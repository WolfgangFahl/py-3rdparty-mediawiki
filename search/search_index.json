{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-3rdparty-mediawiki API Documentation","text":""},{"location":"#wikibot3rd.crypt","title":"<code>crypt</code>","text":"<p>Created on 25.03.2020</p> <p>@author: wf</p>"},{"location":"#wikibot3rd.crypt.Crypt","title":"<code>Crypt</code>","text":"<p>               Bases: <code>object</code></p> <p>Python implementation of PBEWithMD5AndDES see https://github.com/binsgit/PBEWithMD5AndDES and https://gist.github.com/rohitshampur/da5f79c34260150aafc1</p> <p>converted to class</p> Source code in <code>wikibot3rd/crypt.py</code> <pre><code>class Crypt(object):\n    \"\"\"\n    Python implementation of PBEWithMD5AndDES\n    see\n    https://github.com/binsgit/PBEWithMD5AndDES\n    and\n    https://gist.github.com/rohitshampur/da5f79c34260150aafc1\n\n    converted to class\"\"\"\n\n    def __init__(self, cypher, iterations=20, salt=None):\n        \"\"\"construct me with the given cypher iterations and salt\"\"\"\n        # avoid annoying\n        #  /opt/local/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/Crypto/Cipher/blockalgo.py:141: DeprecationWarning: PY_SSIZE_T_CLEAN will be required for '#' formats\n        warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\n        self.cypher = cypher.encode(\"utf-8\")\n        self.iterations = iterations\n        if salt is None:\n            self.salt = os.urandom(8)\n        else:\n            self.salt = salt.encode(\"utf-8\")\n        pass\n\n    @staticmethod\n    def getRandomString(rlen=32):\n        # https://docs.python.org/3/library/secrets.html\n        alphabet = string.ascii_letters + string.digits\n        rstring = \"\".join(secrets.choice(alphabet) for i in range(rlen))\n        return rstring\n\n    @staticmethod\n    def getRandomCrypt(cypherLen=32):\n        cypher = Crypt.getRandomString(cypherLen)\n        salt = Crypt.getRandomString(8)\n        crypt = Crypt(cypher, salt=salt)\n        return crypt\n\n    def getCrypt(self):\n        \"\"\"\n        get my DES crypt\n        \"\"\"\n        hasher = MD5.new()\n        hasher.update(self.cypher)\n        hasher.update(self.salt)\n        result = hasher.digest()\n\n        # iterate over hashes\n        for _i in range(1, self.iterations):\n            hasher = MD5.new()\n            hasher.update(result)\n            result = hasher.digest()\n        key = result[:8]\n        # initialization vector\n        iv = result[8:16]\n        return DES.new(key, DES.MODE_CBC, iv)\n\n    def encrypt(self, msg: str):\n        \"\"\"\n        encrypt the given message\n        \"\"\"\n        if not msg:\n            ValueError(\"encrypt needs something to encrypt\")\n        plaintext_to_encrypt = msg\n        # Pad plaintext per RFC 2898 Section 6.1\n        padding = 8 - len(plaintext_to_encrypt) % 8\n        plaintext_to_encrypt += chr(padding) * padding\n        encoder = self.getCrypt()\n        encrypted = encoder.encrypt(plaintext_to_encrypt.encode(\"utf-8\"))\n        b64enc = base64.b64encode(encrypted).decode(\"utf-8\")\n        return b64enc\n\n    def decrypt(self, encoded):\n        \"\"\"\n        decrypt the given message\n        \"\"\"\n        enc = base64.b64decode(encoded)\n        decoder = self.getCrypt()\n        decryptedb = decoder.decrypt(enc)\n        decrypted = decryptedb.decode(\"utf-8\")\n        return decrypted.rstrip(\"\\2,\\1,\\3,\\4,\\5,\\6,\\7,\\0,\\b\")\n</code></pre>"},{"location":"#wikibot3rd.crypt.Crypt.__init__","title":"<code>__init__(cypher, iterations=20, salt=None)</code>","text":"<p>construct me with the given cypher iterations and salt</p> Source code in <code>wikibot3rd/crypt.py</code> <pre><code>def __init__(self, cypher, iterations=20, salt=None):\n    \"\"\"construct me with the given cypher iterations and salt\"\"\"\n    # avoid annoying\n    #  /opt/local/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/Crypto/Cipher/blockalgo.py:141: DeprecationWarning: PY_SSIZE_T_CLEAN will be required for '#' formats\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n\n    self.cypher = cypher.encode(\"utf-8\")\n    self.iterations = iterations\n    if salt is None:\n        self.salt = os.urandom(8)\n    else:\n        self.salt = salt.encode(\"utf-8\")\n    pass\n</code></pre>"},{"location":"#wikibot3rd.crypt.Crypt.decrypt","title":"<code>decrypt(encoded)</code>","text":"<p>decrypt the given message</p> Source code in <code>wikibot3rd/crypt.py</code> <pre><code>def decrypt(self, encoded):\n    \"\"\"\n    decrypt the given message\n    \"\"\"\n    enc = base64.b64decode(encoded)\n    decoder = self.getCrypt()\n    decryptedb = decoder.decrypt(enc)\n    decrypted = decryptedb.decode(\"utf-8\")\n    return decrypted.rstrip(\"\\2,\\1,\\3,\\4,\\5,\\6,\\7,\\0,\\b\")\n</code></pre>"},{"location":"#wikibot3rd.crypt.Crypt.encrypt","title":"<code>encrypt(msg)</code>","text":"<p>encrypt the given message</p> Source code in <code>wikibot3rd/crypt.py</code> <pre><code>def encrypt(self, msg: str):\n    \"\"\"\n    encrypt the given message\n    \"\"\"\n    if not msg:\n        ValueError(\"encrypt needs something to encrypt\")\n    plaintext_to_encrypt = msg\n    # Pad plaintext per RFC 2898 Section 6.1\n    padding = 8 - len(plaintext_to_encrypt) % 8\n    plaintext_to_encrypt += chr(padding) * padding\n    encoder = self.getCrypt()\n    encrypted = encoder.encrypt(plaintext_to_encrypt.encode(\"utf-8\"))\n    b64enc = base64.b64encode(encrypted).decode(\"utf-8\")\n    return b64enc\n</code></pre>"},{"location":"#wikibot3rd.crypt.Crypt.getCrypt","title":"<code>getCrypt()</code>","text":"<p>get my DES crypt</p> Source code in <code>wikibot3rd/crypt.py</code> <pre><code>def getCrypt(self):\n    \"\"\"\n    get my DES crypt\n    \"\"\"\n    hasher = MD5.new()\n    hasher.update(self.cypher)\n    hasher.update(self.salt)\n    result = hasher.digest()\n\n    # iterate over hashes\n    for _i in range(1, self.iterations):\n        hasher = MD5.new()\n        hasher.update(result)\n        result = hasher.digest()\n    key = result[:8]\n    # initialization vector\n    iv = result[8:16]\n    return DES.new(key, DES.MODE_CBC, iv)\n</code></pre>"},{"location":"#wikibot3rd.lambda_action","title":"<code>lambda_action</code>","text":"<p>Created on 31.01.2021</p> <p>@author: wf</p>"},{"location":"#wikibot3rd.lambda_action.Code","title":"<code>Code</code>","text":"<p>               Bases: <code>object</code></p> <p>a piece of code</p> Source code in <code>wikibot3rd/lambda_action.py</code> <pre><code>class Code(object):\n    \"\"\"\n    a piece of code\n    \"\"\"\n\n    def __init__(self, name: str, text: str, lang: str = \"python\"):\n        \"\"\"\n        construct me from the given text and language\n        \"\"\"\n        self.name = name\n        self.text = text\n        self.lang = lang\n\n    def execute(self, context):\n        \"\"\"\n        https://stackoverflow.com/questions/701802/how-do-i-execute-a-string-containing-python-code-in-python\n        https://stackoverflow.com/questions/436198/what-is-an-alternative-to-execfile-in-python-3\n        https://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile\n        \"\"\"\n        if self.lang == \"jinja\":\n            self.executeTemplate(context)\n        else:\n            exec(self.text)\n        pass\n\n    def executeTemplate(self, context):\n        \"\"\"\n        Renders the jinja-template with the query results placed in the given context and stores the result as wiki page.\n        The name of the wiki page is either given through the template with set parameters.\n        E.g.:\n            {% set pagetitle = \"\"%}\n            {% set pagetitle_prefix = \"List of \"%}\n        If the pagetitle is empty, like in the example, the name variable of the query results is used as pagetitle.\n        The pagetitle_prefix is added in all cases, if not defined a empty string is added.\n        Assumption: self.text is a jinja template\n        \"\"\"\n        getAttribute = lambda template, name: re.search(\n            \"\\{% *set +\" + name + \" += *['\\\"](?P&lt;name&gt;.*)['\\\"] *%\\}\", template\n        ).group(\"name\")\n        raw_template = LambdaAction.unescapeHTML(self.text)\n        template = Template(raw_template)\n        title = getAttribute(raw_template, \"pagetitle\")\n        pagetitle_prefix = getAttribute(raw_template, \"pagetitle_prefix\")\n        if not pagetitle_prefix:\n            pagetitle_prefix = \"\"\n        user = context[\"wikiclient\"].wikiUser.user\n        for row in context[\"rows\"]:\n            page_content = template.render({\"row\": row, \"smw\": context[\"smw\"]})\n            if not title:\n                if not row[\"name\"]:\n                    raise ValueError(\n                        f\"Can't save wikipage without a title. Either provide a page title in the \"\n                        f\"template or provide the name variable for each query result\"\n                    )\n                pagetitle = pagetitle_prefix + row[\"name\"]\n            else:\n                pagetitle = pagetitle_prefix + title\n            page = context[\"wikiclient\"].getPage(pagetitle)\n            # ToDo\n            page.edit(\n                page_content,\n                f\"Created with the template [[{self.name}]] by {user} through LambdaActions\",\n            )\n</code></pre>"},{"location":"#wikibot3rd.lambda_action.Code.__init__","title":"<code>__init__(name, text, lang='python')</code>","text":"<p>construct me from the given text and language</p> Source code in <code>wikibot3rd/lambda_action.py</code> <pre><code>def __init__(self, name: str, text: str, lang: str = \"python\"):\n    \"\"\"\n    construct me from the given text and language\n    \"\"\"\n    self.name = name\n    self.text = text\n    self.lang = lang\n</code></pre>"},{"location":"#wikibot3rd.lambda_action.Code.execute","title":"<code>execute(context)</code>","text":"<p>https://stackoverflow.com/questions/701802/how-do-i-execute-a-string-containing-python-code-in-python https://stackoverflow.com/questions/436198/what-is-an-alternative-to-execfile-in-python-3 https://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile</p> Source code in <code>wikibot3rd/lambda_action.py</code> <pre><code>def execute(self, context):\n    \"\"\"\n    https://stackoverflow.com/questions/701802/how-do-i-execute-a-string-containing-python-code-in-python\n    https://stackoverflow.com/questions/436198/what-is-an-alternative-to-execfile-in-python-3\n    https://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile\n    \"\"\"\n    if self.lang == \"jinja\":\n        self.executeTemplate(context)\n    else:\n        exec(self.text)\n    pass\n</code></pre>"},{"location":"#wikibot3rd.lambda_action.Code.executeTemplate","title":"<code>executeTemplate(context)</code>","text":"<p>Renders the jinja-template with the query results placed in the given context and stores the result as wiki page. The name of the wiki page is either given through the template with set parameters. E.g.:     {% set pagetitle = \"\"%}     {% set pagetitle_prefix = \"List of \"%} If the pagetitle is empty, like in the example, the name variable of the query results is used as pagetitle. The pagetitle_prefix is added in all cases, if not defined a empty string is added. Assumption: self.text is a jinja template</p> Source code in <code>wikibot3rd/lambda_action.py</code> <pre><code>def executeTemplate(self, context):\n    \"\"\"\n    Renders the jinja-template with the query results placed in the given context and stores the result as wiki page.\n    The name of the wiki page is either given through the template with set parameters.\n    E.g.:\n        {% set pagetitle = \"\"%}\n        {% set pagetitle_prefix = \"List of \"%}\n    If the pagetitle is empty, like in the example, the name variable of the query results is used as pagetitle.\n    The pagetitle_prefix is added in all cases, if not defined a empty string is added.\n    Assumption: self.text is a jinja template\n    \"\"\"\n    getAttribute = lambda template, name: re.search(\n        \"\\{% *set +\" + name + \" += *['\\\"](?P&lt;name&gt;.*)['\\\"] *%\\}\", template\n    ).group(\"name\")\n    raw_template = LambdaAction.unescapeHTML(self.text)\n    template = Template(raw_template)\n    title = getAttribute(raw_template, \"pagetitle\")\n    pagetitle_prefix = getAttribute(raw_template, \"pagetitle_prefix\")\n    if not pagetitle_prefix:\n        pagetitle_prefix = \"\"\n    user = context[\"wikiclient\"].wikiUser.user\n    for row in context[\"rows\"]:\n        page_content = template.render({\"row\": row, \"smw\": context[\"smw\"]})\n        if not title:\n            if not row[\"name\"]:\n                raise ValueError(\n                    f\"Can't save wikipage without a title. Either provide a page title in the \"\n                    f\"template or provide the name variable for each query result\"\n                )\n            pagetitle = pagetitle_prefix + row[\"name\"]\n        else:\n            pagetitle = pagetitle_prefix + title\n        page = context[\"wikiclient\"].getPage(pagetitle)\n        # ToDo\n        page.edit(\n            page_content,\n            f\"Created with the template [[{self.name}]] by {user} through LambdaActions\",\n        )\n</code></pre>"},{"location":"#wikibot3rd.lambda_action.LambdaAction","title":"<code>LambdaAction</code>","text":"<p>               Bases: <code>object</code></p> <p>a lambda action</p> Source code in <code>wikibot3rd/lambda_action.py</code> <pre><code>class LambdaAction(object):\n    \"\"\"\n    a lambda action\n    \"\"\"\n\n    def __init__(self, name: str, query: Query, code: Code):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.name = name\n        self.query = query\n        self.code = code\n\n    def executeQuery(self, context):\n        rows = None\n        if self.query.lang == \"sql\":\n            if \"sqlDB\" in context:\n                db = context[\"sqlDB\"]\n                rows = db.query(self.query.query)\n        elif self.query.lang == \"sparql\":\n            # ToDo\n            pass\n        elif self.query.lang == \"smw\":\n            if \"smw\" in context:\n                smw = context[\"smw\"]\n                query = LambdaAction.unescapeHTML(self.query.query)\n                query_results = smw.query(query)\n                rows = list(query_results.values())\n        else:\n            print(\n                f\"Queries of type {self.query.lang} are currently not supported by LambdaActions.\"\n            )\n        context[\"rows\"] = rows\n        return rows\n\n    def getMessage(self, context):\n        message = None\n        if \"result\" in context:\n            result = context[\"result\"]\n            if \"message\" in result:\n                message = result[\"message\"]\n        return message\n\n    def execute(self, context):\n        \"\"\"\n        run my query and feed the result into the given code\n\n        Args:\n            context(dict): a dictionary for the exchange of parameters\n        \"\"\"\n        self.executeQuery(context)\n        self.code.execute(context)\n\n    @staticmethod\n    def unescapeHTML(value: str):\n        \"\"\"\n        Unescapes received html value and removes html tags.\n        Replaces:\n            &lt;br /&gt; -&gt; \"\\n\"\n            &lt;pre&gt; -&gt; \"\"\n        Args:\n            value(str): html encoded string\n        Returns:\n            Returns the received value but without the html tags and unescaped.\n        \"\"\"\n        if value.startswith(\"&lt;pre&gt;\"):\n            return html.unescape(value).replace(\"&lt;br /&gt;\", \"\\n\")[5:][:-6]\n        return value\n</code></pre>"},{"location":"#wikibot3rd.lambda_action.LambdaAction.__init__","title":"<code>__init__(name, query, code)</code>","text":"<p>Constructor</p> Source code in <code>wikibot3rd/lambda_action.py</code> <pre><code>def __init__(self, name: str, query: Query, code: Code):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.name = name\n    self.query = query\n    self.code = code\n</code></pre>"},{"location":"#wikibot3rd.lambda_action.LambdaAction.execute","title":"<code>execute(context)</code>","text":"<p>run my query and feed the result into the given code</p> <p>Parameters:</p> Name Type Description Default <code>context(dict)</code> <p>a dictionary for the exchange of parameters</p> required Source code in <code>wikibot3rd/lambda_action.py</code> <pre><code>def execute(self, context):\n    \"\"\"\n    run my query and feed the result into the given code\n\n    Args:\n        context(dict): a dictionary for the exchange of parameters\n    \"\"\"\n    self.executeQuery(context)\n    self.code.execute(context)\n</code></pre>"},{"location":"#wikibot3rd.lambda_action.LambdaAction.unescapeHTML","title":"<code>unescapeHTML(value)</code>  <code>staticmethod</code>","text":"<pre><code>    Unescapes received html value and removes html tags.\n    Replaces:\n        &lt;br /&gt; -&gt; \"\n</code></pre> <p>\"             <pre> -&gt; \"\"\n        Args:\n            value(str): html encoded string\n        Returns:\n            Returns the received value but without the html tags and unescaped.\n\n            \n              Source code in <code>wikibot3rd/lambda_action.py</code>\n              <pre><code>@staticmethod\ndef unescapeHTML(value: str):\n    \"\"\"\n    Unescapes received html value and removes html tags.\n    Replaces:\n        &lt;br /&gt; -&gt; \"\\n\"\n        &lt;pre&gt; -&gt; \"\"\n    Args:\n        value(str): html encoded string\n    Returns:\n        Returns the received value but without the html tags and unescaped.\n    \"\"\"\n    if value.startswith(\"&lt;pre&gt;\"):\n        return html.unescape(value).replace(\"&lt;br /&gt;\", \"\\n\")[5:][:-6]\n    return value\n</code></pre>"},{"location":"#wikibot3rd.mwTable","title":"<code>mwTable</code>","text":"<p>Created on 2020-08-21</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.mwTable.MediaWikiTable","title":"<code>MediaWikiTable</code>","text":"<p>\n              Bases: <code>object</code></p>\n\n\n      <p>helper for https://www.mediawiki.org/wiki/Help:Tables</p>\n\n              \n                Source code in <code>wikibot3rd/mwTable.py</code>\n                <pre><code>class MediaWikiTable(object):\n    \"\"\"\n    helper for https://www.mediawiki.org/wiki/Help:Tables\n    \"\"\"\n\n    def __init__(\n        self, wikiTable=True, colFormats=None, sortable=True, withNewLines=False\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.colFormats = colFormats\n        cssDelim = \"\"\n        if wikiTable:\n            cWikiTable = \"wikitable\"\n            cssDelim = \" \"\n        else:\n            cWikiTable = \"\"\n        if sortable:\n            cSortable = \"sortable\"\n        else:\n            cSortable = \"\"\n\n        self.start = '{|class=\"%s%s%s\"\\n' % (cWikiTable, cssDelim, cSortable)\n        self.header = None\n        self.content = \"\"\n        self.end = \"\\n|}\\n\"\n        self.withNewLines = withNewLines\n        pass\n\n    def addHeader(self, record):\n        \"\"\"\n        add the given record as a \"sample\" header\n        \"\"\"\n        if self.withNewLines:\n            headerStart = \"|+\"\n            firstColDelim = \"\\n!\"\n            colDelim = firstColDelim\n        else:\n            headerStart = \"|+\\n\"\n            firstColDelim = \"!\"\n            colDelim = \"!!\"\n        self.header = headerStart\n        first = True\n        for key in record.keys():\n            if first:\n                delim = firstColDelim\n                first = False\n            else:\n                delim = colDelim\n            self.header += \"%s%s\" % (delim, key)\n\n    def addRow4Dict(self, record):\n        if self.header is None:\n            self.addHeader(record)\n        if self.withNewLines:\n            rowStart = \"\\n|-\"\n            colDelim = \"\\n|\"\n        else:\n            rowStart = \"\\n|-\\n\"\n            colDelim = \"||\"\n        self.content += rowStart\n        for key in record.keys():\n            value = record[key]\n            if self.colFormats is not None and key in self.colFormats:\n                colFormat = self.colFormats[key]\n            else:\n                colFormat = \"%s\"\n            self.content += (\"%s\" + colFormat) % (colDelim, value)\n\n    def fromListOfDicts(self, listOfDicts):\n        for record in listOfDicts:\n            self.addRow4Dict(record)\n        pass\n\n    def noneReplace(self, value):\n        return \"\" if value is None else value\n\n    def asWikiMarkup(self):\n        \"\"\"\n        convert me to MediaWiki markup\n\n        Returns:\n            string: the MediWiki Markup for this table\n        \"\"\"\n        markup = (\n            self.noneReplace(self.start)\n            + self.noneReplace(self.header)\n            + self.noneReplace(self.content)\n            + self.noneReplace(self.end)\n        )\n        return markup\n</code></pre>"},{"location":"#wikibot3rd.mwTable.MediaWikiTable.__init__","title":"<code>__init__(wikiTable=True, colFormats=None, sortable=True, withNewLines=False)</code>","text":"<p>Constructor</p>\n\n            \n              Source code in <code>wikibot3rd/mwTable.py</code>\n              <pre><code>def __init__(\n    self, wikiTable=True, colFormats=None, sortable=True, withNewLines=False\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.colFormats = colFormats\n    cssDelim = \"\"\n    if wikiTable:\n        cWikiTable = \"wikitable\"\n        cssDelim = \" \"\n    else:\n        cWikiTable = \"\"\n    if sortable:\n        cSortable = \"sortable\"\n    else:\n        cSortable = \"\"\n\n    self.start = '{|class=\"%s%s%s\"\\n' % (cWikiTable, cssDelim, cSortable)\n    self.header = None\n    self.content = \"\"\n    self.end = \"\\n|}\\n\"\n    self.withNewLines = withNewLines\n    pass\n</code></pre>"},{"location":"#wikibot3rd.mwTable.MediaWikiTable.addHeader","title":"<code>addHeader(record)</code>","text":"<p>add the given record as a \"sample\" header</p>\n\n            \n              Source code in <code>wikibot3rd/mwTable.py</code>\n              <pre><code>def addHeader(self, record):\n    \"\"\"\n    add the given record as a \"sample\" header\n    \"\"\"\n    if self.withNewLines:\n        headerStart = \"|+\"\n        firstColDelim = \"\\n!\"\n        colDelim = firstColDelim\n    else:\n        headerStart = \"|+\\n\"\n        firstColDelim = \"!\"\n        colDelim = \"!!\"\n    self.header = headerStart\n    first = True\n    for key in record.keys():\n        if first:\n            delim = firstColDelim\n            first = False\n        else:\n            delim = colDelim\n        self.header += \"%s%s\" % (delim, key)\n</code></pre>"},{"location":"#wikibot3rd.mwTable.MediaWikiTable.asWikiMarkup","title":"<code>asWikiMarkup()</code>","text":"<p>convert me to MediaWiki markup</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>string</code>            \n            \n            \n              \n                <p>the MediWiki Markup for this table</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/mwTable.py</code>\n              <pre><code>def asWikiMarkup(self):\n    \"\"\"\n    convert me to MediaWiki markup\n\n    Returns:\n        string: the MediWiki Markup for this table\n    \"\"\"\n    markup = (\n        self.noneReplace(self.start)\n        + self.noneReplace(self.header)\n        + self.noneReplace(self.content)\n        + self.noneReplace(self.end)\n    )\n    return markup\n</code></pre>"},{"location":"#wikibot3rd.pagehistory","title":"<code>pagehistory</code>","text":""},{"location":"#wikibot3rd.pagehistory.PageHistory","title":"<code>PageHistory</code>","text":"<p>Represents the history of a page</p>\n\n              \n                Source code in <code>wikibot3rd/pagehistory.py</code>\n                <pre><code>class PageHistory:\n    \"\"\"\n    Represents the history of a page\n    \"\"\"\n\n    def __init__(self, pageTitle: str, wikiId: str, debug: bool = False):\n        \"\"\"\n        Constructor\n\n        Args:\n            pageTitle(str): name of the page\n            wikiId(str): id of the wiki the page is located\n            debug(bool): If True show debug messages\n        \"\"\"\n        self.debug = debug\n        self.pageTitle = pageTitle\n        self.wikiClient = WikiClient.ofWikiId(wikiId, debug=self.debug)\n        self.page = self.wikiClient.getPage(pageTitle)\n        self.revisions = self._getRevisions()\n\n    def _getRevisions(self) -&gt; List[PageRevision]:\n        \"\"\"\n        Get the revisions of the page as PageRevision object\n\n        Returns:\n            List of PageRevisions of the page\n        \"\"\"\n        revisions = []\n        for revisionRecord in self.page.revisions(\n            prop=\"ids|timestamp|user|userid|comment|size\"\n        ):\n            revision = PageRevision()\n            revision.fromDict(revisionRecord)\n            revisions.append(revision)\n        return revisions\n\n    def exists(self) -&gt; bool:\n        \"\"\"\n        Checks if the page exists\n        Assumption: If the page exists than ot exists at least one revision entry\n\n        Returns:\n            True if the page exists otherwise False\n        \"\"\"\n        return len(self.revisions) &gt; 0\n\n    def getFirstUser(\n        self, reverse: bool = False, limitedUserGroup: List[str] = None\n    ) -&gt; Union[str, None]:\n        \"\"\"\n        Returns the first user in the revisions\n\n        Args:\n            reverse(bool): If False start the search at the oldest entry. Otherwise, search from the newest to the oldest revision\n            limitedUserGroup(list): limit the search to the given list. If None all users will be considered.\n\n        Returns:\n            str username that matches the search criterion\n        \"\"\"\n        revisions = self.revisions\n        revisions.sort(key=lambda r: int(getattr(r, \"revid\", 0)))\n        if reverse:\n            revisions = reversed(revisions)\n        for revision in revisions:\n            user = getattr(revision, \"user\", None)\n            if user is None:\n                continue\n            if limitedUserGroup is None:\n                return user\n            elif user in limitedUserGroup:\n                return user\n        return None\n</code></pre>"},{"location":"#wikibot3rd.pagehistory.PageHistory.__init__","title":"<code>__init__(pageTitle, wikiId, debug=False)</code>","text":"<p>Constructor</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>pageTitle(str)</code>\n            \n            \n            \n              \n                <p>name of the page</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>wikiId(str)</code>\n            \n            \n            \n              \n                <p>id of the wiki the page is located</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>debug(bool)</code>\n            \n            \n            \n              \n                <p>If True show debug messages</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/pagehistory.py</code>\n              <pre><code>def __init__(self, pageTitle: str, wikiId: str, debug: bool = False):\n    \"\"\"\n    Constructor\n\n    Args:\n        pageTitle(str): name of the page\n        wikiId(str): id of the wiki the page is located\n        debug(bool): If True show debug messages\n    \"\"\"\n    self.debug = debug\n    self.pageTitle = pageTitle\n    self.wikiClient = WikiClient.ofWikiId(wikiId, debug=self.debug)\n    self.page = self.wikiClient.getPage(pageTitle)\n    self.revisions = self._getRevisions()\n</code></pre>"},{"location":"#wikibot3rd.pagehistory.PageHistory.exists","title":"<code>exists()</code>","text":"<p>Checks if the page exists\nAssumption: If the page exists than ot exists at least one revision entry</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>bool</code>\n            \n            \n              \n                <p>True if the page exists otherwise False</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/pagehistory.py</code>\n              <pre><code>def exists(self) -&gt; bool:\n    \"\"\"\n    Checks if the page exists\n    Assumption: If the page exists than ot exists at least one revision entry\n\n    Returns:\n        True if the page exists otherwise False\n    \"\"\"\n    return len(self.revisions) &gt; 0\n</code></pre>"},{"location":"#wikibot3rd.pagehistory.PageHistory.getFirstUser","title":"<code>getFirstUser(reverse=False, limitedUserGroup=None)</code>","text":"<p>Returns the first user in the revisions</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>reverse(bool)</code>\n            \n            \n            \n              \n                <p>If False start the search at the oldest entry. Otherwise, search from the newest to the oldest revision</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>limitedUserGroup(list)</code>\n            \n            \n            \n              \n                <p>limit the search to the given list. If None all users will be considered.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>Union[str, None]</code>\n            \n            \n              \n                <p>str username that matches the search criterion</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/pagehistory.py</code>\n              <pre><code>def getFirstUser(\n    self, reverse: bool = False, limitedUserGroup: List[str] = None\n) -&gt; Union[str, None]:\n    \"\"\"\n    Returns the first user in the revisions\n\n    Args:\n        reverse(bool): If False start the search at the oldest entry. Otherwise, search from the newest to the oldest revision\n        limitedUserGroup(list): limit the search to the given list. If None all users will be considered.\n\n    Returns:\n        str username that matches the search criterion\n    \"\"\"\n    revisions = self.revisions\n    revisions.sort(key=lambda r: int(getattr(r, \"revid\", 0)))\n    if reverse:\n        revisions = reversed(revisions)\n    for revision in revisions:\n        user = getattr(revision, \"user\", None)\n        if user is None:\n            continue\n        if limitedUserGroup is None:\n            return user\n        elif user in limitedUserGroup:\n            return user\n    return None\n</code></pre>"},{"location":"#wikibot3rd.pagehistory.PageRevision","title":"<code>PageRevision</code>","text":"<p>\n              Bases: <code>JSONAble</code></p>\n\n\n      <p>Represents the metadata of a mediawiki page revision</p>\n\n              \n                Source code in <code>wikibot3rd/pagehistory.py</code>\n                <pre><code>class PageRevision(JSONAble):\n    \"\"\"\n    Represents the metadata of a mediawiki page revision\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"revid\": 7056,\n                \"parentid\": 0,\n                \"user\": \"127.0.0.1\",\n                \"anon\": \"\",\n                \"userid\": 0,\n                \"timestamp\": \"2008-10-14T21:23:09Z\",\n                \"size\": 6905,\n                \"comment\": \"Event created\",\n            },\n            {\n                \"revid\": 8195,\n                \"parentid\": 8194,\n                \"user\": \"Wf\",\n                \"timestamp\": \"2021-11-11T12:50:31Z\",\n                \"size\": 910,\n                \"comment\": \"\",\n            },\n        ]\n        return samples\n\n    def __repr__(self):\n        props = \", \".join([f\"{k}={str(v)}\" for k, v in self.__dict__.items()])\n        return f\"{self.__class__.__name__}({props})\"\n</code></pre>"},{"location":"#wikibot3rd.selector","title":"<code>selector</code>","text":"<p>Created on 2020-12-20</p>"},{"location":"#wikibot3rd.selector.Selector","title":"<code>Selector</code>","text":"<p>selector class</p>\n\n              \n                Source code in <code>wikibot3rd/selector.py</code>\n                <pre><code>class Selector:\n    \"\"\"\n    selector class\n    \"\"\"\n\n    def __init__(self, items):\n        \"\"\"\n        Constructor\n        \"\"\"\n        import tkinter as tk\n\n        self.items = items\n        self.items = list(map(str, self.items))\n        self.var = dict()\n        self.count = 1\n        self.checkvar = tk.IntVar(value=1)\n        self.label_test = tk.StringVar()\n        self.label_test.set(\"Select None\")\n        self.quitProgram = False\n\n    def createWindow(self, root, action, title, description):\n        \"\"\"\n         create the Window for the selection list\n         Args:\n            root(tk.App Object): tk.App opened object\n            action(str): Type of Action\n            title(str): Title of Window\n            description(str): Description of Task to do\n        Returns:\n            None\n        \"\"\"\n        import tkinter as tk\n\n        # Title\n        rowCounter = 0\n        root.title(title)  # set window title to given title string\n        root.resizable(1, 1)  # set so the window can be resized by user\n\n        # finding optimal window size\n        items_by_len = sorted(self.items, key=len)\n        longest_string = items_by_len[-1]\n\n        # Setting Message to description string\n        desc = tk.Message(root, text=description)\n        desc.bind(\"&lt;Configure&gt;\", lambda e: desc.configure(width=e.width - 10))\n        desc.pack(side=\"top\", fill=tk.X)\n\n        # Frame creation for Listbox\n        frameList = tk.Frame(root)\n\n        items = tk.StringVar(root)\n        items.set(self.items)\n        listbox = tk.Listbox(\n            frameList,\n            listvariable=items,\n            selectmode=\"multiple\",\n            width=len(longest_string) + 5,\n        )\n        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        listbox.select_set(0, tk.END)\n\n        # Frame creation for select all/none checkbox\n        frameSelect = tk.Frame(root)\n        frameSelect.pack(side=tk.TOP, fill=tk.BOTH)\n        frameList.pack(fill=tk.BOTH, expand=True)\n\n        # label and checkbutton creation\n        label = tk.Label(frameSelect, textvariable=self.label_test)\n        check = tk.Checkbutton(\n            frameSelect,\n            text=\"\",\n            variable=self.checkvar,\n            command=lambda: self.select_all(listbox),\n        )\n        check.pack(side=tk.LEFT, anchor=\"sw\")\n        label.pack(side=tk.LEFT, anchor=\"sw\")\n\n        # Scrollbar binding and creation\n        scrollbar = tk.Scrollbar(frameList)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.BOTH)\n        listbox.config(yscrollcommand=scrollbar.set)\n        scrollbar.config(command=listbox.yview)\n        listbox.bind(\"&lt;&lt;ListboxSelect&gt;&gt;\", self.updateCheck)\n\n        # Frame for Action and Quit Buttons\n        frameControl = tk.Frame(root)\n        frameControl.pack(side=tk.BOTTOM, fill=tk.X)\n\n        # Action and Quit button creation\n        actionBtn = tk.Button(\n            frameControl,\n            text=action,\n            bg=\"green\",\n            fg=\"white\",\n            command=lambda: self.updatePages(root, listbox),\n        )\n        actionBtn.pack(side=tk.LEFT, anchor=\"sw\")\n        quitBtn = tk.Button(\n            frameControl,\n            text=\"Quit\",\n            bg=\"red\",\n            fg=\"white\",\n            command=lambda: self.quitSelector(root),\n        )\n        quitBtn.pack(side=tk.RIGHT, anchor=\"se\")\n\n        # To destroy window and exit program if cross button is pressed\n        root.protocol(\"WM_DELETE_WINDOW\", lambda: self.quitSelector(root))\n\n    def updateCheck(self, event):\n        \"\"\"\n        Helper function to change state of select all checkbox\n        Returns:\n            event(Tk event Object): All registered events on Tkinter\n        \"\"\"\n        if len(event.widget.curselection()) &lt; len(\n            self.items\n        ):  # check if any item is deselected\n            self.label_test.set(\"Select All\")\n            self.checkvar.set(0)\n        elif len(event.widget.curselection()) == len(self.items):\n            self.label_test.set(\"Select None\")\n            self.checkvar.set(1)\n\n    def select_all(self, listbox):\n        \"\"\"\n        Button helper function to select all list items\n        Returns:\n            listbox(Tk Listbox Object): listbox to update to all items\n        \"\"\"\n        import tkinter as tk\n\n        if self.checkvar.get():\n            listbox.select_set(0, tk.END)\n            self.label_test.set(\"Select None\")\n        else:\n            listbox.select_clear(0, tk.END)\n            self.label_test.set(\"Select All\")\n\n    def updatePages(self, root, listbox):\n        \"\"\"\n        Update function to remove unselected items from list\n        Args:\n            root(tk.App Object): tk.App opened object\n            listbox(TK listbox Object): listbox to update\n        Returns:\n            None\n        \"\"\"\n        self.items = [\n            listbox.get(idx) for idx in listbox.curselection()\n        ]  # Remove unselected items from list\n        root.destroy()\n\n    def quitSelector(self, root):\n        \"\"\"\n        Quit the python program when Quit Button is pressed.\n        Args:\n            root(tk.App Object): tk.App opened object\n        Returns:\n            None\n        \"\"\"\n        root.destroy()\n        self.items = \"Q\"\n\n    def getUpdatedPages(self):\n        \"\"\"\n        Getter function for the class variable items\n        Returns:\n            items(list): List of pages selected in GUI by user\n        \"\"\"\n        return self.items\n\n    @staticmethod\n    def select(selectionList, action=\"Select\", title=\"Selection\", description=\"\"):\n        \"\"\"\n        Creates a GUI in which the user can select a subset of the provided selectionList.\n        The user can quit the selection resulting in the return of an empty list.\n        :param selectionList:\n        :param action: name of the action the selection performs. Default is select\n        :param title: title of the created window\n        :param description: Instructions for the user (consequence of the selection)\n        :return: user selected subset of the given selectionList\n        \"\"\"\n        import tkinter as tk\n\n        root = tk.Tk()\n        GUI = Selector(selectionList)  # Tkinter Object creation\n        GUI.createWindow(\n            root, action, title, description\n        )  # create Window with given parameters\n        root.mainloop()  # Run GUI loop\n        selectionList = GUI.getUpdatedPages()  # Get selected items\n        return selectionList\n</code></pre>"},{"location":"#wikibot3rd.selector.Selector.__init__","title":"<code>__init__(items)</code>","text":"<p>Constructor</p>\n\n            \n              Source code in <code>wikibot3rd/selector.py</code>\n              <pre><code>def __init__(self, items):\n    \"\"\"\n    Constructor\n    \"\"\"\n    import tkinter as tk\n\n    self.items = items\n    self.items = list(map(str, self.items))\n    self.var = dict()\n    self.count = 1\n    self.checkvar = tk.IntVar(value=1)\n    self.label_test = tk.StringVar()\n    self.label_test.set(\"Select None\")\n    self.quitProgram = False\n</code></pre>"},{"location":"#wikibot3rd.selector.Selector.createWindow","title":"<code>createWindow(root, action, title, description)</code>","text":"<p>create the Window for the selection list\n Args:\n    root(tk.App Object): tk.App opened object\n    action(str): Type of Action\n    title(str): Title of Window\n    description(str): Description of Task to do\nReturns:\n    None</p>\n\n            \n              Source code in <code>wikibot3rd/selector.py</code>\n              <pre><code>def createWindow(self, root, action, title, description):\n    \"\"\"\n     create the Window for the selection list\n     Args:\n        root(tk.App Object): tk.App opened object\n        action(str): Type of Action\n        title(str): Title of Window\n        description(str): Description of Task to do\n    Returns:\n        None\n    \"\"\"\n    import tkinter as tk\n\n    # Title\n    rowCounter = 0\n    root.title(title)  # set window title to given title string\n    root.resizable(1, 1)  # set so the window can be resized by user\n\n    # finding optimal window size\n    items_by_len = sorted(self.items, key=len)\n    longest_string = items_by_len[-1]\n\n    # Setting Message to description string\n    desc = tk.Message(root, text=description)\n    desc.bind(\"&lt;Configure&gt;\", lambda e: desc.configure(width=e.width - 10))\n    desc.pack(side=\"top\", fill=tk.X)\n\n    # Frame creation for Listbox\n    frameList = tk.Frame(root)\n\n    items = tk.StringVar(root)\n    items.set(self.items)\n    listbox = tk.Listbox(\n        frameList,\n        listvariable=items,\n        selectmode=\"multiple\",\n        width=len(longest_string) + 5,\n    )\n    listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n    listbox.select_set(0, tk.END)\n\n    # Frame creation for select all/none checkbox\n    frameSelect = tk.Frame(root)\n    frameSelect.pack(side=tk.TOP, fill=tk.BOTH)\n    frameList.pack(fill=tk.BOTH, expand=True)\n\n    # label and checkbutton creation\n    label = tk.Label(frameSelect, textvariable=self.label_test)\n    check = tk.Checkbutton(\n        frameSelect,\n        text=\"\",\n        variable=self.checkvar,\n        command=lambda: self.select_all(listbox),\n    )\n    check.pack(side=tk.LEFT, anchor=\"sw\")\n    label.pack(side=tk.LEFT, anchor=\"sw\")\n\n    # Scrollbar binding and creation\n    scrollbar = tk.Scrollbar(frameList)\n    scrollbar.pack(side=tk.RIGHT, fill=tk.BOTH)\n    listbox.config(yscrollcommand=scrollbar.set)\n    scrollbar.config(command=listbox.yview)\n    listbox.bind(\"&lt;&lt;ListboxSelect&gt;&gt;\", self.updateCheck)\n\n    # Frame for Action and Quit Buttons\n    frameControl = tk.Frame(root)\n    frameControl.pack(side=tk.BOTTOM, fill=tk.X)\n\n    # Action and Quit button creation\n    actionBtn = tk.Button(\n        frameControl,\n        text=action,\n        bg=\"green\",\n        fg=\"white\",\n        command=lambda: self.updatePages(root, listbox),\n    )\n    actionBtn.pack(side=tk.LEFT, anchor=\"sw\")\n    quitBtn = tk.Button(\n        frameControl,\n        text=\"Quit\",\n        bg=\"red\",\n        fg=\"white\",\n        command=lambda: self.quitSelector(root),\n    )\n    quitBtn.pack(side=tk.RIGHT, anchor=\"se\")\n\n    # To destroy window and exit program if cross button is pressed\n    root.protocol(\"WM_DELETE_WINDOW\", lambda: self.quitSelector(root))\n</code></pre>"},{"location":"#wikibot3rd.selector.Selector.getUpdatedPages","title":"<code>getUpdatedPages()</code>","text":"<p>Getter function for the class variable items\nReturns:\n    items(list): List of pages selected in GUI by user</p>\n\n            \n              Source code in <code>wikibot3rd/selector.py</code>\n              <pre><code>def getUpdatedPages(self):\n    \"\"\"\n    Getter function for the class variable items\n    Returns:\n        items(list): List of pages selected in GUI by user\n    \"\"\"\n    return self.items\n</code></pre>"},{"location":"#wikibot3rd.selector.Selector.quitSelector","title":"<code>quitSelector(root)</code>","text":"<p>Quit the python program when Quit Button is pressed.\nArgs:\n    root(tk.App Object): tk.App opened object\nReturns:\n    None</p>\n\n            \n              Source code in <code>wikibot3rd/selector.py</code>\n              <pre><code>def quitSelector(self, root):\n    \"\"\"\n    Quit the python program when Quit Button is pressed.\n    Args:\n        root(tk.App Object): tk.App opened object\n    Returns:\n        None\n    \"\"\"\n    root.destroy()\n    self.items = \"Q\"\n</code></pre>"},{"location":"#wikibot3rd.selector.Selector.select","title":"<code>select(selectionList, action='Select', title='Selection', description='')</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Creates a GUI in which the user can select a subset of the provided selectionList.\nThe user can quit the selection resulting in the return of an empty list.\n:param selectionList:\n:param action: name of the action the selection performs. Default is select\n:param title: title of the created window\n:param description: Instructions for the user (consequence of the selection)\n:return: user selected subset of the given selectionList</p>\n\n            \n              Source code in <code>wikibot3rd/selector.py</code>\n              <pre><code>@staticmethod\ndef select(selectionList, action=\"Select\", title=\"Selection\", description=\"\"):\n    \"\"\"\n    Creates a GUI in which the user can select a subset of the provided selectionList.\n    The user can quit the selection resulting in the return of an empty list.\n    :param selectionList:\n    :param action: name of the action the selection performs. Default is select\n    :param title: title of the created window\n    :param description: Instructions for the user (consequence of the selection)\n    :return: user selected subset of the given selectionList\n    \"\"\"\n    import tkinter as tk\n\n    root = tk.Tk()\n    GUI = Selector(selectionList)  # Tkinter Object creation\n    GUI.createWindow(\n        root, action, title, description\n    )  # create Window with given parameters\n    root.mainloop()  # Run GUI loop\n    selectionList = GUI.getUpdatedPages()  # Get selected items\n    return selectionList\n</code></pre>"},{"location":"#wikibot3rd.selector.Selector.select_all","title":"<code>select_all(listbox)</code>","text":"<p>Button helper function to select all list items\nReturns:\n    listbox(Tk Listbox Object): listbox to update to all items</p>\n\n            \n              Source code in <code>wikibot3rd/selector.py</code>\n              <pre><code>def select_all(self, listbox):\n    \"\"\"\n    Button helper function to select all list items\n    Returns:\n        listbox(Tk Listbox Object): listbox to update to all items\n    \"\"\"\n    import tkinter as tk\n\n    if self.checkvar.get():\n        listbox.select_set(0, tk.END)\n        self.label_test.set(\"Select None\")\n    else:\n        listbox.select_clear(0, tk.END)\n        self.label_test.set(\"Select All\")\n</code></pre>"},{"location":"#wikibot3rd.selector.Selector.updateCheck","title":"<code>updateCheck(event)</code>","text":"<p>Helper function to change state of select all checkbox\nReturns:\n    event(Tk event Object): All registered events on Tkinter</p>\n\n            \n              Source code in <code>wikibot3rd/selector.py</code>\n              <pre><code>def updateCheck(self, event):\n    \"\"\"\n    Helper function to change state of select all checkbox\n    Returns:\n        event(Tk event Object): All registered events on Tkinter\n    \"\"\"\n    if len(event.widget.curselection()) &lt; len(\n        self.items\n    ):  # check if any item is deselected\n        self.label_test.set(\"Select All\")\n        self.checkvar.set(0)\n    elif len(event.widget.curselection()) == len(self.items):\n        self.label_test.set(\"Select None\")\n        self.checkvar.set(1)\n</code></pre>"},{"location":"#wikibot3rd.selector.Selector.updatePages","title":"<code>updatePages(root, listbox)</code>","text":"<p>Update function to remove unselected items from list\nArgs:\n    root(tk.App Object): tk.App opened object\n    listbox(TK listbox Object): listbox to update\nReturns:\n    None</p>\n\n            \n              Source code in <code>wikibot3rd/selector.py</code>\n              <pre><code>def updatePages(self, root, listbox):\n    \"\"\"\n    Update function to remove unselected items from list\n    Args:\n        root(tk.App Object): tk.App opened object\n        listbox(TK listbox Object): listbox to update\n    Returns:\n        None\n    \"\"\"\n    self.items = [\n        listbox.get(idx) for idx in listbox.curselection()\n    ]  # Remove unselected items from list\n    root.destroy()\n</code></pre>"},{"location":"#wikibot3rd.smw","title":"<code>smw</code>","text":"<p>Created on 2020-05-29</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.smw.PrintRequest","title":"<code>PrintRequest</code>","text":"<p>\n              Bases: <code>object</code></p>\n\n\n              \n                Source code in <code>wikibot3rd/smw.py</code>\n                <pre><code>class PrintRequest(object):\n    debug = False\n    \"\"\"\n    construct the given print request\n    see https://www.semantic-mediawiki.org/wiki/Serialization_(JSON)\n    :ivar smw: SMW context for this printrequest\n    :ivar label: the label of the printrequest\n    :ivar key:\n    :ivar redi:\n    :ivar typeid:\n    :ivar mode:\n    :ivar format:\n    \"\"\"\n\n    def __init__(self, smw, record):\n        \"\"\"\n        construct me from the given record\n        Args:\n            smw(SMW): the SemanticMediaWiki context of this PrintRequest\n            record(dict): the dict derived from the printrequest json serialization\n        \"\"\"\n        self.smw = smw\n        self.debug = PrintRequest.debug\n        if self.debug:\n            print(record)\n        self.label = record[\"label\"]\n        self.key = record[\"key\"]\n        self.redi = record[\"redi\"]\n        self.typeid = record[\"typeid\"]\n        self.mode = int(record[\"mode\"])\n        if \"format\" in record:\n            self.format = record[\"format\"]\n        else:\n            self.format = None\n\n    def deserializeSingle(self, value):\n        \"\"\"deserialize a single value\n        Args:\n            value(object): the value to be deserialized according to the typeid\n\n        Returns:\n            the deserialized value\n        \"\"\"\n        # FIXME complete list of types according to\n        # https://www.semantic-mediawiki.org/wiki/Help:API:ask\n        # Page https://www.semantic-mediawiki.org/wiki/Help:API:ask/Page\n        if self.typeid == \"_wpg\":\n            value = value[\"fulltext\"]\n            if value:\n                value = unquote(value)\n            pass\n        # Text https://www.semantic-mediawiki.org/wiki/Help:API:ask/Text\n        elif self.typeid == \"_txt\":\n            pass\n        elif self.typeid == \"_qty\":\n            pass\n        elif self.typeid == \"_num\":\n            value = int(value)\n        elif self.typeid == \"_dat\":\n            if \"timestamp\" in value:\n                ts = int(value[\"timestamp\"])\n                try:\n                    # timezone aware\n                    value = datetime.fromtimestamp(ts, tz=timezone.utc)\n                    # naive - for compatibility\n                    value = value.replace(tzinfo=None)\n                    #  print (date.strftime('%Y-%m-%d %H:%M:%S'))\n                except ValueError as ve:\n                    if self.debug:\n                        print(\"Warning timestamp %d is invalid: %s\" % (ts, str(ve)))\n                    pass\n            else:\n                # ignore faulty values\n                if self.debug:\n                    print(\"Warning: timestamp missing for value\")\n                pass\n        elif self.typeid == \"_eid\":\n            pass\n        else:\n            pass\n        return value\n\n    def deserialize(self, result):\n        \"\"\"deserialize the given result record\n        Args:\n            result(dict): a single result record dict from the deserialiation of the ask query\n        Returns:\n            object: a single deserialized value according to my typeid\n        \"\"\"\n        po = result[\"printouts\"]\n        if self.label in po:\n            value = po[self.label]\n        else:\n            value = result\n        if isinstance(value, list):\n            valueList = []\n            for valueItem in value:\n                valueList.append(self.deserializeSingle(valueItem))\n            # handle lists\n            # empty lists =&gt; None\n            if len(valueList) == 0:\n                value = None\n            # lists with one value -&gt; return the item (this unfortunately removes the list property of the value)\n            elif len(valueList) == 1:\n                value = valueList[0]\n            # only if there is a \"real\" list return it\n            else:\n                value = valueList\n        else:\n            value = self.deserializeSingle(value)\n\n        if PrintRequest.debug:\n            print(\"%s(%s)='%s'\" % (self.label, self.typeid, value))\n        return value\n\n    def __repr__(self):\n        text = (\n            \"PrintRequest(label='%s' key='%s' redi='%s' typeid='%s' mode=%d format='%s')\"\n            % (self.label, self.key, self.redi, self.typeid, self.mode, self.format)\n        )\n        return text\n</code></pre>"},{"location":"#wikibot3rd.smw.PrintRequest.debug","title":"<code>debug = PrintRequest.debug</code>\n\n  \n      <code>class-attribute</code>\n      <code>instance-attribute</code>","text":"<p>construct the given print request\nsee https://www.semantic-mediawiki.org/wiki/Serialization_(JSON)\n:ivar smw: SMW context for this printrequest\n:ivar label: the label of the printrequest\n:ivar key:\n:ivar redi:\n:ivar typeid:\n:ivar mode:\n:ivar format:</p>"},{"location":"#wikibot3rd.smw.PrintRequest.__init__","title":"<code>__init__(smw, record)</code>","text":"<p>construct me from the given record\nArgs:\n    smw(SMW): the SemanticMediaWiki context of this PrintRequest\n    record(dict): the dict derived from the printrequest json serialization</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def __init__(self, smw, record):\n    \"\"\"\n    construct me from the given record\n    Args:\n        smw(SMW): the SemanticMediaWiki context of this PrintRequest\n        record(dict): the dict derived from the printrequest json serialization\n    \"\"\"\n    self.smw = smw\n    self.debug = PrintRequest.debug\n    if self.debug:\n        print(record)\n    self.label = record[\"label\"]\n    self.key = record[\"key\"]\n    self.redi = record[\"redi\"]\n    self.typeid = record[\"typeid\"]\n    self.mode = int(record[\"mode\"])\n    if \"format\" in record:\n        self.format = record[\"format\"]\n    else:\n        self.format = None\n</code></pre>"},{"location":"#wikibot3rd.smw.PrintRequest.deserialize","title":"<code>deserialize(result)</code>","text":"<p>deserialize the given result record\nArgs:\n    result(dict): a single result record dict from the deserialiation of the ask query\nReturns:\n    object: a single deserialized value according to my typeid</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def deserialize(self, result):\n    \"\"\"deserialize the given result record\n    Args:\n        result(dict): a single result record dict from the deserialiation of the ask query\n    Returns:\n        object: a single deserialized value according to my typeid\n    \"\"\"\n    po = result[\"printouts\"]\n    if self.label in po:\n        value = po[self.label]\n    else:\n        value = result\n    if isinstance(value, list):\n        valueList = []\n        for valueItem in value:\n            valueList.append(self.deserializeSingle(valueItem))\n        # handle lists\n        # empty lists =&gt; None\n        if len(valueList) == 0:\n            value = None\n        # lists with one value -&gt; return the item (this unfortunately removes the list property of the value)\n        elif len(valueList) == 1:\n            value = valueList[0]\n        # only if there is a \"real\" list return it\n        else:\n            value = valueList\n    else:\n        value = self.deserializeSingle(value)\n\n    if PrintRequest.debug:\n        print(\"%s(%s)='%s'\" % (self.label, self.typeid, value))\n    return value\n</code></pre>"},{"location":"#wikibot3rd.smw.PrintRequest.deserializeSingle","title":"<code>deserializeSingle(value)</code>","text":"<p>deserialize a single value\nArgs:\n    value(object): the value to be deserialized according to the typeid</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n            \n            \n              \n                <p>the deserialized value</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def deserializeSingle(self, value):\n    \"\"\"deserialize a single value\n    Args:\n        value(object): the value to be deserialized according to the typeid\n\n    Returns:\n        the deserialized value\n    \"\"\"\n    # FIXME complete list of types according to\n    # https://www.semantic-mediawiki.org/wiki/Help:API:ask\n    # Page https://www.semantic-mediawiki.org/wiki/Help:API:ask/Page\n    if self.typeid == \"_wpg\":\n        value = value[\"fulltext\"]\n        if value:\n            value = unquote(value)\n        pass\n    # Text https://www.semantic-mediawiki.org/wiki/Help:API:ask/Text\n    elif self.typeid == \"_txt\":\n        pass\n    elif self.typeid == \"_qty\":\n        pass\n    elif self.typeid == \"_num\":\n        value = int(value)\n    elif self.typeid == \"_dat\":\n        if \"timestamp\" in value:\n            ts = int(value[\"timestamp\"])\n            try:\n                # timezone aware\n                value = datetime.fromtimestamp(ts, tz=timezone.utc)\n                # naive - for compatibility\n                value = value.replace(tzinfo=None)\n                #  print (date.strftime('%Y-%m-%d %H:%M:%S'))\n            except ValueError as ve:\n                if self.debug:\n                    print(\"Warning timestamp %d is invalid: %s\" % (ts, str(ve)))\n                pass\n        else:\n            # ignore faulty values\n            if self.debug:\n                print(\"Warning: timestamp missing for value\")\n            pass\n    elif self.typeid == \"_eid\":\n        pass\n    else:\n        pass\n    return value\n</code></pre>"},{"location":"#wikibot3rd.smw.QueryResultSizeExceedException","title":"<code>QueryResultSizeExceedException</code>","text":"<p>\n              Bases: <code>BaseException</code></p>\n\n\n      <p>Raised if the results of a query can not completely be queried due to SMW result limits.</p>\n\n              \n                Source code in <code>wikibot3rd/smw.py</code>\n                <pre><code>class QueryResultSizeExceedException(BaseException):\n    \"\"\"Raised if the results of a query can not completely be queried due to SMW result limits.\"\"\"\n\n    def __init__(\n        self,\n        result=[],\n        message=\"Query can not completely be queried due to SMW result limits.\",\n    ):\n        super().__init__(message)\n        self.result = result\n\n    def getResults(self):\n        \"\"\"Returns the queried results before the exception was raised\"\"\"\n        return self.result\n</code></pre>"},{"location":"#wikibot3rd.smw.QueryResultSizeExceedException.getResults","title":"<code>getResults()</code>","text":"<p>Returns the queried results before the exception was raised</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def getResults(self):\n    \"\"\"Returns the queried results before the exception was raised\"\"\"\n    return self.result\n</code></pre>"},{"location":"#wikibot3rd.smw.SMW","title":"<code>SMW</code>","text":"<p>\n              Bases: <code>object</code></p>\n\n\n      <p>Semantic MediaWiki Access e.g. for ask API\nsee\n* https://www.semantic-mediawiki.org/wiki/Help:API\n* https://www.semantic-mediawiki.org/wiki/Serialization_(JSON)\n* https://www.semantic-mediawiki.org/wiki/Help:API:askargs</p>\n<p>adapted from Java SimpleGraph Module\nhttps://github.com/BITPlan/com.bitplan.simplegraph/blob/master/simplegraph-smw/src/main/java/com/bitplan/simplegraph/smw/SmwSystem.java\n:ivar site: the pywikibot site to use for requests\n:ivar prefix: the path prefix for this site e.g. /wiki/</p>\n\n              \n                Source code in <code>wikibot3rd/smw.py</code>\n                <pre><code>class SMW(object):\n    \"\"\"\n    Semantic MediaWiki Access e.g. for ask API\n    see\n    * https://www.semantic-mediawiki.org/wiki/Help:API\n    * https://www.semantic-mediawiki.org/wiki/Serialization_(JSON)\n    * https://www.semantic-mediawiki.org/wiki/Help:API:askargs\n\n    adapted from Java SimpleGraph Module\n    https://github.com/BITPlan/com.bitplan.simplegraph/blob/master/simplegraph-smw/src/main/java/com/bitplan/simplegraph/smw/SmwSystem.java\n    :ivar site: the pywikibot site to use for requests\n    :ivar prefix: the path prefix for this site e.g. /wiki/\n    \"\"\"\n\n    def __init__(\n        self, site=None, prefix=\"/\", showProgress=False, queryDivision=1, debug=False\n    ):\n        \"\"\"\n        Constructor\n        Args:\n            site: the site to use (optional)\n            showProgess(bool): if progress should be shown\n            queryDivision(int): Defines the number of subintervals the query is divided into (must be greater equal 1)\n            debug(bool): if debugging should be activated - default: False\n        \"\"\"\n        self.site = site\n        self.prefix = prefix\n        self.showProgress = showProgress\n        self.queryDivision = queryDivision\n        self.splitClause = SplitClause()\n        self.debug = debug\n\n    def deserialize(self, rawresult) -&gt; dict:\n        \"\"\"deserialize the given rawresult according to\n        https://www.semantic-mediawiki.org/wiki/Serialization_(JSON)\n\n        Args:\n            rawresult(dict): contains printrequests and results which need to be merged\n\n        Returns:\n            dict: query mainlabel (usually pageTitle) mapped to the corresponding dict of printrequests with label\n        \"\"\"\n        resultDict = {}\n        if rawresult is None:\n            return resultDict\n        if not \"query\" in rawresult:\n            raise Exception(\"invalid query result - 'query' missing\")\n        query = rawresult[\"query\"]\n        if not \"printrequests\" in query:\n            raise Exception(\"invalid query result - 'printrequests' missing\")\n        printrequests = query[\"printrequests\"]\n        if not \"results\" in query:\n            raise Exception(\"invalid query result - 'results' missing\")\n        results = query[\"results\"]\n        prdict = {}\n        for record in printrequests:\n            pr = PrintRequest(self, record)\n            prdict[pr.label] = pr\n\n        if results:\n            for key in results.keys():\n                record = results[key]\n                recordDict = {}\n                for label in prdict.keys():\n                    pr = prdict[label]\n                    recordDict[label] = pr.deserialize(record)\n                resultDict[key] = recordDict\n        return resultDict\n\n    def fixAsk(self, ask: str):\n        \"\"\"\n        fix an ask String to be usable for the API\n        Args:\n            ask: - a \"normal\" ask query\n\n        Returns:\n             the fixed asked query\n        \"\"\"\n        # ^\\\\s*\\\\{\\\\{\n        # remove {{ with surrounding white space at beginning\n        fixedAsk = re.sub(r\"^\\s*\\{\\{\", \"\", ask)\n        # remove #ask:\n        fixedAsk = re.sub(r\"#ask:\", \"\", fixedAsk)\n        # remove }} with surrounding white space at end\n        fixedAsk = re.sub(r\"\\}\\}\\s*$\", \"\", fixedAsk)\n        # split by lines (with side effect to remove newlines)\n        parts = fixedAsk.split(r\"\\n\")\n        fixedAsk = \"\"\n        for part in parts:\n            #  remove whitespace around part\n            part = part.strip()\n            # remove whitespace around pipe sign\n            part = re.sub(r\"\\s*\\|\\s*\", \"|\", part)\n            # remove whitespace around assignment =\n            part = re.sub(r\"\\s*=\\s*\", \"=\", part)\n            # remove whitespace in query parts\n            part = re.sub(r\"\\]\\s*\\[\", \"][\", part)\n            fixedAsk = fixedAsk + part\n        return fixedAsk\n\n    def getConcept(self, ask):\n        \"\"\"get the concept from the given ask query\"\"\"\n        m = re.search(r\"\\[\\[Concept:(.+?)\\]\\]\", ask)\n        if m:\n            return m.groups()[0]\n        else:\n            return None\n\n    argumentRegex = staticmethod(lambda arg: r\"\\| *\" + arg + r\" *= *\\d+(?=\\s|\\||$)\")\n\n    @staticmethod\n    def getOuterMostArgumentValueOfQuery(argument, query):\n        \"\"\"\n        Extracts the integer value of the given argument from the given query\n        Args:\n            argument(string): Argument that should be extracted\n            query(string): smw query where the given argument is assumed\n\n        Returns:\n            Returns integer value of the given argument in the given query.\n            If the argument occurs multiple times the last one is returned.\n            If it does not occur return None.\n        \"\"\"\n        if not argument or not query:\n            return None\n        args = re.compile(SMW.argumentRegex(argument), re.IGNORECASE).findall(query)\n        if not args:\n            return None\n        return int(re.compile(\"[0-9]+\").search(args[-1]).group())\n</code></pre>"},{"location":"#wikibot3rd.smw.SMW.__init__","title":"<code>__init__(site=None, prefix='/', showProgress=False, queryDivision=1, debug=False)</code>","text":"<p>Constructor\nArgs:\n    site: the site to use (optional)\n    showProgess(bool): if progress should be shown\n    queryDivision(int): Defines the number of subintervals the query is divided into (must be greater equal 1)\n    debug(bool): if debugging should be activated - default: False</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def __init__(\n    self, site=None, prefix=\"/\", showProgress=False, queryDivision=1, debug=False\n):\n    \"\"\"\n    Constructor\n    Args:\n        site: the site to use (optional)\n        showProgess(bool): if progress should be shown\n        queryDivision(int): Defines the number of subintervals the query is divided into (must be greater equal 1)\n        debug(bool): if debugging should be activated - default: False\n    \"\"\"\n    self.site = site\n    self.prefix = prefix\n    self.showProgress = showProgress\n    self.queryDivision = queryDivision\n    self.splitClause = SplitClause()\n    self.debug = debug\n</code></pre>"},{"location":"#wikibot3rd.smw.SMW.deserialize","title":"<code>deserialize(rawresult)</code>","text":"<p>deserialize the given rawresult according to\nhttps://www.semantic-mediawiki.org/wiki/Serialization_(JSON)</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>rawresult(dict)</code>\n            \n            \n            \n              \n                <p>contains printrequests and results which need to be merged</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>dict</code>            \n                  <code>dict</code>\n            \n            \n              \n                <p>query mainlabel (usually pageTitle) mapped to the corresponding dict of printrequests with label</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def deserialize(self, rawresult) -&gt; dict:\n    \"\"\"deserialize the given rawresult according to\n    https://www.semantic-mediawiki.org/wiki/Serialization_(JSON)\n\n    Args:\n        rawresult(dict): contains printrequests and results which need to be merged\n\n    Returns:\n        dict: query mainlabel (usually pageTitle) mapped to the corresponding dict of printrequests with label\n    \"\"\"\n    resultDict = {}\n    if rawresult is None:\n        return resultDict\n    if not \"query\" in rawresult:\n        raise Exception(\"invalid query result - 'query' missing\")\n    query = rawresult[\"query\"]\n    if not \"printrequests\" in query:\n        raise Exception(\"invalid query result - 'printrequests' missing\")\n    printrequests = query[\"printrequests\"]\n    if not \"results\" in query:\n        raise Exception(\"invalid query result - 'results' missing\")\n    results = query[\"results\"]\n    prdict = {}\n    for record in printrequests:\n        pr = PrintRequest(self, record)\n        prdict[pr.label] = pr\n\n    if results:\n        for key in results.keys():\n            record = results[key]\n            recordDict = {}\n            for label in prdict.keys():\n                pr = prdict[label]\n                recordDict[label] = pr.deserialize(record)\n            resultDict[key] = recordDict\n    return resultDict\n</code></pre>"},{"location":"#wikibot3rd.smw.SMW.fixAsk","title":"<code>fixAsk(ask)</code>","text":"<p>fix an ask String to be usable for the API\nArgs:\n    ask: - a \"normal\" ask query</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n            \n            \n              \n                <p>the fixed asked query</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def fixAsk(self, ask: str):\n    \"\"\"\n    fix an ask String to be usable for the API\n    Args:\n        ask: - a \"normal\" ask query\n\n    Returns:\n         the fixed asked query\n    \"\"\"\n    # ^\\\\s*\\\\{\\\\{\n    # remove {{ with surrounding white space at beginning\n    fixedAsk = re.sub(r\"^\\s*\\{\\{\", \"\", ask)\n    # remove #ask:\n    fixedAsk = re.sub(r\"#ask:\", \"\", fixedAsk)\n    # remove }} with surrounding white space at end\n    fixedAsk = re.sub(r\"\\}\\}\\s*$\", \"\", fixedAsk)\n    # split by lines (with side effect to remove newlines)\n    parts = fixedAsk.split(r\"\\n\")\n    fixedAsk = \"\"\n    for part in parts:\n        #  remove whitespace around part\n        part = part.strip()\n        # remove whitespace around pipe sign\n        part = re.sub(r\"\\s*\\|\\s*\", \"|\", part)\n        # remove whitespace around assignment =\n        part = re.sub(r\"\\s*=\\s*\", \"=\", part)\n        # remove whitespace in query parts\n        part = re.sub(r\"\\]\\s*\\[\", \"][\", part)\n        fixedAsk = fixedAsk + part\n    return fixedAsk\n</code></pre>"},{"location":"#wikibot3rd.smw.SMW.getConcept","title":"<code>getConcept(ask)</code>","text":"<p>get the concept from the given ask query</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def getConcept(self, ask):\n    \"\"\"get the concept from the given ask query\"\"\"\n    m = re.search(r\"\\[\\[Concept:(.+?)\\]\\]\", ask)\n    if m:\n        return m.groups()[0]\n    else:\n        return None\n</code></pre>"},{"location":"#wikibot3rd.smw.SMW.getOuterMostArgumentValueOfQuery","title":"<code>getOuterMostArgumentValueOfQuery(argument, query)</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Extracts the integer value of the given argument from the given query\nArgs:\n    argument(string): Argument that should be extracted\n    query(string): smw query where the given argument is assumed</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n            \n            \n              \n                <p>Returns integer value of the given argument in the given query.</p>\n              \n            \n          \n          \n            \n            \n            \n              \n                <p>If the argument occurs multiple times the last one is returned.</p>\n              \n            \n          \n          \n            \n            \n            \n              \n                <p>If it does not occur return None.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>@staticmethod\ndef getOuterMostArgumentValueOfQuery(argument, query):\n    \"\"\"\n    Extracts the integer value of the given argument from the given query\n    Args:\n        argument(string): Argument that should be extracted\n        query(string): smw query where the given argument is assumed\n\n    Returns:\n        Returns integer value of the given argument in the given query.\n        If the argument occurs multiple times the last one is returned.\n        If it does not occur return None.\n    \"\"\"\n    if not argument or not query:\n        return None\n    args = re.compile(SMW.argumentRegex(argument), re.IGNORECASE).findall(query)\n    if not args:\n        return None\n    return int(re.compile(\"[0-9]+\").search(args[-1]).group())\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWBot","title":"<code>SMWBot</code>","text":"<p>\n              Bases: <code>SMW</code></p>\n\n\n      <p>Semantic MediaWiki access using pywikibot library</p>\n\n              \n                Source code in <code>wikibot3rd/smw.py</code>\n                <pre><code>class SMWBot(SMW):\n    \"\"\"\n    Semantic MediaWiki access using pywikibot library\n    \"\"\"\n\n    def __init__(self, site=None, prefix=\"/\", showProgress=False, debug=False):\n        \"\"\"\n        constructor\n\n        Args:\n            site:\n            prefix(str): the prefix to use\n            showProgress(bool): show progress if true\n            debug(bool): set debugging mode if true\n        \"\"\"\n        super(SMWBot, self).__init__(\n            site, prefix, showProgress=showProgress, debug=debug\n        )\n        pass\n\n    def submit(self, parameters):\n        \"\"\"submit the request with the given parameters\n        Args:\n            parameters(list): the parameters to use for the SMW API request\n        Returns:\n            dict: the submit result\n        \"\"\"\n        if not \"Request\" in sys.modules:\n            from pywikibot.data.api import Request\n\n        request = Request(site=self.site, parameters=parameters)\n        result = None\n        try:\n            result = request.submit()\n        except pywikibot.exceptions.TimeoutError as _toe:\n            msg = f\"submit for {self.site} failed due to pywikibot TimeoutError\"\n            raise Exception(msg)\n            pass\n        return result\n\n    def info(self):\n        \"\"\"see https://www.semantic-mediawiki.org/wiki/Help:API:smwinfo\"\"\"\n        parameters = {\"action\": \"smwinfo\"}\n        return self.submit(parameters)\n\n    def rawquery(self, ask: str, limit=None):\n        \"\"\"\n         send a query see https://www.semantic-mediawiki.org/wiki/Help:Inline_queries#Parser_function_.23ask\n\n        Args:\n            ask(str): the SMW ASK query as it would be used in MediaWiki markup\n        \"\"\"\n        # allow usage of original Wiki ask content - strip all non needed parts\n        fixedAsk = self.fixAsk(ask)\n        # set parameters for request\n        parameters = {\"action\": \"ask\", \"query\": fixedAsk}\n        result = self.submit(parameters)\n        return result\n\n    def query(self, ask, limit=None):\n        \"\"\"\n        send a query and deserialize it\n        \"\"\"\n        rawresult = self.rawquery(ask, limit=limit)\n        result = self.deserialize(rawresult)\n        return result\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWBot.__init__","title":"<code>__init__(site=None, prefix='/', showProgress=False, debug=False)</code>","text":"<p>constructor</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>site</code>\n            \n            \n            \n              \n                \n              \n            \n            \n                  <code>None</code>\n            \n          \n          \n            <code>prefix(str)</code>\n            \n            \n            \n              \n                <p>the prefix to use</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>showProgress(bool)</code>\n            \n            \n            \n              \n                <p>show progress if true</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>debug(bool)</code>\n            \n            \n            \n              \n                <p>set debugging mode if true</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def __init__(self, site=None, prefix=\"/\", showProgress=False, debug=False):\n    \"\"\"\n    constructor\n\n    Args:\n        site:\n        prefix(str): the prefix to use\n        showProgress(bool): show progress if true\n        debug(bool): set debugging mode if true\n    \"\"\"\n    super(SMWBot, self).__init__(\n        site, prefix, showProgress=showProgress, debug=debug\n    )\n    pass\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWBot.info","title":"<code>info()</code>","text":"<p>see https://www.semantic-mediawiki.org/wiki/Help:API:smwinfo</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def info(self):\n    \"\"\"see https://www.semantic-mediawiki.org/wiki/Help:API:smwinfo\"\"\"\n    parameters = {\"action\": \"smwinfo\"}\n    return self.submit(parameters)\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWBot.query","title":"<code>query(ask, limit=None)</code>","text":"<p>send a query and deserialize it</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def query(self, ask, limit=None):\n    \"\"\"\n    send a query and deserialize it\n    \"\"\"\n    rawresult = self.rawquery(ask, limit=limit)\n    result = self.deserialize(rawresult)\n    return result\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWBot.rawquery","title":"<code>rawquery(ask, limit=None)</code>","text":"<p>send a query see https://www.semantic-mediawiki.org/wiki/Help:Inline_queries#Parser_function_.23ask</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>ask(str)</code>\n            \n            \n            \n              \n                <p>the SMW ASK query as it would be used in MediaWiki markup</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def rawquery(self, ask: str, limit=None):\n    \"\"\"\n     send a query see https://www.semantic-mediawiki.org/wiki/Help:Inline_queries#Parser_function_.23ask\n\n    Args:\n        ask(str): the SMW ASK query as it would be used in MediaWiki markup\n    \"\"\"\n    # allow usage of original Wiki ask content - strip all non needed parts\n    fixedAsk = self.fixAsk(ask)\n    # set parameters for request\n    parameters = {\"action\": \"ask\", \"query\": fixedAsk}\n    result = self.submit(parameters)\n    return result\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWBot.submit","title":"<code>submit(parameters)</code>","text":"<p>submit the request with the given parameters\nArgs:\n    parameters(list): the parameters to use for the SMW API request\nReturns:\n    dict: the submit result</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def submit(self, parameters):\n    \"\"\"submit the request with the given parameters\n    Args:\n        parameters(list): the parameters to use for the SMW API request\n    Returns:\n        dict: the submit result\n    \"\"\"\n    if not \"Request\" in sys.modules:\n        from pywikibot.data.api import Request\n\n    request = Request(site=self.site, parameters=parameters)\n    result = None\n    try:\n        result = request.submit()\n    except pywikibot.exceptions.TimeoutError as _toe:\n        msg = f\"submit for {self.site} failed due to pywikibot TimeoutError\"\n        raise Exception(msg)\n        pass\n    return result\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient","title":"<code>SMWClient</code>","text":"<p>\n              Bases: <code>SMW</code></p>\n\n\n      <p>Semantic MediaWiki access using mw client library</p>\n\n              \n                Source code in <code>wikibot3rd/smw.py</code>\n                <pre><code>class SMWClient(SMW):\n    \"\"\"\n    Semantic MediaWiki access using mw client library\n    \"\"\"\n\n    def __init__(\n        self, site=None, prefix=\"/\", showProgress=False, queryDivision=1, debug=False\n    ):\n        super(SMWClient, self).__init__(\n            site,\n            prefix,\n            showProgress=showProgress,\n            queryDivision=queryDivision,\n            debug=debug,\n        )\n        pass\n\n    def info(self):\n        \"\"\"see https://www.semantic-mediawiki.org/wiki/Help:API:smwinfo\"\"\"\n        results = self.site.raw_api(\"smwinfo\", http_method=\"GET\")\n        self.site.handle_api_result(results)  # raises APIError on error\n\n        return results\n\n    def ask(self, query: str, title: str = None, limit: int = None):\n        \"\"\"\n        Ask a query against Semantic MediaWiki.\n\n        API doc: https://semantic-mediawiki.org/wiki/Ask_API\n\n        The query is devided into multiple subqueries if the results of the query exeed the defined threshold.\n        If this happens the query is executed multiple times to retrieve all results without passing the threshold.\n\n\n        Args:\n            query(str): SMW ask query to be executed\n            title(str): title of query (optional)\n            limit(int): the maximum number of results to be returned -\n                please note that SMW configuration will also limit results on the server side\n\n        Returns:\n            Generator for retrieving all search results, with each answer as a dictionary.\n            If the query is invalid, an APIError is raised. A valid query with zero\n            results will not raise any error.\n\n        Examples:\n\n            &gt;&gt;&gt; query = \"[[Category:my cat]]|[[Has name::a name]]|?Has property\"\n            &gt;&gt;&gt; for answer in site.ask(query):\n            &gt;&gt;&gt;     for title, data in answer.items()\n            &gt;&gt;&gt;         print(title)\n            &gt;&gt;&gt;         print(data)\n        \"\"\"\n        # kwargs = {}\n        # if title is None:\n        #    kwargs['title'] = title\n\n        if limit is None:\n            # if limit is not defined (via cmd-line), check if defined in query\n            limit = SMW.getOuterMostArgumentValueOfQuery(\"limit\", query)\n        results = None\n        if self.queryDivision == 1:\n            try:\n                results = self.askForAllResults(query, limit)\n            except QueryResultSizeExceedException as e:\n                print(e)\n                results = e.getResults()\n        else:\n            results = self.askPartitionQuery(query, limit)\n        for res in results:\n            yield res\n\n    def askPartitionQuery(self, query, limit=None):\n        \"\"\"\n        Splits the query into multiple subqueries by determining the 'modification date' interval in which all results\n        lie. This interval is then divided into subintervals. The number of subintervals is defined by the user via\n        commandline. The results of all subqueries are then returned.\n        Args:\n            query(string): the SMW inline query to be send via api\n            limit(string): limit of the query\n        Returns:\n            All results of the given query.\n        \"\"\"\n        (start, end) = self.getBoundariesOfQuery(query)\n        results = []\n        if start is None or end is None:\n            return results\n        if self.showProgress:\n            print(f\"Start: {start}, End: {end}\", file=sys.stderr, flush=True)\n        numIntervals = self.queryDivision\n        calcIntervalBound = lambda start, n: (start + n * lenSubinterval).replace(\n            microsecond=0\n        )\n        calcLimit = lambda limit, numRes: None if limit is None else limit - numResults\n        done = False\n        numResults = 0\n        while not done:\n            lenSubinterval = (end - start) / numIntervals\n            for n in range(numIntervals):\n                if self.showProgress:\n                    print(f\"Query {n+1}/{numIntervals}:\")\n                tempLowerBound = calcIntervalBound(start, n)\n                tempUpperBound = (\n                    calcIntervalBound(start, n + 1) if (n + 1 &lt; numIntervals) else end\n                )\n                queryBounds = self.splitClause.queryBounds(\n                    tempLowerBound, tempUpperBound\n                )\n                queryParam = f\"{query}|{queryBounds}\"\n                try:\n                    tempRes = self.askForAllResults(\n                        queryParam, calcLimit(limit, numResults)\n                    )\n                    if tempRes is not None:\n                        for res in tempRes:\n                            results.append(res)\n                            query_field = res.get(\"query\")\n                            if query_field is not None:\n                                meta_field = query_field.get(\"meta\")\n                                if meta_field is not None:\n                                    numResults += int(meta_field.get(\"count\"))\n                except QueryResultSizeExceedException as e:\n                    # Too many results for current subinterval n -&gt; print error and return the results upto this point\n                    print(e)\n                    if e.getResults():\n                        for res in e.getResults():\n                            results.append(res)\n                    numResults = 0\n                    break\n                if limit is not None and limit &lt;= numResults:\n                    if self.showProgress:\n                        print(f\"Defined limit of {limit} reached - ending querying\")\n                    done = True\n                    break\n            done = True\n        return results\n\n    def getTimeStampBoundary(self, queryparam, order):\n        \"\"\"\n        query according to a DATE e.g. MODIFICATION_DATE in the given order\n\n        Args:\n\n        \"\"\"\n        queryparamBoundary = f\"{queryparam}|order={order}\"\n        resultsBoundary = self.site.raw_api(\n            \"ask\", query=queryparamBoundary, http_method=\"GET\"\n        )\n        self.site.handle_api_result(resultsBoundary)\n        deserializedResult = self.deserialize(resultsBoundary)\n\n        deserializedValues = deserializedResult.values()\n        date = self.splitClause.deserialize(deserializedValues)\n        return date\n\n    def getBoundariesOfQuery(self, query):\n        \"\"\"\n        Retrieves the time interval, lower and upper bound, based on the modification date in which the results of the\n        given query lie.\n        Args:\n            query(string): the SMW inline query to be send via api\n        Returns:\n            (Datetime, Datetime): Returns the time interval (based on modification date) in which all results of the\n            query lie potentially the start end end might be None if an error occured or the input is invalid\n        \"\"\"\n        first = self.splitClause.getFirst()\n        queryparam = f\"{query}|{first}\"\n        start = self.getTimeStampBoundary(queryparam, \"asc\")\n        end = self.getTimeStampBoundary(queryparam, \"desc\")\n        return (start, end)\n\n    def askForAllResults(self, query, limit=None, kwargs={}):\n        \"\"\"\n        Executes the query until all results are received of the given limit is reached.\n        If the SMW results limit is reached before all results are retrieved the QueryResultSizeExceedException is raised.\n        Args:\n            query(string): the SMW inline query to be send via api\n            limit(int): limit for the query results, None (default) for all results\n            kwargs:\n        Returns:\n            query results\n        Raises:\n            QueryResultSizeExceedException: Raised if not all results can be retrieved\n        \"\"\"\n        endShowProgress = lambda showProgress, c: (\n            print(\"\\n\" if not c % 80 == 0 else \"\") if showProgress else None\n        )\n        offset = 0\n        done = False\n        count = 0\n        res = []\n        while not done:\n            count += 1\n            if self.showProgress:\n                sep = \"\\n\" if count % 80 == 0 else \"\"\n                print(\".\", end=sep, flush=True)\n\n            queryParam = \"{query}|offset={offset}\".format(query=query, offset=offset)\n            if limit is not None:\n                queryParam += \"|limit={limit}\".format(limit=limit)\n            # print(f\"QueryPram: {queryParam}\")   #debug purposes\n            results = self.site.raw_api(\n                \"ask\", query=queryParam, http_method=\"GET\", **kwargs\n            )\n            self.site.handle_api_result(results)  # raises APIError on error\n            continueOffset = results.get(\"query-continue-offset\")\n            if continueOffset is None:\n                done = True\n            else:\n                if limit is not None and continueOffset &gt;= limit:\n                    done = True\n                elif (\n                    results.get(\"query\") is not None\n                    and not results.get(\"query\").get(\"results\")\n                ) or continueOffset &lt; offset:\n                    # contine-offset is set but result is empty\n                    endShowProgress(self.showProgress, count)\n                    res.append(results)\n                    raise QueryResultSizeExceedException(result=res)\n                if continueOffset &lt; offset:\n                    done = True\n            offset = continueOffset\n            res.append(results)\n        endShowProgress(self.showProgress, count)\n        return res\n\n    def rawquery(self, askQuery, title=None, limit=None):\n        \"\"\"\n        run the given askQuery and return the raw result\n\n        Args:\n            askQuery(string): the SMW inline query to be send via api\n            title(string): the title (if any)\n            limit(int): the maximum number of records to be retrieved (if any)\n\n        Returns:\n            dict: the raw query result as returned by the ask API\n        \"\"\"\n        fixedAsk = self.fixAsk(askQuery)\n        result = None\n        for singleResult in self.ask(fixedAsk, title, limit):\n            if result is None:\n                result = singleResult\n            else:\n                singleResults = None\n                if \"query\" in singleResult:\n                    if \"results\" in singleResult[\"query\"]:\n                        singleResults = singleResult[\"query\"][\"results\"]\n                if singleResults is not None:\n                    if \"query\" in result:\n                        if \"results\" in result[\"query\"]:\n                            results = result[\"query\"][\"results\"]\n                            results.update(singleResults)\n                        else:\n                            result[\"query\"][\"results\"] = singleResults\n                    else:\n                        result[\"query\"] = {}\n                        result[\"query\"][\"results\"] = singleResults\n        return result\n\n    def query(self, askQuery: str, title: str = None, limit: int = None) -&gt; dict:\n        \"\"\"\n        run query and return list of Dicts\n\n        Args:\n            askQuery(string): the SMW inline query to be send via api\n            title(string): the title (if any)\n            limit(int): the maximum number of records to be retrieved (if any)\n\n        Return:\n            dict: mainlabel as key and value is a dict of the associated property values\n        \"\"\"\n        rawresult = self.rawquery(askQuery, title, limit)\n        resultDict = self.deserialize(rawresult)\n        return resultDict\n\n    def updateProgress(self, count):\n        if self.showProgress:\n            sep = \"\\n\" if count % 80 == 0 else \"\"\n            print(\".\", end=sep, flush=True)\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient.ask","title":"<code>ask(query, title=None, limit=None)</code>","text":"<p>Ask a query against Semantic MediaWiki.</p>\n<p>API doc: https://semantic-mediawiki.org/wiki/Ask_API</p>\n<p>The query is devided into multiple subqueries if the results of the query exeed the defined threshold.\nIf this happens the query is executed multiple times to retrieve all results without passing the threshold.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>query(str)</code>\n            \n            \n            \n              \n                <p>SMW ask query to be executed</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>title(str)</code>\n            \n            \n            \n              \n                <p>title of query (optional)</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>limit(int)</code>\n            \n            \n            \n              \n                <p>the maximum number of results to be returned -\nplease note that SMW configuration will also limit results on the server side</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n            \n            \n              \n                <p>Generator for retrieving all search results, with each answer as a dictionary.</p>\n              \n            \n          \n          \n            \n            \n            \n              \n                <p>If the query is invalid, an APIError is raised. A valid query with zero</p>\n              \n            \n          \n          \n            \n            \n            \n              \n                <p>results will not raise any error.</p>\n              \n            \n          \n      \n    \n      <p>Examples:</p>\n<pre><code>&gt;&gt;&gt; query = \"[[Category:my cat]]|[[Has name::a name]]|?Has property\"\n&gt;&gt;&gt; for answer in site.ask(query):\n&gt;&gt;&gt;     for title, data in answer.items()\n&gt;&gt;&gt;         print(title)\n&gt;&gt;&gt;         print(data)\n</code></pre>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def ask(self, query: str, title: str = None, limit: int = None):\n    \"\"\"\n    Ask a query against Semantic MediaWiki.\n\n    API doc: https://semantic-mediawiki.org/wiki/Ask_API\n\n    The query is devided into multiple subqueries if the results of the query exeed the defined threshold.\n    If this happens the query is executed multiple times to retrieve all results without passing the threshold.\n\n\n    Args:\n        query(str): SMW ask query to be executed\n        title(str): title of query (optional)\n        limit(int): the maximum number of results to be returned -\n            please note that SMW configuration will also limit results on the server side\n\n    Returns:\n        Generator for retrieving all search results, with each answer as a dictionary.\n        If the query is invalid, an APIError is raised. A valid query with zero\n        results will not raise any error.\n\n    Examples:\n\n        &gt;&gt;&gt; query = \"[[Category:my cat]]|[[Has name::a name]]|?Has property\"\n        &gt;&gt;&gt; for answer in site.ask(query):\n        &gt;&gt;&gt;     for title, data in answer.items()\n        &gt;&gt;&gt;         print(title)\n        &gt;&gt;&gt;         print(data)\n    \"\"\"\n    # kwargs = {}\n    # if title is None:\n    #    kwargs['title'] = title\n\n    if limit is None:\n        # if limit is not defined (via cmd-line), check if defined in query\n        limit = SMW.getOuterMostArgumentValueOfQuery(\"limit\", query)\n    results = None\n    if self.queryDivision == 1:\n        try:\n            results = self.askForAllResults(query, limit)\n        except QueryResultSizeExceedException as e:\n            print(e)\n            results = e.getResults()\n    else:\n        results = self.askPartitionQuery(query, limit)\n    for res in results:\n        yield res\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient.askForAllResults","title":"<code>askForAllResults(query, limit=None, kwargs={})</code>","text":"<p>Executes the query until all results are received of the given limit is reached.\nIf the SMW results limit is reached before all results are retrieved the QueryResultSizeExceedException is raised.\nArgs:\n    query(string): the SMW inline query to be send via api\n    limit(int): limit for the query results, None (default) for all results\n    kwargs:\nReturns:\n    query results\nRaises:\n    QueryResultSizeExceedException: Raised if not all results can be retrieved</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def askForAllResults(self, query, limit=None, kwargs={}):\n    \"\"\"\n    Executes the query until all results are received of the given limit is reached.\n    If the SMW results limit is reached before all results are retrieved the QueryResultSizeExceedException is raised.\n    Args:\n        query(string): the SMW inline query to be send via api\n        limit(int): limit for the query results, None (default) for all results\n        kwargs:\n    Returns:\n        query results\n    Raises:\n        QueryResultSizeExceedException: Raised if not all results can be retrieved\n    \"\"\"\n    endShowProgress = lambda showProgress, c: (\n        print(\"\\n\" if not c % 80 == 0 else \"\") if showProgress else None\n    )\n    offset = 0\n    done = False\n    count = 0\n    res = []\n    while not done:\n        count += 1\n        if self.showProgress:\n            sep = \"\\n\" if count % 80 == 0 else \"\"\n            print(\".\", end=sep, flush=True)\n\n        queryParam = \"{query}|offset={offset}\".format(query=query, offset=offset)\n        if limit is not None:\n            queryParam += \"|limit={limit}\".format(limit=limit)\n        # print(f\"QueryPram: {queryParam}\")   #debug purposes\n        results = self.site.raw_api(\n            \"ask\", query=queryParam, http_method=\"GET\", **kwargs\n        )\n        self.site.handle_api_result(results)  # raises APIError on error\n        continueOffset = results.get(\"query-continue-offset\")\n        if continueOffset is None:\n            done = True\n        else:\n            if limit is not None and continueOffset &gt;= limit:\n                done = True\n            elif (\n                results.get(\"query\") is not None\n                and not results.get(\"query\").get(\"results\")\n            ) or continueOffset &lt; offset:\n                # contine-offset is set but result is empty\n                endShowProgress(self.showProgress, count)\n                res.append(results)\n                raise QueryResultSizeExceedException(result=res)\n            if continueOffset &lt; offset:\n                done = True\n        offset = continueOffset\n        res.append(results)\n    endShowProgress(self.showProgress, count)\n    return res\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient.askPartitionQuery","title":"<code>askPartitionQuery(query, limit=None)</code>","text":"<p>Splits the query into multiple subqueries by determining the 'modification date' interval in which all results\nlie. This interval is then divided into subintervals. The number of subintervals is defined by the user via\ncommandline. The results of all subqueries are then returned.\nArgs:\n    query(string): the SMW inline query to be send via api\n    limit(string): limit of the query\nReturns:\n    All results of the given query.</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def askPartitionQuery(self, query, limit=None):\n    \"\"\"\n    Splits the query into multiple subqueries by determining the 'modification date' interval in which all results\n    lie. This interval is then divided into subintervals. The number of subintervals is defined by the user via\n    commandline. The results of all subqueries are then returned.\n    Args:\n        query(string): the SMW inline query to be send via api\n        limit(string): limit of the query\n    Returns:\n        All results of the given query.\n    \"\"\"\n    (start, end) = self.getBoundariesOfQuery(query)\n    results = []\n    if start is None or end is None:\n        return results\n    if self.showProgress:\n        print(f\"Start: {start}, End: {end}\", file=sys.stderr, flush=True)\n    numIntervals = self.queryDivision\n    calcIntervalBound = lambda start, n: (start + n * lenSubinterval).replace(\n        microsecond=0\n    )\n    calcLimit = lambda limit, numRes: None if limit is None else limit - numResults\n    done = False\n    numResults = 0\n    while not done:\n        lenSubinterval = (end - start) / numIntervals\n        for n in range(numIntervals):\n            if self.showProgress:\n                print(f\"Query {n+1}/{numIntervals}:\")\n            tempLowerBound = calcIntervalBound(start, n)\n            tempUpperBound = (\n                calcIntervalBound(start, n + 1) if (n + 1 &lt; numIntervals) else end\n            )\n            queryBounds = self.splitClause.queryBounds(\n                tempLowerBound, tempUpperBound\n            )\n            queryParam = f\"{query}|{queryBounds}\"\n            try:\n                tempRes = self.askForAllResults(\n                    queryParam, calcLimit(limit, numResults)\n                )\n                if tempRes is not None:\n                    for res in tempRes:\n                        results.append(res)\n                        query_field = res.get(\"query\")\n                        if query_field is not None:\n                            meta_field = query_field.get(\"meta\")\n                            if meta_field is not None:\n                                numResults += int(meta_field.get(\"count\"))\n            except QueryResultSizeExceedException as e:\n                # Too many results for current subinterval n -&gt; print error and return the results upto this point\n                print(e)\n                if e.getResults():\n                    for res in e.getResults():\n                        results.append(res)\n                numResults = 0\n                break\n            if limit is not None and limit &lt;= numResults:\n                if self.showProgress:\n                    print(f\"Defined limit of {limit} reached - ending querying\")\n                done = True\n                break\n        done = True\n    return results\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient.getBoundariesOfQuery","title":"<code>getBoundariesOfQuery(query)</code>","text":"<p>Retrieves the time interval, lower and upper bound, based on the modification date in which the results of the\ngiven query lie.\nArgs:\n    query(string): the SMW inline query to be send via api\nReturns:\n    (Datetime, Datetime): Returns the time interval (based on modification date) in which all results of the\n    query lie potentially the start end end might be None if an error occured or the input is invalid</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def getBoundariesOfQuery(self, query):\n    \"\"\"\n    Retrieves the time interval, lower and upper bound, based on the modification date in which the results of the\n    given query lie.\n    Args:\n        query(string): the SMW inline query to be send via api\n    Returns:\n        (Datetime, Datetime): Returns the time interval (based on modification date) in which all results of the\n        query lie potentially the start end end might be None if an error occured or the input is invalid\n    \"\"\"\n    first = self.splitClause.getFirst()\n    queryparam = f\"{query}|{first}\"\n    start = self.getTimeStampBoundary(queryparam, \"asc\")\n    end = self.getTimeStampBoundary(queryparam, \"desc\")\n    return (start, end)\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient.getTimeStampBoundary","title":"<code>getTimeStampBoundary(queryparam, order)</code>","text":"<p>query according to a DATE e.g. MODIFICATION_DATE in the given order</p>\n<p>Args:</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def getTimeStampBoundary(self, queryparam, order):\n    \"\"\"\n    query according to a DATE e.g. MODIFICATION_DATE in the given order\n\n    Args:\n\n    \"\"\"\n    queryparamBoundary = f\"{queryparam}|order={order}\"\n    resultsBoundary = self.site.raw_api(\n        \"ask\", query=queryparamBoundary, http_method=\"GET\"\n    )\n    self.site.handle_api_result(resultsBoundary)\n    deserializedResult = self.deserialize(resultsBoundary)\n\n    deserializedValues = deserializedResult.values()\n    date = self.splitClause.deserialize(deserializedValues)\n    return date\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient.info","title":"<code>info()</code>","text":"<p>see https://www.semantic-mediawiki.org/wiki/Help:API:smwinfo</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def info(self):\n    \"\"\"see https://www.semantic-mediawiki.org/wiki/Help:API:smwinfo\"\"\"\n    results = self.site.raw_api(\"smwinfo\", http_method=\"GET\")\n    self.site.handle_api_result(results)  # raises APIError on error\n\n    return results\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient.query","title":"<code>query(askQuery, title=None, limit=None)</code>","text":"<p>run query and return list of Dicts</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>askQuery(string)</code>\n            \n            \n            \n              \n                <p>the SMW inline query to be send via api</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>title(string)</code>\n            \n            \n            \n              \n                <p>the title (if any)</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>limit(int)</code>\n            \n            \n            \n              \n                <p>the maximum number of records to be retrieved (if any)</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n\n  Return\n  <p>dict: mainlabel as key and value is a dict of the associated property values</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def query(self, askQuery: str, title: str = None, limit: int = None) -&gt; dict:\n    \"\"\"\n    run query and return list of Dicts\n\n    Args:\n        askQuery(string): the SMW inline query to be send via api\n        title(string): the title (if any)\n        limit(int): the maximum number of records to be retrieved (if any)\n\n    Return:\n        dict: mainlabel as key and value is a dict of the associated property values\n    \"\"\"\n    rawresult = self.rawquery(askQuery, title, limit)\n    resultDict = self.deserialize(rawresult)\n    return resultDict\n</code></pre>"},{"location":"#wikibot3rd.smw.SMWClient.rawquery","title":"<code>rawquery(askQuery, title=None, limit=None)</code>","text":"<p>run the given askQuery and return the raw result</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>askQuery(string)</code>\n            \n            \n            \n              \n                <p>the SMW inline query to be send via api</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>title(string)</code>\n            \n            \n            \n              \n                <p>the title (if any)</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>limit(int)</code>\n            \n            \n            \n              \n                <p>the maximum number of records to be retrieved (if any)</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>dict</code>            \n            \n            \n              \n                <p>the raw query result as returned by the ask API</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def rawquery(self, askQuery, title=None, limit=None):\n    \"\"\"\n    run the given askQuery and return the raw result\n\n    Args:\n        askQuery(string): the SMW inline query to be send via api\n        title(string): the title (if any)\n        limit(int): the maximum number of records to be retrieved (if any)\n\n    Returns:\n        dict: the raw query result as returned by the ask API\n    \"\"\"\n    fixedAsk = self.fixAsk(askQuery)\n    result = None\n    for singleResult in self.ask(fixedAsk, title, limit):\n        if result is None:\n            result = singleResult\n        else:\n            singleResults = None\n            if \"query\" in singleResult:\n                if \"results\" in singleResult[\"query\"]:\n                    singleResults = singleResult[\"query\"][\"results\"]\n            if singleResults is not None:\n                if \"query\" in result:\n                    if \"results\" in result[\"query\"]:\n                        results = result[\"query\"][\"results\"]\n                        results.update(singleResults)\n                    else:\n                        result[\"query\"][\"results\"] = singleResults\n                else:\n                    result[\"query\"] = {}\n                    result[\"query\"][\"results\"] = singleResults\n    return result\n</code></pre>"},{"location":"#wikibot3rd.smw.SplitClause","title":"<code>SplitClause</code>","text":"<p>Query parameter to be used for splitting e.g. Modification date, Creation Date, could be potentially\nany parameter that is ordered and countable\nCurrently we assume a parameter of type Date and use Modification date by default</p>\n\n              \n                Source code in <code>wikibot3rd/smw.py</code>\n                <pre><code>class SplitClause:\n    \"\"\"\n    Query parameter to be used for splitting e.g. Modification date, Creation Date, could be potentially\n    any parameter that is ordered and countable\n    Currently we assume a parameter of type Date and use Modification date by default\n    \"\"\"\n\n    def __init__(self, name=\"Modification date\", label=\"mdate\"):\n        \"\"\"\n        construct me\n        \"\"\"\n        self.name = name\n        self.label = label\n\n    def queryBounds(self, lowerBound, upperBound) -&gt; str:\n        \"\"\"\n        get the query bounds\n        e.g. [[Modification date::&gt;=2021-01-01T12:00\n\n        Args:\n            lowerBound(datetime): start of the time interval\n            upperBound(datetime): end of the time interval\n\n        Returns:\n            Returns the SMW ask part for the boundary\n        \"\"\"\n        result = f\"[[{self.name}:: &gt;={lowerBound.isoformat()}]]|[[{self.name}:: &lt;={upperBound.isoformat()}]]\"\n        return result\n\n    def getFirst(self) -&gt; str:\n        \"\"\"\n        get the first element\n        \"\"\"\n        result = f\"?{self.name}={self.label}|sort={self.name}|limit=1\"\n        return result\n\n    def deserialize(self, values):\n        \"\"\"\n        deserialize my query result\n        \"\"\"\n        # dict: {\n        #    'Property:Foaf:knows': {\n        #       '': 'Property:Foaf:knows',\n        #       'Modification date': datetime.datetime(2020, 11, 28, 17, 40, 36)\n        #    }\n        # }\n        date = None\n        vlist = list(values)\n        if len(vlist) &gt; 0:\n            innerValue = vlist[0]\n            if self.label in innerValue:\n                date = innerValue[self.label]\n        return date\n</code></pre>"},{"location":"#wikibot3rd.smw.SplitClause.__init__","title":"<code>__init__(name='Modification date', label='mdate')</code>","text":"<p>construct me</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def __init__(self, name=\"Modification date\", label=\"mdate\"):\n    \"\"\"\n    construct me\n    \"\"\"\n    self.name = name\n    self.label = label\n</code></pre>"},{"location":"#wikibot3rd.smw.SplitClause.deserialize","title":"<code>deserialize(values)</code>","text":"<p>deserialize my query result</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def deserialize(self, values):\n    \"\"\"\n    deserialize my query result\n    \"\"\"\n    # dict: {\n    #    'Property:Foaf:knows': {\n    #       '': 'Property:Foaf:knows',\n    #       'Modification date': datetime.datetime(2020, 11, 28, 17, 40, 36)\n    #    }\n    # }\n    date = None\n    vlist = list(values)\n    if len(vlist) &gt; 0:\n        innerValue = vlist[0]\n        if self.label in innerValue:\n            date = innerValue[self.label]\n    return date\n</code></pre>"},{"location":"#wikibot3rd.smw.SplitClause.getFirst","title":"<code>getFirst()</code>","text":"<p>get the first element</p>\n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def getFirst(self) -&gt; str:\n    \"\"\"\n    get the first element\n    \"\"\"\n    result = f\"?{self.name}={self.label}|sort={self.name}|limit=1\"\n    return result\n</code></pre>"},{"location":"#wikibot3rd.smw.SplitClause.queryBounds","title":"<code>queryBounds(lowerBound, upperBound)</code>","text":"<p>get the query bounds\ne.g. [[Modification date::&gt;=2021-01-01T12:00</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>lowerBound(datetime)</code>\n            \n            \n            \n              \n                <p>start of the time interval</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>upperBound(datetime)</code>\n            \n            \n            \n              \n                <p>end of the time interval</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>str</code>\n            \n            \n              \n                <p>Returns the SMW ask part for the boundary</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/smw.py</code>\n              <pre><code>def queryBounds(self, lowerBound, upperBound) -&gt; str:\n    \"\"\"\n    get the query bounds\n    e.g. [[Modification date::&gt;=2021-01-01T12:00\n\n    Args:\n        lowerBound(datetime): start of the time interval\n        upperBound(datetime): end of the time interval\n\n    Returns:\n        Returns the SMW ask part for the boundary\n    \"\"\"\n    result = f\"[[{self.name}:: &gt;={lowerBound.isoformat()}]]|[[{self.name}:: &lt;={upperBound.isoformat()}]]\"\n    return result\n</code></pre>"},{"location":"#wikibot3rd.sso","title":"<code>sso</code>","text":"<p>Created on 2024-01-22</p>\n<p>@author: wf</p>\n<p>with ChatGPT-4 prompting</p>"},{"location":"#wikibot3rd.sso.SSO","title":"<code>SSO</code>","text":"<p>A class to implement MediaWiki single sign-on support.</p>\n<p>This class provides functionality to connect to a MediaWiki database,\nverify user credentials, and handle database connections with pooling.</p>\n\n\n<p>Attributes:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n        \n      \n      \n          \n            <code>host</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The host of the MediaWiki database.</p>\n              \n            \n          \n          \n            <code>database</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The name of the MediaWiki database.</p>\n              \n            \n          \n          \n            <code>sql_port</code>\n            \n                  <code>int</code>\n            \n            \n              \n                <p>The SQL port for the database connection.</p>\n              \n            \n          \n          \n            <code>db_username</code>\n            \n                  <code>Optional[str]</code>\n            \n            \n              \n                <p>The database username.</p>\n              \n            \n          \n          \n            <code>db_password</code>\n            \n                  <code>Optional[str]</code>\n            \n            \n              \n                <p>The database password.</p>\n              \n            \n          \n          \n            <code>with_pool</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>Flag to determine if connection pooling is used.</p>\n              \n            \n          \n          \n            <code>timeout</code>\n            \n                  <code>float</code>\n            \n            \n              \n                <p>The timeout for checking SQL port availability.</p>\n              \n            \n          \n          \n            <code>debug</code>\n            \n                  <code>Optional[bool]</code>\n            \n            \n              \n                <p>Flag to enable debug mode.</p>\n              \n            \n          \n      \n    \n\n              \n                Source code in <code>wikibot3rd/sso.py</code>\n                <pre><code>class SSO:\n    \"\"\"\n    A class to implement MediaWiki single sign-on support.\n\n    This class provides functionality to connect to a MediaWiki database,\n    verify user credentials, and handle database connections with pooling.\n\n    Attributes:\n        host (str): The host of the MediaWiki database.\n        database (str): The name of the MediaWiki database.\n        sql_port (int): The SQL port for the database connection.\n        db_username (Optional[str]): The database username.\n        db_password (Optional[str]): The database password.\n        with_pool (bool): Flag to determine if connection pooling is used.\n        timeout (float): The timeout for checking SQL port availability.\n        debug (Optional[bool]): Flag to enable debug mode.\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str,\n        database: str,\n        sql_port: int = 3306,\n        db_username: Optional[str] = None,\n        db_password: Optional[str] = None,\n        with_pool: bool = True,\n        timeout: float = 3,\n        debug: Optional[bool] = False,\n    ):\n        \"\"\"\n        Constructs all the necessary attributes for the SSO object.\n\n        Args:\n            host (str): The host of the MediaWiki database.\n            database (str): The name of the MediaWiki database.\n            sql_port (int): The SQL port for the database connection.\n            db_username (Optional[str]): The database username.\n            db_password (Optional[str]): The database password.\n            with_pool (bool): Flag to determine if connection pooling is used.\n            timeout (float): The timeout for checking SQL port availability.\n            debug (Optional[bool]): Flag to enable debug mode.\n        \"\"\"\n        self.host = host\n        self.database = database\n        self.sql_port = sql_port\n        self.timeout = timeout\n        self.db_username = db_username\n        self.db_password = db_password\n        self.debug = debug\n        self.pool = self.get_pool() if with_pool else None\n\n    def get_pool(self) -&gt; pooling.MySQLConnectionPool:\n        \"\"\"\n        Creates a connection pool for the database.\n\n        Returns:\n            MySQLConnectionPool: A pool of database connections.\n        \"\"\"\n        pool_config = {\n            \"pool_name\": \"mypool\",\n            \"pool_size\": 2,\n            \"host\": self.host,\n            \"user\": self.db_username,\n            \"password\": self.db_password,\n            \"database\": self.database,\n            \"raise_on_warnings\": True,\n        }\n        return pooling.MySQLConnectionPool(**pool_config)\n\n    def check_port(self) -&gt; bool:\n        \"\"\"\n        Checks if the specified SQL port is accessible on the configured host.\n\n        Returns:\n            bool: True if the port is accessible, False otherwise.\n        \"\"\"\n        try:\n            with socket.create_connection(\n                (self.host, self.sql_port), timeout=self.timeout\n            ):\n                return True\n        except socket.error as ex:\n            if self.debug:\n                print(f\"Connection to {self.host} port {self.sql_port} failed: {ex}\")\n                traceback.print_exc()\n            return False\n\n    def verify_password(self, password: str, hash_value: str) -&gt; bool:\n        \"\"\"\n        Verifies a password against a stored hash value.\n\n        Args:\n            password (str): The password to verify.\n            hash_value (str): The stored hash value to compare against.\n\n        Returns:\n            bool: True if the password matches the hash value, False otherwise.\n        \"\"\"\n        parts = hash_value.split(\":\")\n        if len(parts) != 7:\n            raise ValueError(\"Invalid hash format\")\n\n        (\n            _,\n            pbkdf2_indicator,\n            hash_algorithm,\n            iterations,\n            _,\n            salt,\n            hashed_password,\n        ) = parts\n\n        if pbkdf2_indicator != \"pbkdf2\":\n            raise ValueError(\"verify_password expects pbkdf2 hashes\")\n\n        iterations = int(iterations)\n\n        def fix_base64_padding(string: str) -&gt; str:\n            return string + \"=\" * (-len(string) % 4)\n\n        salt = fix_base64_padding(salt)\n        hashed_password = fix_base64_padding(hashed_password)\n\n        salt = base64.b64decode(salt)\n        hashed_password = base64.b64decode(hashed_password)\n\n        if hash_algorithm not in hashlib.algorithms_available:\n            raise ValueError(f\"Unsupported hash algorithm: {hash_algorithm}\")\n\n        new_hash = hashlib.pbkdf2_hmac(\n            hash_algorithm, password.encode(\"utf-8\"), salt, iterations\n        )\n        return new_hash == hashed_password\n\n    def get_user(self, username: str) -&gt; Optional[User]:\n        \"\"\"\n        Retrieve details of a user by username.\n        Returns a User object if found, otherwise None.\n        \"\"\"\n        mw_username = username[0].upper() + username[1:]\n        user_record = self.fetch_user_data_from_database(mw_username)\n        if user_record:\n            return User(\n                id=user_record[\"user_id\"],\n                name=user_record[\"user_name\"],\n                real_name=user_record[\"user_real_name\"],\n                password=user_record[\"user_password\"],\n                email=user_record[\"user_email\"],\n                touched=user_record[\"user_touched\"],\n                editcount=user_record[\"user_editcount\"],\n                is_admin=user_record[\"is_sysop\"] &gt; 0,\n            )\n        return None\n\n    def query(self, connection, sql_query, params) -&gt; Dict:\n        cursor = connection.cursor(dictionary=True)\n        cursor.execute(sql_query, params)\n        record = cursor.fetchone()\n        cursor.close()\n        return record\n\n    def fetch_user_data_from_database(self, mw_username: str) -&gt; Optional[dict]:\n        \"\"\"\n        Fetch user data from the database.\n\n        Args:\n            mw_username(str): the Mediawiki username\n        \"\"\"\n        user_record = None\n        try:\n            connection = (\n                self.pool.get_connection()\n                if self.pool\n                else mysql.connector.connect(\n                    host=self.host,\n                    user=self.db_username,\n                    password=self.db_password,\n                    database=self.database,\n                )\n            )\n            # JOIN query: Fetch user data and sysop status\n            sql_query = \"\"\"\n            SELECT u.*, \n                   COUNT(ug.ug_group) AS is_sysop\n            FROM `user` u\n            LEFT JOIN `user_groups` ug ON u.user_id = ug.ug_user AND ug.ug_group = 'sysop'\n            WHERE u.user_name = %s\n            GROUP BY u.user_id\n            \"\"\"\n            user_record = self.query(connection, sql_query, (mw_username,))\n        except Exception as ex:\n            if self.debug:\n                print(f\"Database error: {ex}\")\n                traceback.print_exc()\n        finally:\n            if connection and connection.is_connected():\n                connection.close()\n        return user_record\n\n    def check_credentials(self, username: str, password: str) -&gt; bool:\n        \"\"\"\n        Checks the validity of MediaWiki username and password.\n\n        Args:\n            username (str): The MediaWiki username.\n            password (str): The password to verify.\n\n        Returns:\n            bool: True if the credentials are valid, False otherwise.\n        \"\"\"\n        is_valid = False\n        user = self.get_user(username)\n        if user:\n            stored_hash = user.password\n            is_valid = self.verify_password(password, stored_hash)\n        elif self.debug:\n            print(f\"Username {username} not found in {self.database} on {self.host}\")\n        return is_valid\n</code></pre>"},{"location":"#wikibot3rd.sso.SSO.__init__","title":"<code>__init__(host, database, sql_port=3306, db_username=None, db_password=None, with_pool=True, timeout=3, debug=False)</code>","text":"<p>Constructs all the necessary attributes for the SSO object.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>host</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The host of the MediaWiki database.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>database</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The name of the MediaWiki database.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>sql_port</code>\n            \n                  <code>int</code>\n            \n            \n              \n                <p>The SQL port for the database connection.</p>\n              \n            \n            \n                  <code>3306</code>\n            \n          \n          \n            <code>db_username</code>\n            \n                  <code>Optional[str]</code>\n            \n            \n              \n                <p>The database username.</p>\n              \n            \n            \n                  <code>None</code>\n            \n          \n          \n            <code>db_password</code>\n            \n                  <code>Optional[str]</code>\n            \n            \n              \n                <p>The database password.</p>\n              \n            \n            \n                  <code>None</code>\n            \n          \n          \n            <code>with_pool</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>Flag to determine if connection pooling is used.</p>\n              \n            \n            \n                  <code>True</code>\n            \n          \n          \n            <code>timeout</code>\n            \n                  <code>float</code>\n            \n            \n              \n                <p>The timeout for checking SQL port availability.</p>\n              \n            \n            \n                  <code>3</code>\n            \n          \n          \n            <code>debug</code>\n            \n                  <code>Optional[bool]</code>\n            \n            \n              \n                <p>Flag to enable debug mode.</p>\n              \n            \n            \n                  <code>False</code>\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/sso.py</code>\n              <pre><code>def __init__(\n    self,\n    host: str,\n    database: str,\n    sql_port: int = 3306,\n    db_username: Optional[str] = None,\n    db_password: Optional[str] = None,\n    with_pool: bool = True,\n    timeout: float = 3,\n    debug: Optional[bool] = False,\n):\n    \"\"\"\n    Constructs all the necessary attributes for the SSO object.\n\n    Args:\n        host (str): The host of the MediaWiki database.\n        database (str): The name of the MediaWiki database.\n        sql_port (int): The SQL port for the database connection.\n        db_username (Optional[str]): The database username.\n        db_password (Optional[str]): The database password.\n        with_pool (bool): Flag to determine if connection pooling is used.\n        timeout (float): The timeout for checking SQL port availability.\n        debug (Optional[bool]): Flag to enable debug mode.\n    \"\"\"\n    self.host = host\n    self.database = database\n    self.sql_port = sql_port\n    self.timeout = timeout\n    self.db_username = db_username\n    self.db_password = db_password\n    self.debug = debug\n    self.pool = self.get_pool() if with_pool else None\n</code></pre>"},{"location":"#wikibot3rd.sso.SSO.check_credentials","title":"<code>check_credentials(username, password)</code>","text":"<p>Checks the validity of MediaWiki username and password.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>username</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The MediaWiki username.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>password</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The password to verify.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>bool</code>            \n                  <code>bool</code>\n            \n            \n              \n                <p>True if the credentials are valid, False otherwise.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/sso.py</code>\n              <pre><code>def check_credentials(self, username: str, password: str) -&gt; bool:\n    \"\"\"\n    Checks the validity of MediaWiki username and password.\n\n    Args:\n        username (str): The MediaWiki username.\n        password (str): The password to verify.\n\n    Returns:\n        bool: True if the credentials are valid, False otherwise.\n    \"\"\"\n    is_valid = False\n    user = self.get_user(username)\n    if user:\n        stored_hash = user.password\n        is_valid = self.verify_password(password, stored_hash)\n    elif self.debug:\n        print(f\"Username {username} not found in {self.database} on {self.host}\")\n    return is_valid\n</code></pre>"},{"location":"#wikibot3rd.sso.SSO.check_port","title":"<code>check_port()</code>","text":"<p>Checks if the specified SQL port is accessible on the configured host.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>bool</code>            \n                  <code>bool</code>\n            \n            \n              \n                <p>True if the port is accessible, False otherwise.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/sso.py</code>\n              <pre><code>def check_port(self) -&gt; bool:\n    \"\"\"\n    Checks if the specified SQL port is accessible on the configured host.\n\n    Returns:\n        bool: True if the port is accessible, False otherwise.\n    \"\"\"\n    try:\n        with socket.create_connection(\n            (self.host, self.sql_port), timeout=self.timeout\n        ):\n            return True\n    except socket.error as ex:\n        if self.debug:\n            print(f\"Connection to {self.host} port {self.sql_port} failed: {ex}\")\n            traceback.print_exc()\n        return False\n</code></pre>"},{"location":"#wikibot3rd.sso.SSO.fetch_user_data_from_database","title":"<code>fetch_user_data_from_database(mw_username)</code>","text":"<p>Fetch user data from the database.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>mw_username(str)</code>\n            \n            \n            \n              \n                <p>the Mediawiki username</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/sso.py</code>\n              <pre><code>def fetch_user_data_from_database(self, mw_username: str) -&gt; Optional[dict]:\n    \"\"\"\n    Fetch user data from the database.\n\n    Args:\n        mw_username(str): the Mediawiki username\n    \"\"\"\n    user_record = None\n    try:\n        connection = (\n            self.pool.get_connection()\n            if self.pool\n            else mysql.connector.connect(\n                host=self.host,\n                user=self.db_username,\n                password=self.db_password,\n                database=self.database,\n            )\n        )\n        # JOIN query: Fetch user data and sysop status\n        sql_query = \"\"\"\n        SELECT u.*, \n               COUNT(ug.ug_group) AS is_sysop\n        FROM `user` u\n        LEFT JOIN `user_groups` ug ON u.user_id = ug.ug_user AND ug.ug_group = 'sysop'\n        WHERE u.user_name = %s\n        GROUP BY u.user_id\n        \"\"\"\n        user_record = self.query(connection, sql_query, (mw_username,))\n    except Exception as ex:\n        if self.debug:\n            print(f\"Database error: {ex}\")\n            traceback.print_exc()\n    finally:\n        if connection and connection.is_connected():\n            connection.close()\n    return user_record\n</code></pre>"},{"location":"#wikibot3rd.sso.SSO.get_pool","title":"<code>get_pool()</code>","text":"<p>Creates a connection pool for the database.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>MySQLConnectionPool</code>            \n                  <code>MySQLConnectionPool</code>\n            \n            \n              \n                <p>A pool of database connections.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/sso.py</code>\n              <pre><code>def get_pool(self) -&gt; pooling.MySQLConnectionPool:\n    \"\"\"\n    Creates a connection pool for the database.\n\n    Returns:\n        MySQLConnectionPool: A pool of database connections.\n    \"\"\"\n    pool_config = {\n        \"pool_name\": \"mypool\",\n        \"pool_size\": 2,\n        \"host\": self.host,\n        \"user\": self.db_username,\n        \"password\": self.db_password,\n        \"database\": self.database,\n        \"raise_on_warnings\": True,\n    }\n    return pooling.MySQLConnectionPool(**pool_config)\n</code></pre>"},{"location":"#wikibot3rd.sso.SSO.get_user","title":"<code>get_user(username)</code>","text":"<p>Retrieve details of a user by username.\nReturns a User object if found, otherwise None.</p>\n\n            \n              Source code in <code>wikibot3rd/sso.py</code>\n              <pre><code>def get_user(self, username: str) -&gt; Optional[User]:\n    \"\"\"\n    Retrieve details of a user by username.\n    Returns a User object if found, otherwise None.\n    \"\"\"\n    mw_username = username[0].upper() + username[1:]\n    user_record = self.fetch_user_data_from_database(mw_username)\n    if user_record:\n        return User(\n            id=user_record[\"user_id\"],\n            name=user_record[\"user_name\"],\n            real_name=user_record[\"user_real_name\"],\n            password=user_record[\"user_password\"],\n            email=user_record[\"user_email\"],\n            touched=user_record[\"user_touched\"],\n            editcount=user_record[\"user_editcount\"],\n            is_admin=user_record[\"is_sysop\"] &gt; 0,\n        )\n    return None\n</code></pre>"},{"location":"#wikibot3rd.sso.SSO.verify_password","title":"<code>verify_password(password, hash_value)</code>","text":"<p>Verifies a password against a stored hash value.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>password</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The password to verify.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>hash_value</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The stored hash value to compare against.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>bool</code>            \n                  <code>bool</code>\n            \n            \n              \n                <p>True if the password matches the hash value, False otherwise.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/sso.py</code>\n              <pre><code>def verify_password(self, password: str, hash_value: str) -&gt; bool:\n    \"\"\"\n    Verifies a password against a stored hash value.\n\n    Args:\n        password (str): The password to verify.\n        hash_value (str): The stored hash value to compare against.\n\n    Returns:\n        bool: True if the password matches the hash value, False otherwise.\n    \"\"\"\n    parts = hash_value.split(\":\")\n    if len(parts) != 7:\n        raise ValueError(\"Invalid hash format\")\n\n    (\n        _,\n        pbkdf2_indicator,\n        hash_algorithm,\n        iterations,\n        _,\n        salt,\n        hashed_password,\n    ) = parts\n\n    if pbkdf2_indicator != \"pbkdf2\":\n        raise ValueError(\"verify_password expects pbkdf2 hashes\")\n\n    iterations = int(iterations)\n\n    def fix_base64_padding(string: str) -&gt; str:\n        return string + \"=\" * (-len(string) % 4)\n\n    salt = fix_base64_padding(salt)\n    hashed_password = fix_base64_padding(hashed_password)\n\n    salt = base64.b64decode(salt)\n    hashed_password = base64.b64decode(hashed_password)\n\n    if hash_algorithm not in hashlib.algorithms_available:\n        raise ValueError(f\"Unsupported hash algorithm: {hash_algorithm}\")\n\n    new_hash = hashlib.pbkdf2_hmac(\n        hash_algorithm, password.encode(\"utf-8\"), salt, iterations\n    )\n    return new_hash == hashed_password\n</code></pre>"},{"location":"#wikibot3rd.sso.User","title":"<code>User</code>","text":"<p>Mediawiki user details</p>\n\n              \n                Source code in <code>wikibot3rd/sso.py</code>\n                <pre><code>@lod_storable\nclass User:\n    \"\"\"\n    Mediawiki user details\n    \"\"\"\n\n    id: int\n    name: str\n    real_name: str\n    password: str  # hashed password\n    email: str\n    touched: str\n    editcount: int\n    is_admin: Optional[bool] = False\n\n    def __post_init__(self):\n        # Safely convert binary fields to strings if they are not already\n        if isinstance(self.password, bytes):\n            self.password = self.password.decode(\"utf-8\", errors=\"replace\")\n        if isinstance(self.touched, bytes):\n            self.touched = self.touched.decode(\"utf-8\", errors=\"replace\")\n</code></pre>"},{"location":"#wikibot3rd.version","title":"<code>version</code>","text":"<p>Created on 2022-03-24</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.version.Version","title":"<code>Version</code>","text":"<p>\n              Bases: <code>object</code></p>\n\n\n      <p>Version handling for py-3rdparty-mediawiki</p>\n\n              \n                Source code in <code>wikibot3rd/version.py</code>\n                <pre><code>class Version(object):\n    \"\"\"\n    Version handling for py-3rdparty-mediawiki\n    \"\"\"\n\n    name = \"py-3rdparty-mediawiki\"\n    version = wikibot3rd.__version__\n    date = \"2020-10-31\"\n    updated = \"2024-11-08\"\n\n    authors = \"Wolfgang Fahl, Tim Holzheim\"\n\n    description = \"Wrapper for mwclient with improvements for 3rd party wikis\"\n\n    cm_url = \"https://github.com/WolfgangFahl/py-3rdparty-mediawiki\"\n    chat_url = \"https://github.com/WolfgangFahl/py-3rdparty-mediawiki/discussions\"\n    doc_url = \"https://wiki.bitplan.com/index.php/Py-3rdparty-mediawiki\"\n\n    license = f\"\"\"Copyright 2020-2024 contributors. All rights reserved.\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#wikibot3rd.wiki","title":"<code>wiki</code>","text":"<p>Created on 2020-11-05</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wiki.Wiki","title":"<code>Wiki</code>","text":"<p>\n              Bases: <code>object</code></p>\n\n\n      <p>common interface for WikiBot and WikiClient</p>\n\n              \n                Source code in <code>wikibot3rd/wiki.py</code>\n                <pre><code>class Wiki(object):\n    \"\"\"\n    common interface for WikiBot and WikiClient\n    \"\"\"\n\n    def __init__(self, wikiUser, debug=False, smw_enabled: bool = True):\n        \"\"\"\n        Constructor\n\n        Args:\n            wikiUser(WikiUser): the wiki user to initialize me for\n        \"\"\"\n        self.wikiUser = wikiUser\n        self.debug = debug\n        self.is_smw_enabled = smw_enabled\n\n    def __str__(self):\n        \"\"\"\n        return a string representation of myself\n        \"\"\"\n        wu = self.wikiUser\n        botType = type(self).__name__\n        text = \"%20s(%10s): %15s %s\" % (wu.wikiId, botType, wu.user, wu.url)\n        return text\n</code></pre>"},{"location":"#wikibot3rd.wiki.Wiki.__init__","title":"<code>__init__(wikiUser, debug=False, smw_enabled=True)</code>","text":"<p>Constructor</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>wikiUser(WikiUser)</code>\n            \n            \n            \n              \n                <p>the wiki user to initialize me for</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wiki.py</code>\n              <pre><code>def __init__(self, wikiUser, debug=False, smw_enabled: bool = True):\n    \"\"\"\n    Constructor\n\n    Args:\n        wikiUser(WikiUser): the wiki user to initialize me for\n    \"\"\"\n    self.wikiUser = wikiUser\n    self.debug = debug\n    self.is_smw_enabled = smw_enabled\n</code></pre>"},{"location":"#wikibot3rd.wiki.Wiki.__str__","title":"<code>__str__()</code>","text":"<p>return a string representation of myself</p>\n\n            \n              Source code in <code>wikibot3rd/wiki.py</code>\n              <pre><code>def __str__(self):\n    \"\"\"\n    return a string representation of myself\n    \"\"\"\n    wu = self.wikiUser\n    botType = type(self).__name__\n    text = \"%20s(%10s): %15s %s\" % (wu.wikiId, botType, wu.user, wu.url)\n    return text\n</code></pre>"},{"location":"#wikibot3rd.wikiaction","title":"<code>wikiaction</code>","text":"<p>Created on 2021-02-02</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikiaction.WikiAction","title":"<code>WikiAction</code>","text":"<p>\n              Bases: <code>object</code></p>\n\n\n      <p>perform an action on the given semantic media wiki</p>\n\n              \n                Source code in <code>wikibot3rd/wikiaction.py</code>\n                <pre><code>class WikiAction(object):\n    \"\"\"\n    perform an action on the given semantic media wiki\n    \"\"\"\n\n    def __init__(self, smw, debug=False):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.smw = smw\n        self.debug = debug\n        self.sourceCodeResult = self.getSourceCodes()\n\n    def getSourceCodes(self):\n        ask = \"\"\"{{#ask: [[Concept:Sourcecode]]\n|mainlabel=Sourcecode\n| ?Sourcecode id = id\n| ?Sourcecode lang = lang\n| ?Sourcecode text = text\n| ?Sourcecode author = author\n| ?Sourcecode since = since\n| ?Sourcecode url = url\n}}\"\"\"\n        result = self.smw.query(ask)\n        return result\n\n    def getLambdaAction(self, name, queryName, actionName):\n        \"\"\"\n        get an action from the result with the given query and actionName\n        \"\"\"\n        if self.debug:\n            print(\n                \"lambdaAction with query: %s and action: %s\" % (queryName, actionName)\n            )\n        qCode = self.sourceCodeResult[queryName]\n        query = Query(name=qCode[\"id\"], query=qCode[\"text\"], lang=qCode[\"lang\"])\n        sCode = self.sourceCodeResult[actionName]\n        code = Code(name=sCode[\"id\"], text=sCode[\"text\"], lang=sCode[\"lang\"])\n        action = LambdaAction(name, query=query, code=code)\n        return action\n</code></pre>"},{"location":"#wikibot3rd.wikiaction.WikiAction.__init__","title":"<code>__init__(smw, debug=False)</code>","text":"<p>Constructor</p>\n\n            \n              Source code in <code>wikibot3rd/wikiaction.py</code>\n              <pre><code>def __init__(self, smw, debug=False):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.smw = smw\n    self.debug = debug\n    self.sourceCodeResult = self.getSourceCodes()\n</code></pre>"},{"location":"#wikibot3rd.wikiaction.WikiAction.getLambdaAction","title":"<code>getLambdaAction(name, queryName, actionName)</code>","text":"<p>get an action from the result with the given query and actionName</p>\n\n            \n              Source code in <code>wikibot3rd/wikiaction.py</code>\n              <pre><code>def getLambdaAction(self, name, queryName, actionName):\n    \"\"\"\n    get an action from the result with the given query and actionName\n    \"\"\"\n    if self.debug:\n        print(\n            \"lambdaAction with query: %s and action: %s\" % (queryName, actionName)\n        )\n    qCode = self.sourceCodeResult[queryName]\n    query = Query(name=qCode[\"id\"], query=qCode[\"text\"], lang=qCode[\"lang\"])\n    sCode = self.sourceCodeResult[actionName]\n    code = Code(name=sCode[\"id\"], text=sCode[\"text\"], lang=sCode[\"lang\"])\n    action = LambdaAction(name, query=query, code=code)\n    return action\n</code></pre>"},{"location":"#wikibot3rd.wikibackup","title":"<code>wikibackup</code>","text":"<p>Created on 2020-12-05</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikibot","title":"<code>wikibot</code>","text":"<p>Created on 2020-03-24</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikibot.WikiBot","title":"<code>WikiBot</code>","text":"<p>\n              Bases: <code>Wiki</code></p>\n\n\n      <p>WikiBot</p>\n\n              \n                Source code in <code>wikibot3rd/wikibot.py</code>\n                <pre><code>class WikiBot(Wiki):\n    \"\"\"\n    WikiBot\n    \"\"\"\n\n    @staticmethod\n    def getBots(limit=None, name=None, valueExpr=None):\n        bots = {}\n        wikiUsers = WikiUser.getWikiUsers().values()\n        for wikiUser in wikiUsers:\n            selected = True\n            if name is not None:\n                value = wikiUser.__dict__[name]\n                found = re.search(valueExpr, value)\n                selected = found is not None\n            if selected:\n                wikibot = WikiBot(wikiUser)\n                bots[wikiUser.wikiId] = wikibot\n                if limit is not None and len(bots) &gt;= limit:\n                    break\n        return bots\n\n    @staticmethod\n    def ofWikiId(wikiId, lenient: bool = True, debug: bool = False):\n        wikiUser = WikiUser.ofWikiId(wikiId, lenient=lenient)\n        wikibot = WikiBot(wikiUser, debug=debug)\n        return wikibot\n\n    @staticmethod\n    def ofWikiUser(wikiUser, debug: bool = False):\n        wikibot = WikiBot(wikiUser, debug=debug)\n        return wikibot\n\n    def __init__(\n        self, wikiUser, debug: bool = False, withLogin: bool = False, maxRetries=2\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            wikiUser(WikiUser): the wiki user to initialize me for\n            debug(bool): True if debug mode should be on\n            withLogin(bool): True if init should automatically login\n        \"\"\"\n        pywikibot.config.max_retries = maxRetries\n        super(WikiBot, self).__init__(wikiUser, debug)\n        self.family = wikiUser.wikiId.replace(\"-\", \"\").replace(\"_\", \"\")\n        self.url = wikiUser.url.replace(\"\\\\:\", \":\")\n        if not self.url:\n            raise Exception(\"url is missing for %s\" % wikiUser.wikiId)\n\n        self.scriptPath = wikiUser.scriptPath\n        self.version = wikiUser.version\n        o = urlparse(self.url)\n        self.scheme = o.scheme\n        self.netloc = o.netloc\n        msg = f\"netloc for family {self.family} is {self.netloc} derived from url {self.url}\"\n        if self.debug:\n            print(msg)\n        self.scriptPath = o.path + self.scriptPath\n        self.checkFamily()\n        if withLogin:\n            self.login()\n\n    def register_family_file(self, familyName: str, famfile: str):\n        \"\"\"\n        register the family file\n\n        Args:\n            family(str): the familyName to register\n            famfile(str): the path to the family file\n        \"\"\"\n        # deprecated code\n        # config2.register_family_file(familyName, famfile)\n        pywikibot.config.family_files[familyName] = famfile\n\n    def checkFamily(self):\n        \"\"\"\n        check if a valid family file exists and if not create it\n\n        watch out for https://stackoverflow.com/questions/76612838/how-to-work-with-custom-wikibase-using-pywikibot\n        8.2 changes that might break old family files\n        \"\"\"\n        iniFile = WikiUser.iniFilePath(self.wikiUser.wikiId)\n        famfile = iniFile.replace(\".ini\", \".py\")\n        if not isfile(famfile):\n            print(\"creating family file %s\" % famfile)\n            template = \"\"\"# -*- coding: utf-8  -*-\nfrom pywikibot import family\n\nclass Family(family.Family):\n    name = '%s'\n    langs = {\n        'en': '%s',\n    }\n    def scriptpath(self, code):\n       return '%s'\n\n    def isPublic(self):\n        return %s\n\n    def version(self, code):\n        return \"%s\"  # The MediaWiki version used. Very important in most cases. (contrary to documentation)\n\n    def protocol(self, code):\n       return '%s'\n\n    def ignore_certificate_error(self, code):\n       return True\n\"\"\"\n            mw_version = self.wikiUser.version.lower().replace(\"mediawiki \", \"\")\n            ispublic = \"False\" if self.wikiUser.user is not None else \"True\"\n            code = template % (\n                self.family,\n                self.netloc,\n                self.scriptPath,\n                ispublic,\n                mw_version,\n                self.scheme,\n            )\n            with open(famfile, \"w\") as py_file:\n                py_file.write(code)\n        self.register_family_file(self.family, famfile)\n        if self.wikiUser.user:\n            pywikibot.config.usernames[self.family][\"en\"] = self.wikiUser.user\n        # config2.authenticate[self.netloc] = (self.user,self.getPassword())\n        self.site = pywikibot.Site(\"en\", self.family)\n\n    def login(self):\n        if self.wikiUser.user:\n            # needs patch as outlined in https://phabricator.wikimedia.org/T248471\n            # self.site.login(password=self.wikiUser.getPassword())\n            lm = pywikibot.login.ClientLoginManager(\n                password=self.wikiUser.getPassword(),\n                site=self.site,\n                user=self.wikiUser.user,\n            )\n            lm.login()\n        else:\n            raise Exception(\"wikiUser is not set\")\n\n    def getWikiMarkup(self, pageTitle):\n        \"\"\"\n        get the wiki markup code (text) for the given page Title\n\n        Args:\n            pageTitle(str): the title of the page to retrieve\n\n        Returns:\n            str: the wiki markup code for the page\n        \"\"\"\n        page = self.getPage(pageTitle)\n        markup = page.text\n        return markup\n\n    def getHtml(self, pageTitle):\n        \"\"\"\n        get the HTML code for the given page Title\n\n        Args:\n            pageTitle(str): the title of the page to retrieve\n\n        Returns:\n            str: the rendered HTML code for the page\n        \"\"\"\n        page = self.getPage(pageTitle)\n        html = page.get_parsed_page()\n        return html\n\n    def getPage(self, pageTitle):\n        \"\"\"get the page with the given title\n        Args:\n            pageTitle(str): the title of the page to retrieve\n        Returns:\n            Page: the wikibot3rd page for the given pageTitle\n        \"\"\"\n        page = pywikibot.Page(self.site, pageTitle)\n        return page\n\n    def savePage(self, pageTitle, pageContent, pageSummary):\n        \"\"\"save a page with the given pageTitle, pageContent and pageSummary\"\"\"\n        newPage = self.getPage(pageTitle)\n        newPage.text = pageContent\n        newPage.save(pageSummary)\n</code></pre>"},{"location":"#wikibot3rd.wikibot.WikiBot.__init__","title":"<code>__init__(wikiUser, debug=False, withLogin=False, maxRetries=2)</code>","text":"<p>Constructor</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>wikiUser(WikiUser)</code>\n            \n            \n            \n              \n                <p>the wiki user to initialize me for</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>debug(bool)</code>\n            \n            \n            \n              \n                <p>True if debug mode should be on</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>withLogin(bool)</code>\n            \n            \n            \n              \n                <p>True if init should automatically login</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikibot.py</code>\n              <pre><code>def __init__(\n    self, wikiUser, debug: bool = False, withLogin: bool = False, maxRetries=2\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        wikiUser(WikiUser): the wiki user to initialize me for\n        debug(bool): True if debug mode should be on\n        withLogin(bool): True if init should automatically login\n    \"\"\"\n    pywikibot.config.max_retries = maxRetries\n    super(WikiBot, self).__init__(wikiUser, debug)\n    self.family = wikiUser.wikiId.replace(\"-\", \"\").replace(\"_\", \"\")\n    self.url = wikiUser.url.replace(\"\\\\:\", \":\")\n    if not self.url:\n        raise Exception(\"url is missing for %s\" % wikiUser.wikiId)\n\n    self.scriptPath = wikiUser.scriptPath\n    self.version = wikiUser.version\n    o = urlparse(self.url)\n    self.scheme = o.scheme\n    self.netloc = o.netloc\n    msg = f\"netloc for family {self.family} is {self.netloc} derived from url {self.url}\"\n    if self.debug:\n        print(msg)\n    self.scriptPath = o.path + self.scriptPath\n    self.checkFamily()\n    if withLogin:\n        self.login()\n</code></pre>"},{"location":"#wikibot3rd.wikibot.WikiBot.checkFamily","title":"<code>checkFamily()</code>","text":"<p>check if a valid family file exists and if not create it</p>\n<p>watch out for https://stackoverflow.com/questions/76612838/how-to-work-with-custom-wikibase-using-pywikibot\n8.2 changes that might break old family files</p>\n\n            \n              Source code in <code>wikibot3rd/wikibot.py</code>\n              <pre><code>    def checkFamily(self):\n        \"\"\"\n        check if a valid family file exists and if not create it\n\n        watch out for https://stackoverflow.com/questions/76612838/how-to-work-with-custom-wikibase-using-pywikibot\n        8.2 changes that might break old family files\n        \"\"\"\n        iniFile = WikiUser.iniFilePath(self.wikiUser.wikiId)\n        famfile = iniFile.replace(\".ini\", \".py\")\n        if not isfile(famfile):\n            print(\"creating family file %s\" % famfile)\n            template = \"\"\"# -*- coding: utf-8  -*-\nfrom pywikibot import family\n\nclass Family(family.Family):\n    name = '%s'\n    langs = {\n        'en': '%s',\n    }\n    def scriptpath(self, code):\n       return '%s'\n\n    def isPublic(self):\n        return %s\n\n    def version(self, code):\n        return \"%s\"  # The MediaWiki version used. Very important in most cases. (contrary to documentation)\n\n    def protocol(self, code):\n       return '%s'\n\n    def ignore_certificate_error(self, code):\n       return True\n\"\"\"\n            mw_version = self.wikiUser.version.lower().replace(\"mediawiki \", \"\")\n            ispublic = \"False\" if self.wikiUser.user is not None else \"True\"\n            code = template % (\n                self.family,\n                self.netloc,\n                self.scriptPath,\n                ispublic,\n                mw_version,\n                self.scheme,\n            )\n            with open(famfile, \"w\") as py_file:\n                py_file.write(code)\n        self.register_family_file(self.family, famfile)\n        if self.wikiUser.user:\n            pywikibot.config.usernames[self.family][\"en\"] = self.wikiUser.user\n        # config2.authenticate[self.netloc] = (self.user,self.getPassword())\n        self.site = pywikibot.Site(\"en\", self.family)\n</code></pre>"},{"location":"#wikibot3rd.wikibot.WikiBot.getHtml","title":"<code>getHtml(pageTitle)</code>","text":"<p>get the HTML code for the given page Title</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>pageTitle(str)</code>\n            \n            \n            \n              \n                <p>the title of the page to retrieve</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n            \n            \n              \n                <p>the rendered HTML code for the page</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikibot.py</code>\n              <pre><code>def getHtml(self, pageTitle):\n    \"\"\"\n    get the HTML code for the given page Title\n\n    Args:\n        pageTitle(str): the title of the page to retrieve\n\n    Returns:\n        str: the rendered HTML code for the page\n    \"\"\"\n    page = self.getPage(pageTitle)\n    html = page.get_parsed_page()\n    return html\n</code></pre>"},{"location":"#wikibot3rd.wikibot.WikiBot.getPage","title":"<code>getPage(pageTitle)</code>","text":"<p>get the page with the given title\nArgs:\n    pageTitle(str): the title of the page to retrieve\nReturns:\n    Page: the wikibot3rd page for the given pageTitle</p>\n\n            \n              Source code in <code>wikibot3rd/wikibot.py</code>\n              <pre><code>def getPage(self, pageTitle):\n    \"\"\"get the page with the given title\n    Args:\n        pageTitle(str): the title of the page to retrieve\n    Returns:\n        Page: the wikibot3rd page for the given pageTitle\n    \"\"\"\n    page = pywikibot.Page(self.site, pageTitle)\n    return page\n</code></pre>"},{"location":"#wikibot3rd.wikibot.WikiBot.getWikiMarkup","title":"<code>getWikiMarkup(pageTitle)</code>","text":"<p>get the wiki markup code (text) for the given page Title</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>pageTitle(str)</code>\n            \n            \n            \n              \n                <p>the title of the page to retrieve</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n            \n            \n              \n                <p>the wiki markup code for the page</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikibot.py</code>\n              <pre><code>def getWikiMarkup(self, pageTitle):\n    \"\"\"\n    get the wiki markup code (text) for the given page Title\n\n    Args:\n        pageTitle(str): the title of the page to retrieve\n\n    Returns:\n        str: the wiki markup code for the page\n    \"\"\"\n    page = self.getPage(pageTitle)\n    markup = page.text\n    return markup\n</code></pre>"},{"location":"#wikibot3rd.wikibot.WikiBot.register_family_file","title":"<code>register_family_file(familyName, famfile)</code>","text":"<p>register the family file</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>family(str)</code>\n            \n            \n            \n              \n                <p>the familyName to register</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>famfile(str)</code>\n            \n            \n            \n              \n                <p>the path to the family file</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikibot.py</code>\n              <pre><code>def register_family_file(self, familyName: str, famfile: str):\n    \"\"\"\n    register the family file\n\n    Args:\n        family(str): the familyName to register\n        famfile(str): the path to the family file\n    \"\"\"\n    # deprecated code\n    # config2.register_family_file(familyName, famfile)\n    pywikibot.config.family_files[familyName] = famfile\n</code></pre>"},{"location":"#wikibot3rd.wikibot.WikiBot.savePage","title":"<code>savePage(pageTitle, pageContent, pageSummary)</code>","text":"<p>save a page with the given pageTitle, pageContent and pageSummary</p>\n\n            \n              Source code in <code>wikibot3rd/wikibot.py</code>\n              <pre><code>def savePage(self, pageTitle, pageContent, pageSummary):\n    \"\"\"save a page with the given pageTitle, pageContent and pageSummary\"\"\"\n    newPage = self.getPage(pageTitle)\n    newPage.text = pageContent\n    newPage.save(pageSummary)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient","title":"<code>wikiclient</code>","text":""},{"location":"#wikibot3rd.wikiclient.WikiClient","title":"<code>WikiClient</code>","text":"<p>\n              Bases: <code>Wiki</code></p>\n\n\n      <p>Access MediaWiki via mwclient library.</p>\n\n              \n                Source code in <code>wikibot3rd/wikiclient.py</code>\n                <pre><code>class WikiClient(Wiki):\n    \"\"\"\n    Access MediaWiki via mwclient library.\n    \"\"\"\n\n    def __init__(\n        self, wiki_user: WikiUser, debug: bool = False, smw_enabled: bool = True\n    ):\n        \"\"\"\n        Initialize the WikiClient with a WikiUser and an optional debug mode.\n\n        Args:\n            wiki_user: A WikiUser instance containing login credentials.\n            debug: A flag to enable debug mode.\n        \"\"\"\n        super(WikiClient, self).__init__(\n            wiki_user, debug=debug, smw_enabled=smw_enabled\n        )\n        self.wiki_user: WikiUser = wiki_user\n        # compatibility\n        self.wikiUser = self.wiki_user\n        self.site: Optional[Site] = None\n        self._is_logged_in: bool = False\n\n    def get_site(self) -&gt; Site:\n        \"\"\"\n        Get the Site object for the MediaWiki site.\n\n        Returns:\n            The Site object representing the MediaWiki site.\n        \"\"\"\n        if self.site is None:\n            o = urlparse(self.wiki_user.url)\n            scheme = o.scheme\n            host = o.netloc\n            path = o.path + self.wiki_user.scriptPath\n            path = f\"{path}/\"\n            self.site = Site(host=host, path=path, scheme=scheme)\n        return self.site\n\n    def getSite(self) -&gt; Site:\n        \"\"\"Deprecated: Use get_site instead.\"\"\"\n        return self.get_site()\n\n    def needs_login(self) -&gt; bool:\n        \"\"\"\n        Check if login is required for the wiki.\n\n        Returns:\n            True if login is required, False otherwise.\n        \"\"\"\n        login_needed: bool = False\n        site = self.get_site()\n        if not site.initialized:\n            try:\n                self.site.site_init()\n                if hasattr(\"site\", \"writeapi\"):\n                    login_needed = not site.writeapi\n                else:\n                    login_needed = not \"writeapi\" in site.site\n            except Exception as ex:\n                if hasattr(ex, \"args\") and \"readapidenied\" in ex.args:\n                    login_needed = True\n                pass\n\n        return login_needed\n\n    def needsLogin(self) -&gt; bool:\n        \"\"\"Deprecated: Use needs_login instead.\"\"\"\n        return self.needs_login()\n\n    def try_login(self) -&gt; Exception:\n        \"\"\"\n        Attempt to log in to the MediaWiki site.\n\n        Returns:\n            Exception: None if login is successful, Exception otherwise.\n        \"\"\"\n        wu = self.wiki_user\n        try:\n            self.get_site().login(username=wu.user, password=wu.get_password())\n            self._is_logged_in = True\n            return None\n        except Exception as ex:\n            self._is_logged_in = False\n            return ex\n\n    def login(self) -&gt; bool:\n        \"\"\"\n        Attempt to log in to the MediaWiki site.\n\n        Returns:\n            True if login is successful, False otherwise.\n        \"\"\"\n        ex = self.try_login()\n        if ex and self.debug:\n            print(f\"Login failed: {ex}\")\n        success = ex is None\n        return success\n\n    def get_wiki_markup(self, page_title: str) -&gt; str:\n        \"\"\"\n        Get the wiki markup for a given page title.\n\n        Args:\n            page_title: The title of the page to retrieve the markup for.\n\n        Returns:\n            The wiki markup of the specified page.\n        \"\"\"\n        page = self.get_page(page_title)\n        markup = page.text()\n        return markup\n\n    def getWikiMarkup(self, pageTitle: str) -&gt; str:\n        \"\"\"Deprecated: Use get_wiki_markup instead.\"\"\"\n        return self.get_wiki_markup(pageTitle)\n\n    def get_html(self, page_title: str) -&gt; str:\n        \"\"\"\n        Get the HTML content for a given page title.\n\n        Args:\n            page_title: The title of the page to retrieve the HTML for.\n\n        Returns:\n            The HTML content of the specified page.\n        \"\"\"\n        api = self.get_site().api(\"parse\", page=page_title)\n        if \"parse\" not in api:\n            raise Exception(f\"Could not retrieve HTML for page {page_title}\")\n        html: str = api[\"parse\"][\"text\"][\"*\"]\n        return html\n\n    def getHtml(self, pageTitle: str) -&gt; str:\n        \"\"\"Deprecated: Use get_html instead.\"\"\"\n        return self.get_html(pageTitle)\n\n    def get_page(self, page_title: str) -&gt; Any:\n        \"\"\"\n        Get the page object for a given title.\n\n        Args:\n            page_title: The title of the page to retrieve.\n\n        Returns:\n            The page object for the specified title.\n        \"\"\"\n        page = self.get_site().pages[page_title]\n        return page\n\n    def getPage(self, pageTitle: str) -&gt; Any:\n        \"\"\"Deprecated: Use get_page instead.\"\"\"\n        return self.get_page(pageTitle)\n\n    def save_page(self, page_title: str, page_content: str, page_summary: str) -&gt; None:\n        \"\"\"\n        Save a page with given title and content.\n\n        Args:\n            page_title: The title of the page.\n            page_content: The new content of the page.\n            page_summary: A summary of the changes made.\n        \"\"\"\n        new_page = self.get_page(page_title)\n        new_page.edit(page_content, page_summary)\n\n    def savePage(self, pageTitle: str, pageContent: str, pageSummary: str) -&gt; None:\n        \"\"\"Deprecated: Use save_page instead.\"\"\"\n        self.save_page(pageTitle, pageContent, pageSummary)\n\n    def get_site_statistics(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Fetch site statistics using the MediaWiki API.\n\n        Returns:\n            A dictionary containing the site statistics.\n        \"\"\"\n        params = {\n            \"action\": \"query\",\n            \"meta\": \"siteinfo\",\n            \"siprop\": \"statistics\",\n            \"format\": \"json\",\n        }\n        site = self.get_site()\n        data = site.api(**params)\n        statistics = data[\"query\"][\"statistics\"]\n        return statistics\n\n    def getSiteStatistics(self) -&gt; Dict[str, Any]:\n        \"\"\"Deprecated: Use get_site_statistics instead.\"\"\"\n        return self.get_site_statistics()\n\n    @staticmethod\n    def get_clients() -&gt; Dict[str, \"WikiClient\"]:\n        \"\"\"\n        Get a dictionary of WikiClient instances for all WikiUsers.\n\n        Returns:\n            Dict[str, WikiClient]: A dictionary with wiki user IDs as keys and WikiClient instances as values.\n        \"\"\"\n        clients: Dict[str, WikiClient] = {}\n        for wiki_user in WikiUser.getWikiUsers().values():\n            wiki_client = WikiClient(wiki_user)\n            clients[wiki_user.wikiId] = wiki_client\n        return clients\n\n    @staticmethod\n    def getClients() -&gt; Dict[str, \"WikiClient\"]:\n        \"\"\"Deprecated: Use get_clients instead.\"\"\"\n        return WikiClient.get_clients()\n\n    @staticmethod\n    def of_wiki_id(\n        wiki_id: str, lenient: bool = True, debug: bool = False\n    ) -&gt; \"WikiClient\":\n        \"\"\"\n        Create a WikiClient instance for a specific wiki ID.\n\n        Args:\n            wiki_id: The ID of the wiki to create a client for.\n            lenient: Whether to be lenient in case of errors.\n            debug: Whether to enable debug output.\n\n        Returns:\n            WikiClient: A WikiClient instance for the given wiki ID.\n        \"\"\"\n        wiki_user = WikiUser.ofWikiId(wiki_id, lenient=lenient)\n        wikibot = WikiClient(wiki_user, debug=debug)\n        wikibot.is_smw_enabled = wiki_user.is_smw\n        return wikibot\n\n    @staticmethod\n    def ofWikiId(\n        wiki_id: str, lenient: bool = True, debug: bool = False\n    ) -&gt; \"WikiClient\":\n        \"\"\"Deprecated: Use of_wiki_id instead.\"\"\"\n        return WikiClient.of_wiki_id(wiki_id, lenient=lenient, debug=debug)\n\n    @staticmethod\n    def of_wiki_user(wiki_user: WikiUser, debug: bool = False) -&gt; \"WikiClient\":\n        \"\"\"\n        Create a WikiClient instance from a WikiUser object.\n\n        Args:\n            wiki_user: A WikiUser instance to create a WikiClient for.\n\n        Returns:\n            WikiClient: A WikiClient instance for the given WikiUser.\n        \"\"\"\n        wikibot = WikiClient(wiki_user, debug=debug)\n        wikibot.is_smw_enabled = wiki_user.is_smw\n        return wikibot\n\n    @staticmethod\n    def ofWikiUser(wiki_user: WikiUser, debug: bool = False) -&gt; \"WikiClient\":\n        \"\"\"Deprecated: Use of_wiki_user instead.\"\"\"\n        return WikiClient.of_wiki_user(wiki_user, debug=debug)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.__init__","title":"<code>__init__(wiki_user, debug=False, smw_enabled=True)</code>","text":"<p>Initialize the WikiClient with a WikiUser and an optional debug mode.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>wiki_user</code>\n            \n                  <code>WikiUser</code>\n            \n            \n              \n                <p>A WikiUser instance containing login credentials.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>debug</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>A flag to enable debug mode.</p>\n              \n            \n            \n                  <code>False</code>\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def __init__(\n    self, wiki_user: WikiUser, debug: bool = False, smw_enabled: bool = True\n):\n    \"\"\"\n    Initialize the WikiClient with a WikiUser and an optional debug mode.\n\n    Args:\n        wiki_user: A WikiUser instance containing login credentials.\n        debug: A flag to enable debug mode.\n    \"\"\"\n    super(WikiClient, self).__init__(\n        wiki_user, debug=debug, smw_enabled=smw_enabled\n    )\n    self.wiki_user: WikiUser = wiki_user\n    # compatibility\n    self.wikiUser = self.wiki_user\n    self.site: Optional[Site] = None\n    self._is_logged_in: bool = False\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.getClients","title":"<code>getClients()</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Deprecated: Use get_clients instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>@staticmethod\ndef getClients() -&gt; Dict[str, \"WikiClient\"]:\n    \"\"\"Deprecated: Use get_clients instead.\"\"\"\n    return WikiClient.get_clients()\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.getHtml","title":"<code>getHtml(pageTitle)</code>","text":"<p>Deprecated: Use get_html instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def getHtml(self, pageTitle: str) -&gt; str:\n    \"\"\"Deprecated: Use get_html instead.\"\"\"\n    return self.get_html(pageTitle)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.getPage","title":"<code>getPage(pageTitle)</code>","text":"<p>Deprecated: Use get_page instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def getPage(self, pageTitle: str) -&gt; Any:\n    \"\"\"Deprecated: Use get_page instead.\"\"\"\n    return self.get_page(pageTitle)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.getSite","title":"<code>getSite()</code>","text":"<p>Deprecated: Use get_site instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def getSite(self) -&gt; Site:\n    \"\"\"Deprecated: Use get_site instead.\"\"\"\n    return self.get_site()\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.getSiteStatistics","title":"<code>getSiteStatistics()</code>","text":"<p>Deprecated: Use get_site_statistics instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def getSiteStatistics(self) -&gt; Dict[str, Any]:\n    \"\"\"Deprecated: Use get_site_statistics instead.\"\"\"\n    return self.get_site_statistics()\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.getWikiMarkup","title":"<code>getWikiMarkup(pageTitle)</code>","text":"<p>Deprecated: Use get_wiki_markup instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def getWikiMarkup(self, pageTitle: str) -&gt; str:\n    \"\"\"Deprecated: Use get_wiki_markup instead.\"\"\"\n    return self.get_wiki_markup(pageTitle)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.get_clients","title":"<code>get_clients()</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Get a dictionary of WikiClient instances for all WikiUsers.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>Dict[str, WikiClient]</code>\n            \n            \n              \n                <p>Dict[str, WikiClient]: A dictionary with wiki user IDs as keys and WikiClient instances as values.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>@staticmethod\ndef get_clients() -&gt; Dict[str, \"WikiClient\"]:\n    \"\"\"\n    Get a dictionary of WikiClient instances for all WikiUsers.\n\n    Returns:\n        Dict[str, WikiClient]: A dictionary with wiki user IDs as keys and WikiClient instances as values.\n    \"\"\"\n    clients: Dict[str, WikiClient] = {}\n    for wiki_user in WikiUser.getWikiUsers().values():\n        wiki_client = WikiClient(wiki_user)\n        clients[wiki_user.wikiId] = wiki_client\n    return clients\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.get_html","title":"<code>get_html(page_title)</code>","text":"<p>Get the HTML content for a given page title.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>page_title</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The title of the page to retrieve the HTML for.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>str</code>\n            \n            \n              \n                <p>The HTML content of the specified page.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def get_html(self, page_title: str) -&gt; str:\n    \"\"\"\n    Get the HTML content for a given page title.\n\n    Args:\n        page_title: The title of the page to retrieve the HTML for.\n\n    Returns:\n        The HTML content of the specified page.\n    \"\"\"\n    api = self.get_site().api(\"parse\", page=page_title)\n    if \"parse\" not in api:\n        raise Exception(f\"Could not retrieve HTML for page {page_title}\")\n    html: str = api[\"parse\"][\"text\"][\"*\"]\n    return html\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.get_page","title":"<code>get_page(page_title)</code>","text":"<p>Get the page object for a given title.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>page_title</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The title of the page to retrieve.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>Any</code>\n            \n            \n              \n                <p>The page object for the specified title.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def get_page(self, page_title: str) -&gt; Any:\n    \"\"\"\n    Get the page object for a given title.\n\n    Args:\n        page_title: The title of the page to retrieve.\n\n    Returns:\n        The page object for the specified title.\n    \"\"\"\n    page = self.get_site().pages[page_title]\n    return page\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.get_site","title":"<code>get_site()</code>","text":"<p>Get the Site object for the MediaWiki site.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>Site</code>\n            \n            \n              \n                <p>The Site object representing the MediaWiki site.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def get_site(self) -&gt; Site:\n    \"\"\"\n    Get the Site object for the MediaWiki site.\n\n    Returns:\n        The Site object representing the MediaWiki site.\n    \"\"\"\n    if self.site is None:\n        o = urlparse(self.wiki_user.url)\n        scheme = o.scheme\n        host = o.netloc\n        path = o.path + self.wiki_user.scriptPath\n        path = f\"{path}/\"\n        self.site = Site(host=host, path=path, scheme=scheme)\n    return self.site\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.get_site_statistics","title":"<code>get_site_statistics()</code>","text":"<p>Fetch site statistics using the MediaWiki API.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>Dict[str, Any]</code>\n            \n            \n              \n                <p>A dictionary containing the site statistics.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def get_site_statistics(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetch site statistics using the MediaWiki API.\n\n    Returns:\n        A dictionary containing the site statistics.\n    \"\"\"\n    params = {\n        \"action\": \"query\",\n        \"meta\": \"siteinfo\",\n        \"siprop\": \"statistics\",\n        \"format\": \"json\",\n    }\n    site = self.get_site()\n    data = site.api(**params)\n    statistics = data[\"query\"][\"statistics\"]\n    return statistics\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.get_wiki_markup","title":"<code>get_wiki_markup(page_title)</code>","text":"<p>Get the wiki markup for a given page title.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>page_title</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The title of the page to retrieve the markup for.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>str</code>\n            \n            \n              \n                <p>The wiki markup of the specified page.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def get_wiki_markup(self, page_title: str) -&gt; str:\n    \"\"\"\n    Get the wiki markup for a given page title.\n\n    Args:\n        page_title: The title of the page to retrieve the markup for.\n\n    Returns:\n        The wiki markup of the specified page.\n    \"\"\"\n    page = self.get_page(page_title)\n    markup = page.text()\n    return markup\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.login","title":"<code>login()</code>","text":"<p>Attempt to log in to the MediaWiki site.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>bool</code>\n            \n            \n              \n                <p>True if login is successful, False otherwise.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def login(self) -&gt; bool:\n    \"\"\"\n    Attempt to log in to the MediaWiki site.\n\n    Returns:\n        True if login is successful, False otherwise.\n    \"\"\"\n    ex = self.try_login()\n    if ex and self.debug:\n        print(f\"Login failed: {ex}\")\n    success = ex is None\n    return success\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.needsLogin","title":"<code>needsLogin()</code>","text":"<p>Deprecated: Use needs_login instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def needsLogin(self) -&gt; bool:\n    \"\"\"Deprecated: Use needs_login instead.\"\"\"\n    return self.needs_login()\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.needs_login","title":"<code>needs_login()</code>","text":"<p>Check if login is required for the wiki.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>bool</code>\n            \n            \n              \n                <p>True if login is required, False otherwise.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def needs_login(self) -&gt; bool:\n    \"\"\"\n    Check if login is required for the wiki.\n\n    Returns:\n        True if login is required, False otherwise.\n    \"\"\"\n    login_needed: bool = False\n    site = self.get_site()\n    if not site.initialized:\n        try:\n            self.site.site_init()\n            if hasattr(\"site\", \"writeapi\"):\n                login_needed = not site.writeapi\n            else:\n                login_needed = not \"writeapi\" in site.site\n        except Exception as ex:\n            if hasattr(ex, \"args\") and \"readapidenied\" in ex.args:\n                login_needed = True\n            pass\n\n    return login_needed\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.ofWikiId","title":"<code>ofWikiId(wiki_id, lenient=True, debug=False)</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Deprecated: Use of_wiki_id instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>@staticmethod\ndef ofWikiId(\n    wiki_id: str, lenient: bool = True, debug: bool = False\n) -&gt; \"WikiClient\":\n    \"\"\"Deprecated: Use of_wiki_id instead.\"\"\"\n    return WikiClient.of_wiki_id(wiki_id, lenient=lenient, debug=debug)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.ofWikiUser","title":"<code>ofWikiUser(wiki_user, debug=False)</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Deprecated: Use of_wiki_user instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>@staticmethod\ndef ofWikiUser(wiki_user: WikiUser, debug: bool = False) -&gt; \"WikiClient\":\n    \"\"\"Deprecated: Use of_wiki_user instead.\"\"\"\n    return WikiClient.of_wiki_user(wiki_user, debug=debug)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.of_wiki_id","title":"<code>of_wiki_id(wiki_id, lenient=True, debug=False)</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Create a WikiClient instance for a specific wiki ID.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>wiki_id</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The ID of the wiki to create a client for.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>lenient</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>Whether to be lenient in case of errors.</p>\n              \n            \n            \n                  <code>True</code>\n            \n          \n          \n            <code>debug</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>Whether to enable debug output.</p>\n              \n            \n            \n                  <code>False</code>\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>WikiClient</code>            \n                  <code>WikiClient</code>\n            \n            \n              \n                <p>A WikiClient instance for the given wiki ID.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>@staticmethod\ndef of_wiki_id(\n    wiki_id: str, lenient: bool = True, debug: bool = False\n) -&gt; \"WikiClient\":\n    \"\"\"\n    Create a WikiClient instance for a specific wiki ID.\n\n    Args:\n        wiki_id: The ID of the wiki to create a client for.\n        lenient: Whether to be lenient in case of errors.\n        debug: Whether to enable debug output.\n\n    Returns:\n        WikiClient: A WikiClient instance for the given wiki ID.\n    \"\"\"\n    wiki_user = WikiUser.ofWikiId(wiki_id, lenient=lenient)\n    wikibot = WikiClient(wiki_user, debug=debug)\n    wikibot.is_smw_enabled = wiki_user.is_smw\n    return wikibot\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.of_wiki_user","title":"<code>of_wiki_user(wiki_user, debug=False)</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Create a WikiClient instance from a WikiUser object.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>wiki_user</code>\n            \n                  <code>WikiUser</code>\n            \n            \n              \n                <p>A WikiUser instance to create a WikiClient for.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>WikiClient</code>            \n                  <code>WikiClient</code>\n            \n            \n              \n                <p>A WikiClient instance for the given WikiUser.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>@staticmethod\ndef of_wiki_user(wiki_user: WikiUser, debug: bool = False) -&gt; \"WikiClient\":\n    \"\"\"\n    Create a WikiClient instance from a WikiUser object.\n\n    Args:\n        wiki_user: A WikiUser instance to create a WikiClient for.\n\n    Returns:\n        WikiClient: A WikiClient instance for the given WikiUser.\n    \"\"\"\n    wikibot = WikiClient(wiki_user, debug=debug)\n    wikibot.is_smw_enabled = wiki_user.is_smw\n    return wikibot\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.savePage","title":"<code>savePage(pageTitle, pageContent, pageSummary)</code>","text":"<p>Deprecated: Use save_page instead.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def savePage(self, pageTitle: str, pageContent: str, pageSummary: str) -&gt; None:\n    \"\"\"Deprecated: Use save_page instead.\"\"\"\n    self.save_page(pageTitle, pageContent, pageSummary)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.save_page","title":"<code>save_page(page_title, page_content, page_summary)</code>","text":"<p>Save a page with given title and content.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>page_title</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The title of the page.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>page_content</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The new content of the page.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>page_summary</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>A summary of the changes made.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def save_page(self, page_title: str, page_content: str, page_summary: str) -&gt; None:\n    \"\"\"\n    Save a page with given title and content.\n\n    Args:\n        page_title: The title of the page.\n        page_content: The new content of the page.\n        page_summary: A summary of the changes made.\n    \"\"\"\n    new_page = self.get_page(page_title)\n    new_page.edit(page_content, page_summary)\n</code></pre>"},{"location":"#wikibot3rd.wikiclient.WikiClient.try_login","title":"<code>try_login()</code>","text":"<p>Attempt to log in to the MediaWiki site.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>Exception</code>            \n                  <code>Exception</code>\n            \n            \n              \n                <p>None if login is successful, Exception otherwise.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiclient.py</code>\n              <pre><code>def try_login(self) -&gt; Exception:\n    \"\"\"\n    Attempt to log in to the MediaWiki site.\n\n    Returns:\n        Exception: None if login is successful, Exception otherwise.\n    \"\"\"\n    wu = self.wiki_user\n    try:\n        self.get_site().login(username=wu.user, password=wu.get_password())\n        self._is_logged_in = True\n        return None\n    except Exception as ex:\n        self._is_logged_in = False\n        return ex\n</code></pre>"},{"location":"#wikibot3rd.wikiedit","title":"<code>wikiedit</code>","text":"<p>Created on 2020-11-12</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikinuke","title":"<code>wikinuke</code>","text":"<p>Created on 2020-11-12</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikipush","title":"<code>wikipush</code>","text":"<p>Created on 2020-10-29\n  @author:     wf\n  @copyright:  Wolfgang Fahl. All rights reserved.</p>"},{"location":"#wikibot3rd.wikipush.WikiPush","title":"<code>WikiPush</code>","text":"<p>\n              Bases: <code>object</code></p>\n\n\n      <p>Push pages from one MediaWiki to another</p>\n\n              \n                Source code in <code>wikibot3rd/wikipush.py</code>\n                <pre><code>class WikiPush(object):\n    \"\"\"\n    Push pages from one MediaWiki to another\n    \"\"\"\n\n    differ = None\n\n    def __init__(\n        self,\n        fromWikiId: str,\n        toWikiId: str = None,\n        login: bool = False,\n        verbose: bool = True,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            fromWikiId(str): the id of the wiki to push from (source)\n            toWikiID(str): the id of the wiki to push to (target)\n            login(bool): if True login to source wiki\n            verbose(bool): if True print info messages\n            debug(bool): if True show debugging messages\n        \"\"\"\n        self.verbose = verbose\n        self.debug = debug\n        self.args = Namespace()\n        self.args.template = None\n        self.fromWiki = None\n        self.toWiki = None\n\n        self.fromWikiId = fromWikiId\n        if self.fromWikiId is not None:\n            self.fromWiki = WikiClient.ofWikiId(fromWikiId, debug=self.debug)\n        self.toWikiId = toWikiId\n        if self.toWikiId is not None:\n            self.toWiki = WikiClient.ofWikiId(toWikiId, debug=self.debug)\n        if login and self.fromWikiId is not None:\n            if not self.fromWiki.login():\n                msg = f\"can't login to source Wiki {fromWikiId}\"\n                ex = Exception(msg)\n                self.show_exception(ex)\n                raise (ex)\n        if self.toWiki is not None:\n            if not self.toWiki.login():\n                msg = f\"can't login to target Wiki {toWikiId}\"\n                ex = Exception(msg)\n                self.show_exception(ex)\n                raise (ex)\n\n    def log(self, msg: str, end=\"\\n\"):\n        \"\"\"\n        show the given message if verbose is on\n\n        Args:\n            msg(str): the message to display\n        \"\"\"\n        if self.verbose:\n            print(msg, end=end)\n\n    def extract_template_records(self, pageRecords, template: str) -&gt; list:\n        \"\"\"\n        Extract template records from the given pageRecords using batch page retrieval.\n\n        Args:\n            pageRecords (dict): Dictionary with page titles as keys\n            template (str): Name of the template to extract (e.g., \"Infobox officeholder\")\n\n        Returns:\n            list[dict]: List of template records, where each record is a dictionary\n                       containing the template parameters. Returns None for pages\n                       where the template is not found.\n\n        Example:\n            &gt;&gt;&gt; pageRecords = {\"John Adams\": {}, \"Thomas Jefferson\": {}}\n            &gt;&gt;&gt; records = extract_template_records(pageRecords, \"Infobox officeholder\")\n        \"\"\"\n        dod = {}\n        page_titles = list(pageRecords.keys())\n        # Get multiple pages at once\n        site = self.fromWiki.get_site()\n        # Process each page\n        for page_title in page_titles:\n            try:\n                page = site.pages[page_title]\n                markup = page.text()\n                wiki_markup = WikiMarkup(page.name, markup)\n                records = wiki_markup.extract_template(template)\n                for i, record in enumerate(records):\n                    if record is not None:\n                        key = f\"{page_title}/{i}\" if i &gt; 0 else page_title\n                        dod[key] = record\n            except Exception as ex:\n                print(f\"\u274c {page_title}: {str(ex)}\", file=sys.stderr)\n                pass\n        return dod\n\n    def formatQueryResult(\n        self,\n        askQuery,\n        wiki=None,\n        limit=None,\n        showProgress=False,\n        queryDivision=1,\n        outputFormat=\"lod\",\n        entityName=\"data\",\n        title: str = None,\n    ):\n        \"\"\"\n        format the query result for the given askQuery.\n        Args:\n            askQuery(string): Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries\n            wiki(wikibot3rd): the wiki to query - use fromWiki if not specified\n            limit(int): the limit for the query (optional)\n            showProgress(bool): true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)\n            queryDivision(int): Defines the number of subintervals the query is divided into (must be greater equal 1)\n            outputFormat(str): output format of the query results - default format is lod\n            entityName(str): the name of the entity\n            title(str): the title of the query (if any)\n        Returns:\n            Query results in the requested outputFormat as string.\n            If the requested outputFormat is not supported None is returned.\n        \"\"\"\n        pageRecords = self.queryPages(\n            askQuery, wiki, limit, showProgress, queryDivision\n        )\n        if self.args.template:\n            pageRecords = self.extract_template_records(\n                pageRecords, template=self.args.template\n            )\n            pass\n        outputFormat = outputFormat.lower()\n        if outputFormat == \"csv\":\n            return self.convertToCSV(pageRecords)\n        elif outputFormat == \"json\":\n            res = []\n            for page in pageRecords.values():\n                res.append(page)\n            res_json = json.dumps({entityName: res}, default=str, indent=3)\n            return res_json\n        elif outputFormat == \"lod\":\n            return [pageRecord for pageRecord in pageRecords.values()]\n        else:\n            if title is None:\n                title = entityName\n            query = Query(name=entityName, query=askQuery, title=title)\n            qlod = [pageRecord for pageRecord in pageRecords.values()]\n            doc = query.documentQueryResult(\n                qlod, limit, tablefmt=outputFormat, withSourceCode=False\n            )\n            return doc\n            # if self.debug:\n            #    print(f\"Format {outputFormat} is not supported.\")\n\n    def convertToCSV(self, pageRecords, separator=\";\"):\n        \"\"\"\n        Converts the given pageRecords into a str in csv format\n        ToDO: Currently does not support escaping of the separator and escaping of quotes\n        Args:\n            pageRecords: dict of dicts containing the printouts\n            separator(char):\n        Returns: str\n        \"\"\"\n        res = \"\"\n        printedHeaders = False\n        for pageRecord in pageRecords.values():\n            if not printedHeaders:\n                for key in pageRecord.keys():\n                    res = f\"{res}{key}{separator}\"\n                res = f\"{res[:-1]}\\n\"\n                printedHeaders = True\n            for printouts in pageRecord.values():\n                res = f\"{res}{printouts}{separator}\"\n            res = f\"{res[:-1]}\\n\"  # remove last separator and end line\n        return res\n\n    def queryPages(\n        self, askQuery: str, wiki=None, limit=None, showProgress=False, queryDivision=1\n    ) -&gt; dict:\n        \"\"\"\n        query the given wiki for pagerecords matching the given askQuery\n\n        Args:\n            askQuery (str): Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries\n            wiki (wikibot3rd): the wiki to query - use fromWiki if not specified\n            limit (int): the limit for the query (optional)\n            showProgress (bool): true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)\n            queryDivision (int): Defines the number of subintervals the query is divided into (must be greater equal 1)\n        Returns:\n            list: a list of pageRecords matching the given askQuery\n        \"\"\"\n        if wiki is None:\n            wiki = self.fromWiki\n        # no wiki no pages e.g. if wikirestore is used without a -s option\n        if wiki is None:\n            pageRecords = []\n\n        if wiki.is_smw_enabled:\n            smwClient = SMWClient(\n                wiki.getSite(),\n                showProgress=showProgress,\n                queryDivision=queryDivision,\n                debug=self.debug,\n            )\n            pageRecords = smwClient.query(askQuery, limit=limit)\n        else:\n            pageRecords = self.query_via_mw_api(askQuery, wiki, limit=limit)\n        return pageRecords\n\n    def extract_category_and_mainlabel(\n        self,\n        askQuery: str,\n        category_labels: List[str] = [\n            \"Category\",\n            \"Kategorie\",\n            \"Cat\u00e9gorie\",\n            \"Categor\u00eda\",\n        ],\n    ) -&gt; Optional[Tuple[str, Optional[str]]]:\n        \"\"\"\n        Extracts the category pattern and mainlabel from a MediaWiki query, supporting multiple language labels.\n\n        Args:\n            askQuery (str): The query string to be processed.\n            category_labels (List[str], optional): A list of category labels in different languages\n                                                   (default: ['Category', 'Kategorie', 'Cat\u00e9gorie', 'Categor\u00eda']).\n\n        Returns:\n            Optional[Tuple[str, Optional[str]]]: A tuple containing the category pattern and\n            the mainlabel if present. Returns None if the query does not match a category pattern.\n        \"\"\"\n        # Join the list of category labels into a regex pattern\n        labels_pattern = \"|\".join(re.escape(label) for label in category_labels)\n\n        # Regex to match category queries in specified languages and optionally a mainlabel\n        pattern = rf\"\\[\\[\\s*(?:{labels_pattern})\\s*:\\s*([^\\]]+)\\s*\\]\\](?:\\s*\\|\\s*mainlabel\\s*=\\s*([^\\|]+))?\"\n        match = re.match(pattern, askQuery.strip())\n\n        if match:\n            category = match.group(1).strip()  # Extract the category pattern\n            mainlabel = (\n                match.group(2).strip() if match.group(2) else None\n            )  # Extract the mainlabel if present\n            return category, mainlabel\n\n        return None\n\n    def query_via_mw_api(self, askQuery: str, wiki, limit: int = None) -&gt; Dict:\n        # Handle non-SMW wiki (assuming category query)\n        category, _ = self.extract_category_and_mainlabel(askQuery)\n        if not category:\n            err_msg = f\"non SMW wiki has limited query support ([[Category:+]] and [[Category:someCategory only]] your query: {askQuery} is not supported\"\n            raise ValueError(err_msg)\n        site = wiki.getSite()\n        # result dict\n        page_records = {}\n        if category == \"+\":\n            q_page_records = site.allcategories()\n        else:\n            q_page_records = site.categories[category]\n        for page in q_page_records:\n            if limit and len(page_records) &gt;= limit:\n                break\n            page_records[page.name] = {\"pageTitle\": page.name}\n        return page_records\n\n    def query(\n        self,\n        askQuery,\n        wiki=None,\n        pageField=None,\n        limit=None,\n        showProgress=False,\n        queryDivision=1,\n    ):\n        \"\"\"\n        query the given wiki for pages matching the given askQuery\n\n        Args:\n            askQuery(string): Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries\n            wiki(wikibot3rd): the wiki to query - use fromWiki if not specified\n            pageField(string): the field to select the pageTitle from\n            limit(int): the limit for the query (optional)\n            showProgress(bool): true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)\n        Returns:\n            list: a list of pageTitles matching the given askQuery\n        \"\"\"\n        pageRecords = self.queryPages(\n            askQuery, wiki, limit, showProgress, queryDivision\n        )\n        if pageField is None:\n            return pageRecords.keys()\n        # use a Dict to remove duplicates\n        pagesDict = {}\n        for pageRecord in pageRecords.values():\n            if pageField in pageRecord:\n                pagesDict[pageRecord[pageField]] = True\n        return list(pagesDict.keys())\n\n    def nuke(self, pageTitles, force=False):\n        \"\"\"\n        delete the pages with the given page Titles\n\n        Args:\n            pageTitles(list): a list of page titles to be transfered from the formWiki to the toWiki\n            force(bool): True if pages should be actually deleted - dry run only listing pages is default\n        \"\"\"\n        total = len(pageTitles)\n        self.log(\n            \"deleting %d pages in %s (%s)\"\n            % (total, self.toWikiId, \"forced\" if force else \"dry run\")\n        )\n        for i, pageTitle in enumerate(pageTitles):\n            try:\n                self.log(\n                    \"%d/%d (%4.0f%%): deleting %s ...\"\n                    % (i + 1, total, (i + 1) / total * 100, pageTitle),\n                    end=\"\",\n                )\n                pageToBeDeleted = self.toWiki.getPage(pageTitle)\n                if not force:\n                    self.log(\"\ud83d\udc4d\" if pageToBeDeleted.exists else \"\ud83d\udc4e\")\n                else:\n                    pageToBeDeleted.delete(\"deleted by wiknuke\")\n                    self.log(\"\u2705\")\n            except Exception as ex:\n                self.show_exception(ex)\n\n    @staticmethod\n    def getDiff(text: str, newText: str, n: int = 1, forHuman: bool = True) -&gt; str:\n        \"\"\"\n        Compare the two given strings and return the differences\n        Args:\n            text: old text to compare the new text to\n            newText: new text\n            n: The number of context lines\n            forHuman: If True update the diff string to be better human-readable\n\n        Returns:\n            str: difference string\n        \"\"\"\n        # if WikiPush.differ is None:\n        #    WikiPush.differ=Differ()\n        # https://docs.python.org/3/library/difflib.html\n        #  difflib.unified_diff(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')\u00b6\n        # diffs=WikiPush.differ.compare(,)\n        textLines = text.split(\"\\n\")\n        newTextLines = newText.split(\"\\n\")\n        diffs = difflib.unified_diff(textLines, newTextLines, n=n)\n        if forHuman:\n            hdiffs = []\n            for line in diffs:\n                unwantedItems = [\"@@\", \"---\", \"+++\"]\n                keep = True\n                for unwanted in unwantedItems:\n                    if unwanted in line:\n                        keep = False\n                if keep:\n                    hdiffs.append(line)\n        else:\n            hdiffs = diffs\n        diffStr = \"\\n\".join(hdiffs)\n        return diffStr\n\n    @staticmethod\n    def getModify(\n        search: str, replace: str, debug: bool = False\n    ) -&gt; typing.Callable[[str], str]:\n        \"\"\"\n        get the modification function\n\n        Args:\n            search(str): the search string\n            replace(str): the replace string\n            debug(bool): if debug show\n\n        Returns:\n            String modify function that takes as input the string, applies the search and replace action\n             and returns the modified string\n        \"\"\"\n        if debug:\n            print(f\"search regex: {search}\")\n            print(f\"replace regex: {replace}\")\n        searchRegex = r\"%s\" % search\n        replaceRegex = r\"%s\" % replace\n        modify = lambda text: re.sub(searchRegex, replaceRegex, text)\n        return modify\n\n    def edit_page_content(\n        self,\n        page_title: str,\n        new_text: str = None,\n        summary=\"edited by wikiedit\",\n        modify: typing.Callable[[str], str] = None,\n        force: bool = False,\n        context: int = 1,\n    ) -&gt; str:\n        \"\"\"\n        Edit the content of a single page.\n\n        Args:\n        page_title (str): The title of the page to be edited\n        new_text (str): the new text for the page\n        summary (str): the summary / comment for the editing\n        modify (Callable[[str], str]): Function to modify the page content\n        force (bool): If True, actually edit the page; if False, perform a dry run\n        context (int): The number of context lines for diff\n\n        Returns:\n        str: Status of the edit operation\n        \"\"\"\n        page_to_edit = self.toWiki.getPage(page_title)\n        if not force and not page_to_edit.exists:\n            return \"\ud83d\udc4e\"\n\n        text = page_to_edit.text()\n        if not new_text:\n            new_text = modify(text)\n\n        if new_text == text:\n            return \"\u2194\"\n\n        if force:\n            page_to_edit.edit(new_text, summary)\n            return \"\u2705\"\n        else:\n            diff_str = self.getDiff(text, new_text, n=context)\n            return f\"\ud83d\udc4d{diff_str}\"\n\n    def edit(\n        self,\n        page_titles: typing.List[str],\n        modify: typing.Callable[[str], str] = None,\n        context: int = 1,\n        force: bool = False,\n    ):\n        \"\"\"\n        Edit the pages with the given page titles\n\n        Args:\n        page_titles (list): a list of page titles to be transferred from the formWiki to the toWiki\n        modify: String modify function that takes as input the string and returns the modified string\n        context: The number of context lines\n        force (bool): True if pages should be actually edited - dry run only listing pages is default\n        \"\"\"\n        if modify is None:\n            raise Exception(\"wikipush edit needs a modify function!\")\n\n        total = len(page_titles)\n        self.log(\n            f\"editing {total} pages in {self.toWikiId} ({'forced' if force else 'dry run'})\"\n        )\n\n        for i, page_title in enumerate(page_titles):\n            try:\n                self.log(\n                    f\"{i + 1}/{total} ({(i + 1) / total * 100:4.0f}%): editing {page_title} ...\",\n                    end=\"\",\n                )\n\n                result = self.edit_page_content(page_title, modify, force, context)\n                self.log(result)\n\n            except Exception as ex:\n                self.show_exception(ex)\n\n    def edit_wikison(\n        self,\n        page_titles: typing.List[str],\n        entity_type_name: str,\n        property_name: str,\n        value: typing.Any,\n        force: bool = False,\n    ):\n        \"\"\"\n        Edit the WikiSON for on the given pages\n        Args:\n            page_titles: a list of page titles to be edited\n            entity_type_name: name of the WikiSON entity type\n            property_name: name of the property to edit\n            value: value to set. If None property is deleted from the WikiSON\n            force: If False only print the changes. Otherwise, apply the changes\n        \"\"\"\n        total = len(page_titles)\n        self.log(\n            f\"\"\"editing {total} pages in {self.toWikiId} ({\"forced\" if force else \"dry run\"})\"\"\"\n        )\n        for i, page_title in enumerate(page_titles, 1):\n            try:\n                self.log(\n                    f\"{i}/{total} ({i/total*100:.2f}%): editing {page_title} ...\",\n                    end=\"\",\n                )\n                page_to_be_edited = self.toWiki.getPage(page_title)\n                if not force and not page_to_be_edited.exists:\n                    self.log(\"\ud83d\udc4e\")\n                else:\n                    comment = \"edited by wikiedit\"\n                    markup = page_to_be_edited.text()\n                    wikison = WikiSON(page_title, markup)\n                    new_markup = wikison.set(\n                        entity_type_name=entity_type_name, record={property_name: value}\n                    )\n                    if new_markup != markup:\n                        if force:\n                            page_to_be_edited.edit(new_markup, comment)\n                            self.log(\"\u2705\")\n                        else:\n                            diff_str = self.getDiff(markup, new_markup, n=3)\n                            self.log(f\"\ud83d\udc4d{diff_str}\")\n                    else:\n                        self.log(\"\u2194\")\n            except Exception as ex:\n                self.show_exception(ex)\n\n    def upload(self, files, force=False):\n        \"\"\"\n        push the given files\n        Args:\n            files(list): a list of filenames to be transfered to the toWiki\n            force(bool): True if images should be overwritten if they exist\n        \"\"\"\n        total = len(files)\n        self.log(\"uploading %d files to %s\" % (total, self.toWikiId))\n        for i, file in enumerate(files):\n            try:\n                self.log(\n                    \"%d/%d (%4.0f%%): uploading %s ...\"\n                    % (i + 1, total, (i + 1) / total * 100, file),\n                    end=\"\",\n                )\n                description = \"uploaded by wikiupload\"\n                filename = os.path.basename(file)\n                self.uploadImage(file, filename, description, force)\n                self.log(\"\u2705\")\n            except Exception as ex:\n                self.show_exception(ex)\n\n    def backup(self, pageTitles, backupPath=None, git=False, withImages=False):\n        \"\"\"\n        backup the given page titles\n        Args:\n            pageTitles(list): a list of page titles to be downloaded from the fromWiki\n            git(bool): True if git should be used as a version control system\n            withImages(bool): True if the image on a page should also be copied\n        \"\"\"\n        if backupPath is None:\n            backupPath = self.getHomePath(\"wikibackup/%s\" % self.fromWikiId)\n        imageBackupPath = \"%s/images\" % backupPath\n        total = len(pageTitles)\n        self.log(\n            \"downloading %d pages from %s to %s\" % (total, self.fromWikiId, backupPath)\n        )\n        for i, pageTitle in enumerate(pageTitles):\n            try:\n                self.log(\n                    \"%d/%d (%4.0f%%): downloading %s ...\"\n                    % (i + 1, total, (i + 1) / total * 100, pageTitle),\n                    end=\"\",\n                )\n                page = self.fromWiki.getPage(pageTitle)\n                wikiFilePath = \"%s/%s.wiki\" % (backupPath, pageTitle)\n                self.ensureParentDirectoryExists(wikiFilePath)\n                with open(wikiFilePath, \"w\") as wikiFile:\n                    wikiFile.write(page.text())\n                self.log(\"\u2705\")\n                if isinstance(page, Image):\n                    self.backupImages([page], imageBackupPath)\n                if withImages:\n                    self.backupImages(page.images(), imageBackupPath)\n\n            except Exception as ex:\n                self.show_exception(ex)\n        if git:\n            gitPath = \"%s/.git\" % backupPath\n            if not os.path.isdir(gitPath):\n                self.log(\"initializing git repository ...\")\n                repo = Repo.init(backupPath)\n            else:\n                repo = Repo(backupPath)\n            self.log(\"committing to git repository\")\n            repo.git.add(all=True)\n            timestamp = datetime.datetime.now().isoformat()\n            repo.index.commit(\"auto commit by wikibackup at %s\" % timestamp)\n\n    def backupImages(self, imageList: list, imageBackupPath: str):\n        \"\"\"\n        backup the images in the givne imageList\n\n        Args:\n            imageList(list): the list of images\n            imageBackupPath(str): the path to the backup directory\n        \"\"\"\n        for image in imageList:\n            try:\n                imagePath, filename = self.downloadImage(image, imageBackupPath)\n            except Exception as ex:\n                self.handleException(ex)\n\n    def work(\n        self,\n        pageTitles: list,\n        activity: str = \"copying\",\n        comment: str = \"pushed\",\n        force: bool = False,\n        ignore: bool = False,\n        withImages: bool = False,\n    ) -&gt; list:\n        \"\"\"\n        work on the given page titles\n\n        Args:\n            pageTitles(list): a list of page titles to be transfered from the formWiki to the toWiki\n            activity(str): the activity to perform\n            comment(str): the comment to display\n            force(bool): True if pages should be overwritten if they exist\n            ignore(bool): True if warning for images should be ignored (e.g if they exist)\n            withImages(bool): True if the image on a page should also be copied\n        Returns:\n            list: a list of pageTitles for which the activity failed\n        \"\"\"\n        failed = []\n        total = len(pageTitles)\n        self.log(f\"{activity} {total} pages from {self.fromWikiId} to {self.toWikiId}\")\n        for i, pageTitle in enumerate(pageTitles):\n            try:\n                percent = (i + 1) / total * 100\n                self.log(\n                    f\"{i+1}/{total} ({percent:4.0f}%): {activity} ... {pageTitle}\",\n                    end=\"\",\n                )\n                page = self.fromWiki.getPage(pageTitle)\n                if page.exists:\n                    # is this an image?\n                    if isinstance(page, Image):\n                        self.pushImages([page], ignore=ignore)\n                    else:\n                        newPage = self.toWiki.getPage(pageTitle)\n                        if not newPage.exists or force:\n                            try:\n                                newPage.edit(page.text(), comment)\n                                self.log(\"\u2705\")\n                                pageOk = True\n                            except Exception as ex:\n                                pageOk = self.handleException(ex, ignore)\n                                if not pageOk:\n                                    failed.append(pageTitle)\n                            if withImages and pageOk:\n                                self.pushImages(page.images(), ignore=ignore)\n                        else:\n                            self.log(\"\ud83d\udc4e\")\n                else:\n                    self.log(\"\u274c\")\n                    failed.append(pageTitle)\n            except Exception as ex:\n                self.show_exception(ex)\n                failed.append(pageTitle)\n        return failed\n\n    def push(self, pageTitles, force=False, ignore=False, withImages=False) -&gt; list:\n        \"\"\"\n        push the given page titles\n\n        Args:\n            pageTitles(list): a list of page titles to be transfered from the formWiki to the toWiki\n            force(bool): True if pages should be overwritten if they exist\n            ignore(bool): True if warning for images should be ignored (e.g if they exist)\n            withImages(bool): True if the image on a page should also be copied\n        Returns:\n            list: a list of pageTitles for which the activity failed\n        \"\"\"\n        comment = f\"pushed from {self.fromWikiId} by wikipush\"\n        return self.work(\n            pageTitles,\n            activity=\"copying\",\n            comment=comment,\n            force=force,\n            ignore=ignore,\n            withImages=withImages,\n        )\n\n    def ensureParentDirectoryExists(self, filePath: str):\n        \"\"\"\n        for pages that have a \"/\" in the name make sure that the parent Directory exists\n\n        Args:\n            filePath(str): the filePath to check\n        \"\"\"\n        directory = os.path.dirname(filePath)\n        self.ensureDirectoryExists(directory)\n\n    def ensureDirectoryExists(self, directory: str):\n        \"\"\"\n        make sure the given directory exists\n\n        Args:\n            directory(str): the directory to check for existence\n        \"\"\"\n        Path(directory).mkdir(parents=True, exist_ok=True)\n\n    def getHomePath(self, localPath):\n        \"\"\"\n        get the given home path\n        \"\"\"\n        homePath = f\"{Path.home()}/{localPath}\"\n        self.ensureDirectoryExists(homePath)\n        return homePath\n\n    def getDownloadPath(self):\n        \"\"\"\n        get the download path\n        \"\"\"\n        return self.getHomePath(\"Downloads/mediawiki\")\n\n    def pushImages(self, imageList, delim=\"\", ignore=False):\n        \"\"\"\n        push the images in the given image List\n\n        Args:\n            imageList(list): a list of images to be pushed\n            ignore(bool): True to upload despite any warnings.\n        \"\"\"\n        for image in imageList:\n            try:\n                self.log(\"%scopying image %s ...\" % (delim, image.name), end=\"\")\n                imagePath, filename = self.downloadImage(image)\n                description = image.imageinfo[\"comment\"]\n                try:\n                    self.uploadImage(imagePath, filename, description, ignore)\n                    self.log(\"\u2705\")\n                except Exception as ex:\n                    self.handleAPIWarnings(ex.args[0], ignoreExists=ignore)\n                    if self.debug:\n                        self.show_exception(ex)\n                if self.debug:\n                    print(image.imageinfo)\n            except Exception as ex:\n                self.handleException(ex, ignore)\n\n    def show_exception(self, ex: Exception):\n        \"\"\"\n        Show the given exception and, if debug mode is on, show the traceback.\n        \"\"\"\n        msg = f\"\u274c: {str(ex)}\"\n        if self.debug:\n            # Append the formatted traceback to the message\n            msg += \"\\n\" + traceback.format_exc()\n\n        self.log(msg)\n\n    def handleException(self, ex, ignoreExists=False):\n        \"\"\"\n        handle the given exception and ignore it if it includes \"exists\" and ignoreExists is True\n\n        Args:\n            ex(Exception): the exception to handle\n            ignoreExists(bool): True if \"exists\" should be ignored\n\n        Returns:\n            bool: True if the exception was handled as ok False if it was logged as an error\n        \"\"\"\n        msg = str(ex)\n        return self.handleWarning(msg, marker=\"\u274c\", ignoreExists=ignoreExists)\n\n    def handleAPIWarnings(self, warnings, ignoreExists=False):\n        \"\"\"\n        handle API Warnings\n\n        Args:\n            warnings(list): a list of API warnings\n            ignoreExists(bool): ignore messages that warn about existing content\n\n        Returns:\n            bool: True if the exception was handled as ok False if it was logged as an error\n        \"\"\"\n        msg = \"\"\n        if warnings:\n            if isinstance(warnings, str):\n                msg = warnings\n            else:\n                for warning in warnings:\n                    msg += \"%s\\n\" % str(warning)\n        return self.handleWarning(msg, ignoreExists=ignoreExists)\n\n    def handleWarning(self, msg, marker=\"\u26a0\ufe0f\", ignoreExists=False):\n        \"\"\"\n        handle the given warning and ignore it if it includes \"exists\" and ignoreExists is True\n\n        Args:\n            msg(string): the warning to handle\n            marker(string): the marker to use for the message\n            ignoreExists(bool): True if \"exists\" should be ignored\n\n        Returns:\n            bool: True if the exception was handled as ok False if it was logged as an error\n        \"\"\"\n        # print (\"handling warning %s with ignoreExists=%r\" % (msg,ignoreExists))\n        if ignoreExists and \"exists\" in msg:\n            # shorten exact duplicate message\n            if \"exact duplicate\" in msg:\n                msg = \"exact duplicate\"\n            marker = \"\ud83d\udc40\"\n        if not ignoreExists and \"exists\" in msg:\n            msg = (\n                \"file exists (to overwrite existing files enable the ignore parameter)\"\n            )\n        self.log(\"%s:%s\" % (marker, msg))\n        return marker == \"\ud83d\udc40\"\n\n    def downloadImage(self, image, downloadPath=None):\n        \"\"\"\n        download the given image\n\n        Args:\n            image(image): the image to download\n            downloadPath(str): the path to download to if None getDownloadPath will be used\n        \"\"\"\n        original_filename = image.name\n        prefixes = [\"File\", \"Datei\", \"Fichier\", \"Archivo\", \"\u0424\u0430\u0439\u043b\", \"\u200b\u6587\u4ef6\u200b\", \"\u30d5\u30a1\u30a4\u30eb\"]\n        for prefix in prefixes:\n            if original_filename.startswith(f\"{prefix}:\"):\n                filename = original_filename.replace(f\"{prefix}:\", \"\")\n                break\n        else:\n            filename = original_filename  # Fallback in case no prefix matches\n\n        if downloadPath is None:\n            downloadPath = self.getDownloadPath()\n        imagePath = \"%s/%s\" % (downloadPath, filename)\n        self.ensureParentDirectoryExists(imagePath)\n        with open(imagePath, \"wb\") as imageFile:\n            image.download(imageFile)\n        return imagePath, filename\n\n    def uploadImage(self, imagePath, filename, description, ignoreExists=False):\n        \"\"\"\n        upload an image\n\n        Args:\n            imagePath(str): the path to the image\n            filename(str): the filename to use\n            description(str): the description to use\n            ignoreExists(bool): True if it should be ignored if the image exists\n        \"\"\"\n        with open(imagePath, \"rb\") as imageFile:\n            warnings = None\n            response = self.toWiki.site.upload(\n                imageFile, filename, description, ignoreExists\n            )\n            if \"warnings\" in response:\n                warnings = response[\"warnings\"]\n            if \"upload\" in response and \"warnings\" in response[\"upload\"]:\n                warningsDict = response[\"upload\"][\"warnings\"]\n                warnings = []\n                for item in warningsDict.items():\n                    warnings.append(str(item))\n            if warnings:\n                raise Exception(warnings)\n\n    def restore(self, pageTitles=None, backupPath=None, listFile=None, stdIn=False):\n        \"\"\"\n        restore given page titles from local backup\n        If no page titles are given the whole backup is restored.\n\n        Args:\n            pageTitles(list): a list of pageTitles to be restored to toWiki. If None -&gt; full restore of backup\n            backupPath(str): path to backup location\n            listFile:\n            stdIn:\n        \"\"\"\n        if stdIn:\n            backupPath = os.path.dirname(pageTitles[0].strip())\n            pageTitlesfix = []\n            for i in pageTitles:\n                pageTitlesfix.append(os.path.basename(i.strip().replace(\".wiki\", \"\")))\n            pageTitles = pageTitlesfix\n        elif listFile is not None:\n            f = open(listFile, \"r\")\n            allx = f.readlines()\n            pageTitles = []\n            for i in allx:\n                pageTitles.append(os.path.basename(i.strip()).replace(\".wiki\", \"\"))\n        else:\n            if backupPath is None:\n                backupPath = self.getHomePath(f\"wikibackup/{self.toWikiId}\")\n            if pageTitles is None:\n                pageTitles = []\n                for path, subdirs, files in os.walk(backupPath):\n                    for name in files:\n                        filename = os.path.join(path, name)[len(backupPath) + 1 :]\n                        if filename.endswith(\".wiki\"):\n                            pageTitles.append(filename[: -len(\".wiki\")])\n        total = len(pageTitles)\n        self.log(\n            \"restoring %d pages from %s to %s\" % (total, backupPath, self.toWikiId)\n        )\n        for i, pageTitle in enumerate(pageTitles):\n            try:\n                self.log(\n                    \"%d/%d (%4.0f%%): restore %s ...\"\n                    % (i + 1, total, (i + 1) / total * 100, pageTitle),\n                    end=\"\",\n                )\n                wikiFilePath = f\"{backupPath}/{pageTitle}.wiki\"\n                with open(wikiFilePath, mode=\"r\") as wikiFile:\n                    page_content = wikiFile.read()\n                    page = self.toWiki.getPage(pageTitle)\n                    page.edit(\n                        page_content,\n                        f\"modified through wikirestore by {self.toWiki.wikiUser.user}\",\n                    )\n                self.log(\"\u2705\")\n            except Exception as ex:\n                self.show_exception(ex)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.__init__","title":"<code>__init__(fromWikiId, toWikiId=None, login=False, verbose=True, debug=False)</code>","text":"<p>Constructor</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>fromWikiId(str)</code>\n            \n            \n            \n              \n                <p>the id of the wiki to push from (source)</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>toWikiID(str)</code>\n            \n            \n            \n              \n                <p>the id of the wiki to push to (target)</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>login(bool)</code>\n            \n            \n            \n              \n                <p>if True login to source wiki</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>verbose(bool)</code>\n            \n            \n            \n              \n                <p>if True print info messages</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>debug(bool)</code>\n            \n            \n            \n              \n                <p>if True show debugging messages</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def __init__(\n    self,\n    fromWikiId: str,\n    toWikiId: str = None,\n    login: bool = False,\n    verbose: bool = True,\n    debug: bool = False,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        fromWikiId(str): the id of the wiki to push from (source)\n        toWikiID(str): the id of the wiki to push to (target)\n        login(bool): if True login to source wiki\n        verbose(bool): if True print info messages\n        debug(bool): if True show debugging messages\n    \"\"\"\n    self.verbose = verbose\n    self.debug = debug\n    self.args = Namespace()\n    self.args.template = None\n    self.fromWiki = None\n    self.toWiki = None\n\n    self.fromWikiId = fromWikiId\n    if self.fromWikiId is not None:\n        self.fromWiki = WikiClient.ofWikiId(fromWikiId, debug=self.debug)\n    self.toWikiId = toWikiId\n    if self.toWikiId is not None:\n        self.toWiki = WikiClient.ofWikiId(toWikiId, debug=self.debug)\n    if login and self.fromWikiId is not None:\n        if not self.fromWiki.login():\n            msg = f\"can't login to source Wiki {fromWikiId}\"\n            ex = Exception(msg)\n            self.show_exception(ex)\n            raise (ex)\n    if self.toWiki is not None:\n        if not self.toWiki.login():\n            msg = f\"can't login to target Wiki {toWikiId}\"\n            ex = Exception(msg)\n            self.show_exception(ex)\n            raise (ex)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.backup","title":"<code>backup(pageTitles, backupPath=None, git=False, withImages=False)</code>","text":"<p>backup the given page titles\nArgs:\n    pageTitles(list): a list of page titles to be downloaded from the fromWiki\n    git(bool): True if git should be used as a version control system\n    withImages(bool): True if the image on a page should also be copied</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def backup(self, pageTitles, backupPath=None, git=False, withImages=False):\n    \"\"\"\n    backup the given page titles\n    Args:\n        pageTitles(list): a list of page titles to be downloaded from the fromWiki\n        git(bool): True if git should be used as a version control system\n        withImages(bool): True if the image on a page should also be copied\n    \"\"\"\n    if backupPath is None:\n        backupPath = self.getHomePath(\"wikibackup/%s\" % self.fromWikiId)\n    imageBackupPath = \"%s/images\" % backupPath\n    total = len(pageTitles)\n    self.log(\n        \"downloading %d pages from %s to %s\" % (total, self.fromWikiId, backupPath)\n    )\n    for i, pageTitle in enumerate(pageTitles):\n        try:\n            self.log(\n                \"%d/%d (%4.0f%%): downloading %s ...\"\n                % (i + 1, total, (i + 1) / total * 100, pageTitle),\n                end=\"\",\n            )\n            page = self.fromWiki.getPage(pageTitle)\n            wikiFilePath = \"%s/%s.wiki\" % (backupPath, pageTitle)\n            self.ensureParentDirectoryExists(wikiFilePath)\n            with open(wikiFilePath, \"w\") as wikiFile:\n                wikiFile.write(page.text())\n            self.log(\"\u2705\")\n            if isinstance(page, Image):\n                self.backupImages([page], imageBackupPath)\n            if withImages:\n                self.backupImages(page.images(), imageBackupPath)\n\n        except Exception as ex:\n            self.show_exception(ex)\n    if git:\n        gitPath = \"%s/.git\" % backupPath\n        if not os.path.isdir(gitPath):\n            self.log(\"initializing git repository ...\")\n            repo = Repo.init(backupPath)\n        else:\n            repo = Repo(backupPath)\n        self.log(\"committing to git repository\")\n        repo.git.add(all=True)\n        timestamp = datetime.datetime.now().isoformat()\n        repo.index.commit(\"auto commit by wikibackup at %s\" % timestamp)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.backupImages","title":"<code>backupImages(imageList, imageBackupPath)</code>","text":"<p>backup the images in the givne imageList</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>imageList(list)</code>\n            \n            \n            \n              \n                <p>the list of images</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>imageBackupPath(str)</code>\n            \n            \n            \n              \n                <p>the path to the backup directory</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def backupImages(self, imageList: list, imageBackupPath: str):\n    \"\"\"\n    backup the images in the givne imageList\n\n    Args:\n        imageList(list): the list of images\n        imageBackupPath(str): the path to the backup directory\n    \"\"\"\n    for image in imageList:\n        try:\n            imagePath, filename = self.downloadImage(image, imageBackupPath)\n        except Exception as ex:\n            self.handleException(ex)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.convertToCSV","title":"<code>convertToCSV(pageRecords, separator=';')</code>","text":"<p>Converts the given pageRecords into a str in csv format\nToDO: Currently does not support escaping of the separator and escaping of quotes\nArgs:\n    pageRecords: dict of dicts containing the printouts\n    separator(char):\nReturns: str</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def convertToCSV(self, pageRecords, separator=\";\"):\n    \"\"\"\n    Converts the given pageRecords into a str in csv format\n    ToDO: Currently does not support escaping of the separator and escaping of quotes\n    Args:\n        pageRecords: dict of dicts containing the printouts\n        separator(char):\n    Returns: str\n    \"\"\"\n    res = \"\"\n    printedHeaders = False\n    for pageRecord in pageRecords.values():\n        if not printedHeaders:\n            for key in pageRecord.keys():\n                res = f\"{res}{key}{separator}\"\n            res = f\"{res[:-1]}\\n\"\n            printedHeaders = True\n        for printouts in pageRecord.values():\n            res = f\"{res}{printouts}{separator}\"\n        res = f\"{res[:-1]}\\n\"  # remove last separator and end line\n    return res\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.downloadImage","title":"<code>downloadImage(image, downloadPath=None)</code>","text":"<p>download the given image</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>image(image)</code>\n            \n            \n            \n              \n                <p>the image to download</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>downloadPath(str)</code>\n            \n            \n            \n              \n                <p>the path to download to if None getDownloadPath will be used</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def downloadImage(self, image, downloadPath=None):\n    \"\"\"\n    download the given image\n\n    Args:\n        image(image): the image to download\n        downloadPath(str): the path to download to if None getDownloadPath will be used\n    \"\"\"\n    original_filename = image.name\n    prefixes = [\"File\", \"Datei\", \"Fichier\", \"Archivo\", \"\u0424\u0430\u0439\u043b\", \"\u200b\u6587\u4ef6\u200b\", \"\u30d5\u30a1\u30a4\u30eb\"]\n    for prefix in prefixes:\n        if original_filename.startswith(f\"{prefix}:\"):\n            filename = original_filename.replace(f\"{prefix}:\", \"\")\n            break\n    else:\n        filename = original_filename  # Fallback in case no prefix matches\n\n    if downloadPath is None:\n        downloadPath = self.getDownloadPath()\n    imagePath = \"%s/%s\" % (downloadPath, filename)\n    self.ensureParentDirectoryExists(imagePath)\n    with open(imagePath, \"wb\") as imageFile:\n        image.download(imageFile)\n    return imagePath, filename\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.edit","title":"<code>edit(page_titles, modify=None, context=1, force=False)</code>","text":"<p>Edit the pages with the given page titles</p>\n<p>Args:\npage_titles (list): a list of page titles to be transferred from the formWiki to the toWiki\nmodify: String modify function that takes as input the string and returns the modified string\ncontext: The number of context lines\nforce (bool): True if pages should be actually edited - dry run only listing pages is default</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def edit(\n    self,\n    page_titles: typing.List[str],\n    modify: typing.Callable[[str], str] = None,\n    context: int = 1,\n    force: bool = False,\n):\n    \"\"\"\n    Edit the pages with the given page titles\n\n    Args:\n    page_titles (list): a list of page titles to be transferred from the formWiki to the toWiki\n    modify: String modify function that takes as input the string and returns the modified string\n    context: The number of context lines\n    force (bool): True if pages should be actually edited - dry run only listing pages is default\n    \"\"\"\n    if modify is None:\n        raise Exception(\"wikipush edit needs a modify function!\")\n\n    total = len(page_titles)\n    self.log(\n        f\"editing {total} pages in {self.toWikiId} ({'forced' if force else 'dry run'})\"\n    )\n\n    for i, page_title in enumerate(page_titles):\n        try:\n            self.log(\n                f\"{i + 1}/{total} ({(i + 1) / total * 100:4.0f}%): editing {page_title} ...\",\n                end=\"\",\n            )\n\n            result = self.edit_page_content(page_title, modify, force, context)\n            self.log(result)\n\n        except Exception as ex:\n            self.show_exception(ex)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.edit_page_content","title":"<code>edit_page_content(page_title, new_text=None, summary='edited by wikiedit', modify=None, force=False, context=1)</code>","text":"<p>Edit the content of a single page.</p>\n<p>Args:\npage_title (str): The title of the page to be edited\nnew_text (str): the new text for the page\nsummary (str): the summary / comment for the editing\nmodify (Callable[[str], str]): Function to modify the page content\nforce (bool): If True, actually edit the page; if False, perform a dry run\ncontext (int): The number of context lines for diff</p>\n<p>Returns:\nstr: Status of the edit operation</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def edit_page_content(\n    self,\n    page_title: str,\n    new_text: str = None,\n    summary=\"edited by wikiedit\",\n    modify: typing.Callable[[str], str] = None,\n    force: bool = False,\n    context: int = 1,\n) -&gt; str:\n    \"\"\"\n    Edit the content of a single page.\n\n    Args:\n    page_title (str): The title of the page to be edited\n    new_text (str): the new text for the page\n    summary (str): the summary / comment for the editing\n    modify (Callable[[str], str]): Function to modify the page content\n    force (bool): If True, actually edit the page; if False, perform a dry run\n    context (int): The number of context lines for diff\n\n    Returns:\n    str: Status of the edit operation\n    \"\"\"\n    page_to_edit = self.toWiki.getPage(page_title)\n    if not force and not page_to_edit.exists:\n        return \"\ud83d\udc4e\"\n\n    text = page_to_edit.text()\n    if not new_text:\n        new_text = modify(text)\n\n    if new_text == text:\n        return \"\u2194\"\n\n    if force:\n        page_to_edit.edit(new_text, summary)\n        return \"\u2705\"\n    else:\n        diff_str = self.getDiff(text, new_text, n=context)\n        return f\"\ud83d\udc4d{diff_str}\"\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.edit_wikison","title":"<code>edit_wikison(page_titles, entity_type_name, property_name, value, force=False)</code>","text":"<p>Edit the WikiSON for on the given pages\nArgs:\n    page_titles: a list of page titles to be edited\n    entity_type_name: name of the WikiSON entity type\n    property_name: name of the property to edit\n    value: value to set. If None property is deleted from the WikiSON\n    force: If False only print the changes. Otherwise, apply the changes</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def edit_wikison(\n    self,\n    page_titles: typing.List[str],\n    entity_type_name: str,\n    property_name: str,\n    value: typing.Any,\n    force: bool = False,\n):\n    \"\"\"\n    Edit the WikiSON for on the given pages\n    Args:\n        page_titles: a list of page titles to be edited\n        entity_type_name: name of the WikiSON entity type\n        property_name: name of the property to edit\n        value: value to set. If None property is deleted from the WikiSON\n        force: If False only print the changes. Otherwise, apply the changes\n    \"\"\"\n    total = len(page_titles)\n    self.log(\n        f\"\"\"editing {total} pages in {self.toWikiId} ({\"forced\" if force else \"dry run\"})\"\"\"\n    )\n    for i, page_title in enumerate(page_titles, 1):\n        try:\n            self.log(\n                f\"{i}/{total} ({i/total*100:.2f}%): editing {page_title} ...\",\n                end=\"\",\n            )\n            page_to_be_edited = self.toWiki.getPage(page_title)\n            if not force and not page_to_be_edited.exists:\n                self.log(\"\ud83d\udc4e\")\n            else:\n                comment = \"edited by wikiedit\"\n                markup = page_to_be_edited.text()\n                wikison = WikiSON(page_title, markup)\n                new_markup = wikison.set(\n                    entity_type_name=entity_type_name, record={property_name: value}\n                )\n                if new_markup != markup:\n                    if force:\n                        page_to_be_edited.edit(new_markup, comment)\n                        self.log(\"\u2705\")\n                    else:\n                        diff_str = self.getDiff(markup, new_markup, n=3)\n                        self.log(f\"\ud83d\udc4d{diff_str}\")\n                else:\n                    self.log(\"\u2194\")\n        except Exception as ex:\n            self.show_exception(ex)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.ensureDirectoryExists","title":"<code>ensureDirectoryExists(directory)</code>","text":"<p>make sure the given directory exists</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>directory(str)</code>\n            \n            \n            \n              \n                <p>the directory to check for existence</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def ensureDirectoryExists(self, directory: str):\n    \"\"\"\n    make sure the given directory exists\n\n    Args:\n        directory(str): the directory to check for existence\n    \"\"\"\n    Path(directory).mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.ensureParentDirectoryExists","title":"<code>ensureParentDirectoryExists(filePath)</code>","text":"<p>for pages that have a \"/\" in the name make sure that the parent Directory exists</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>filePath(str)</code>\n            \n            \n            \n              \n                <p>the filePath to check</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def ensureParentDirectoryExists(self, filePath: str):\n    \"\"\"\n    for pages that have a \"/\" in the name make sure that the parent Directory exists\n\n    Args:\n        filePath(str): the filePath to check\n    \"\"\"\n    directory = os.path.dirname(filePath)\n    self.ensureDirectoryExists(directory)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.extract_category_and_mainlabel","title":"<code>extract_category_and_mainlabel(askQuery, category_labels=['Category', 'Kategorie', 'Cat\u00e9gorie', 'Categor\u00eda'])</code>","text":"<p>Extracts the category pattern and mainlabel from a MediaWiki query, supporting multiple language labels.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>askQuery</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>The query string to be processed.</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>category_labels</code>\n            \n                  <code>List[str]</code>\n            \n            \n              \n                <p>A list of category labels in different languages\n                                   (default: ['Category', 'Kategorie', 'Cat\u00e9gorie', 'Categor\u00eda']).</p>\n              \n            \n            \n                  <code>['Category', 'Kategorie', 'Cat\u00e9gorie', 'Categor\u00eda']</code>\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>Optional[Tuple[str, Optional[str]]]</code>\n            \n            \n              \n                <p>Optional[Tuple[str, Optional[str]]]: A tuple containing the category pattern and</p>\n              \n            \n          \n          \n            \n                  <code>Optional[Tuple[str, Optional[str]]]</code>\n            \n            \n              \n                <p>the mainlabel if present. Returns None if the query does not match a category pattern.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def extract_category_and_mainlabel(\n    self,\n    askQuery: str,\n    category_labels: List[str] = [\n        \"Category\",\n        \"Kategorie\",\n        \"Cat\u00e9gorie\",\n        \"Categor\u00eda\",\n    ],\n) -&gt; Optional[Tuple[str, Optional[str]]]:\n    \"\"\"\n    Extracts the category pattern and mainlabel from a MediaWiki query, supporting multiple language labels.\n\n    Args:\n        askQuery (str): The query string to be processed.\n        category_labels (List[str], optional): A list of category labels in different languages\n                                               (default: ['Category', 'Kategorie', 'Cat\u00e9gorie', 'Categor\u00eda']).\n\n    Returns:\n        Optional[Tuple[str, Optional[str]]]: A tuple containing the category pattern and\n        the mainlabel if present. Returns None if the query does not match a category pattern.\n    \"\"\"\n    # Join the list of category labels into a regex pattern\n    labels_pattern = \"|\".join(re.escape(label) for label in category_labels)\n\n    # Regex to match category queries in specified languages and optionally a mainlabel\n    pattern = rf\"\\[\\[\\s*(?:{labels_pattern})\\s*:\\s*([^\\]]+)\\s*\\]\\](?:\\s*\\|\\s*mainlabel\\s*=\\s*([^\\|]+))?\"\n    match = re.match(pattern, askQuery.strip())\n\n    if match:\n        category = match.group(1).strip()  # Extract the category pattern\n        mainlabel = (\n            match.group(2).strip() if match.group(2) else None\n        )  # Extract the mainlabel if present\n        return category, mainlabel\n\n    return None\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.extract_template_records","title":"<code>extract_template_records(pageRecords, template)</code>","text":"<p>Extract template records from the given pageRecords using batch page retrieval.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>pageRecords</code>\n            \n                  <code>dict</code>\n            \n            \n              \n                <p>Dictionary with page titles as keys</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>template</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>Name of the template to extract (e.g., \"Infobox officeholder\")</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>list</code>\n            \n            \n              \n                <p>list[dict]: List of template records, where each record is a dictionary\n       containing the template parameters. Returns None for pages\n       where the template is not found.</p>\n              \n            \n          \n      \n    \n\n\n\n  Example\n  \n\n\n<p>pageRecords = {\"John Adams\": {}, \"Thomas Jefferson\": {}}\nrecords = extract_template_records(pageRecords, \"Infobox officeholder\")</p>\n\n\n\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def extract_template_records(self, pageRecords, template: str) -&gt; list:\n    \"\"\"\n    Extract template records from the given pageRecords using batch page retrieval.\n\n    Args:\n        pageRecords (dict): Dictionary with page titles as keys\n        template (str): Name of the template to extract (e.g., \"Infobox officeholder\")\n\n    Returns:\n        list[dict]: List of template records, where each record is a dictionary\n                   containing the template parameters. Returns None for pages\n                   where the template is not found.\n\n    Example:\n        &gt;&gt;&gt; pageRecords = {\"John Adams\": {}, \"Thomas Jefferson\": {}}\n        &gt;&gt;&gt; records = extract_template_records(pageRecords, \"Infobox officeholder\")\n    \"\"\"\n    dod = {}\n    page_titles = list(pageRecords.keys())\n    # Get multiple pages at once\n    site = self.fromWiki.get_site()\n    # Process each page\n    for page_title in page_titles:\n        try:\n            page = site.pages[page_title]\n            markup = page.text()\n            wiki_markup = WikiMarkup(page.name, markup)\n            records = wiki_markup.extract_template(template)\n            for i, record in enumerate(records):\n                if record is not None:\n                    key = f\"{page_title}/{i}\" if i &gt; 0 else page_title\n                    dod[key] = record\n        except Exception as ex:\n            print(f\"\u274c {page_title}: {str(ex)}\", file=sys.stderr)\n            pass\n    return dod\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.formatQueryResult","title":"<code>formatQueryResult(askQuery, wiki=None, limit=None, showProgress=False, queryDivision=1, outputFormat='lod', entityName='data', title=None)</code>","text":"<p>format the query result for the given askQuery.\nArgs:\n    askQuery(string): Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries\n    wiki(wikibot3rd): the wiki to query - use fromWiki if not specified\n    limit(int): the limit for the query (optional)\n    showProgress(bool): true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)\n    queryDivision(int): Defines the number of subintervals the query is divided into (must be greater equal 1)\n    outputFormat(str): output format of the query results - default format is lod\n    entityName(str): the name of the entity\n    title(str): the title of the query (if any)\nReturns:\n    Query results in the requested outputFormat as string.\n    If the requested outputFormat is not supported None is returned.</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def formatQueryResult(\n    self,\n    askQuery,\n    wiki=None,\n    limit=None,\n    showProgress=False,\n    queryDivision=1,\n    outputFormat=\"lod\",\n    entityName=\"data\",\n    title: str = None,\n):\n    \"\"\"\n    format the query result for the given askQuery.\n    Args:\n        askQuery(string): Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries\n        wiki(wikibot3rd): the wiki to query - use fromWiki if not specified\n        limit(int): the limit for the query (optional)\n        showProgress(bool): true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)\n        queryDivision(int): Defines the number of subintervals the query is divided into (must be greater equal 1)\n        outputFormat(str): output format of the query results - default format is lod\n        entityName(str): the name of the entity\n        title(str): the title of the query (if any)\n    Returns:\n        Query results in the requested outputFormat as string.\n        If the requested outputFormat is not supported None is returned.\n    \"\"\"\n    pageRecords = self.queryPages(\n        askQuery, wiki, limit, showProgress, queryDivision\n    )\n    if self.args.template:\n        pageRecords = self.extract_template_records(\n            pageRecords, template=self.args.template\n        )\n        pass\n    outputFormat = outputFormat.lower()\n    if outputFormat == \"csv\":\n        return self.convertToCSV(pageRecords)\n    elif outputFormat == \"json\":\n        res = []\n        for page in pageRecords.values():\n            res.append(page)\n        res_json = json.dumps({entityName: res}, default=str, indent=3)\n        return res_json\n    elif outputFormat == \"lod\":\n        return [pageRecord for pageRecord in pageRecords.values()]\n    else:\n        if title is None:\n            title = entityName\n        query = Query(name=entityName, query=askQuery, title=title)\n        qlod = [pageRecord for pageRecord in pageRecords.values()]\n        doc = query.documentQueryResult(\n            qlod, limit, tablefmt=outputFormat, withSourceCode=False\n        )\n        return doc\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.getDiff","title":"<code>getDiff(text, newText, n=1, forHuman=True)</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Compare the two given strings and return the differences\nArgs:\n    text: old text to compare the new text to\n    newText: new text\n    n: The number of context lines\n    forHuman: If True update the diff string to be better human-readable</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n                  <code>str</code>\n            \n            \n              \n                <p>difference string</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>@staticmethod\ndef getDiff(text: str, newText: str, n: int = 1, forHuman: bool = True) -&gt; str:\n    \"\"\"\n    Compare the two given strings and return the differences\n    Args:\n        text: old text to compare the new text to\n        newText: new text\n        n: The number of context lines\n        forHuman: If True update the diff string to be better human-readable\n\n    Returns:\n        str: difference string\n    \"\"\"\n    # if WikiPush.differ is None:\n    #    WikiPush.differ=Differ()\n    # https://docs.python.org/3/library/difflib.html\n    #  difflib.unified_diff(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')\u00b6\n    # diffs=WikiPush.differ.compare(,)\n    textLines = text.split(\"\\n\")\n    newTextLines = newText.split(\"\\n\")\n    diffs = difflib.unified_diff(textLines, newTextLines, n=n)\n    if forHuman:\n        hdiffs = []\n        for line in diffs:\n            unwantedItems = [\"@@\", \"---\", \"+++\"]\n            keep = True\n            for unwanted in unwantedItems:\n                if unwanted in line:\n                    keep = False\n            if keep:\n                hdiffs.append(line)\n    else:\n        hdiffs = diffs\n    diffStr = \"\\n\".join(hdiffs)\n    return diffStr\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.getDownloadPath","title":"<code>getDownloadPath()</code>","text":"<p>get the download path</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def getDownloadPath(self):\n    \"\"\"\n    get the download path\n    \"\"\"\n    return self.getHomePath(\"Downloads/mediawiki\")\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.getHomePath","title":"<code>getHomePath(localPath)</code>","text":"<p>get the given home path</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def getHomePath(self, localPath):\n    \"\"\"\n    get the given home path\n    \"\"\"\n    homePath = f\"{Path.home()}/{localPath}\"\n    self.ensureDirectoryExists(homePath)\n    return homePath\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.getModify","title":"<code>getModify(search, replace, debug=False)</code>\n\n  \n      <code>staticmethod</code>","text":"<p>get the modification function</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>search(str)</code>\n            \n            \n            \n              \n                <p>the search string</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>replace(str)</code>\n            \n            \n            \n              \n                <p>the replace string</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>debug(bool)</code>\n            \n            \n            \n              \n                <p>if debug show</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>Callable[[str], str]</code>\n            \n            \n              \n                <p>String modify function that takes as input the string, applies the search and replace action\nand returns the modified string</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>@staticmethod\ndef getModify(\n    search: str, replace: str, debug: bool = False\n) -&gt; typing.Callable[[str], str]:\n    \"\"\"\n    get the modification function\n\n    Args:\n        search(str): the search string\n        replace(str): the replace string\n        debug(bool): if debug show\n\n    Returns:\n        String modify function that takes as input the string, applies the search and replace action\n         and returns the modified string\n    \"\"\"\n    if debug:\n        print(f\"search regex: {search}\")\n        print(f\"replace regex: {replace}\")\n    searchRegex = r\"%s\" % search\n    replaceRegex = r\"%s\" % replace\n    modify = lambda text: re.sub(searchRegex, replaceRegex, text)\n    return modify\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.handleAPIWarnings","title":"<code>handleAPIWarnings(warnings, ignoreExists=False)</code>","text":"<p>handle API Warnings</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>warnings(list)</code>\n            \n            \n            \n              \n                <p>a list of API warnings</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>ignoreExists(bool)</code>\n            \n            \n            \n              \n                <p>ignore messages that warn about existing content</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>bool</code>            \n            \n            \n              \n                <p>True if the exception was handled as ok False if it was logged as an error</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def handleAPIWarnings(self, warnings, ignoreExists=False):\n    \"\"\"\n    handle API Warnings\n\n    Args:\n        warnings(list): a list of API warnings\n        ignoreExists(bool): ignore messages that warn about existing content\n\n    Returns:\n        bool: True if the exception was handled as ok False if it was logged as an error\n    \"\"\"\n    msg = \"\"\n    if warnings:\n        if isinstance(warnings, str):\n            msg = warnings\n        else:\n            for warning in warnings:\n                msg += \"%s\\n\" % str(warning)\n    return self.handleWarning(msg, ignoreExists=ignoreExists)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.handleException","title":"<code>handleException(ex, ignoreExists=False)</code>","text":"<p>handle the given exception and ignore it if it includes \"exists\" and ignoreExists is True</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>ex(Exception)</code>\n            \n            \n            \n              \n                <p>the exception to handle</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>ignoreExists(bool)</code>\n            \n            \n            \n              \n                <p>True if \"exists\" should be ignored</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>bool</code>            \n            \n            \n              \n                <p>True if the exception was handled as ok False if it was logged as an error</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def handleException(self, ex, ignoreExists=False):\n    \"\"\"\n    handle the given exception and ignore it if it includes \"exists\" and ignoreExists is True\n\n    Args:\n        ex(Exception): the exception to handle\n        ignoreExists(bool): True if \"exists\" should be ignored\n\n    Returns:\n        bool: True if the exception was handled as ok False if it was logged as an error\n    \"\"\"\n    msg = str(ex)\n    return self.handleWarning(msg, marker=\"\u274c\", ignoreExists=ignoreExists)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.handleWarning","title":"<code>handleWarning(msg, marker='\u26a0\ufe0f', ignoreExists=False)</code>","text":"<p>handle the given warning and ignore it if it includes \"exists\" and ignoreExists is True</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>msg(string)</code>\n            \n            \n            \n              \n                <p>the warning to handle</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>marker(string)</code>\n            \n            \n            \n              \n                <p>the marker to use for the message</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>ignoreExists(bool)</code>\n            \n            \n            \n              \n                <p>True if \"exists\" should be ignored</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>bool</code>            \n            \n            \n              \n                <p>True if the exception was handled as ok False if it was logged as an error</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def handleWarning(self, msg, marker=\"\u26a0\ufe0f\", ignoreExists=False):\n    \"\"\"\n    handle the given warning and ignore it if it includes \"exists\" and ignoreExists is True\n\n    Args:\n        msg(string): the warning to handle\n        marker(string): the marker to use for the message\n        ignoreExists(bool): True if \"exists\" should be ignored\n\n    Returns:\n        bool: True if the exception was handled as ok False if it was logged as an error\n    \"\"\"\n    # print (\"handling warning %s with ignoreExists=%r\" % (msg,ignoreExists))\n    if ignoreExists and \"exists\" in msg:\n        # shorten exact duplicate message\n        if \"exact duplicate\" in msg:\n            msg = \"exact duplicate\"\n        marker = \"\ud83d\udc40\"\n    if not ignoreExists and \"exists\" in msg:\n        msg = (\n            \"file exists (to overwrite existing files enable the ignore parameter)\"\n        )\n    self.log(\"%s:%s\" % (marker, msg))\n    return marker == \"\ud83d\udc40\"\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.log","title":"<code>log(msg, end='\\n')</code>","text":"<p>show the given message if verbose is on</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>msg(str)</code>\n            \n            \n            \n              \n                <p>the message to display</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def log(self, msg: str, end=\"\\n\"):\n    \"\"\"\n    show the given message if verbose is on\n\n    Args:\n        msg(str): the message to display\n    \"\"\"\n    if self.verbose:\n        print(msg, end=end)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.nuke","title":"<code>nuke(pageTitles, force=False)</code>","text":"<p>delete the pages with the given page Titles</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>pageTitles(list)</code>\n            \n            \n            \n              \n                <p>a list of page titles to be transfered from the formWiki to the toWiki</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>force(bool)</code>\n            \n            \n            \n              \n                <p>True if pages should be actually deleted - dry run only listing pages is default</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def nuke(self, pageTitles, force=False):\n    \"\"\"\n    delete the pages with the given page Titles\n\n    Args:\n        pageTitles(list): a list of page titles to be transfered from the formWiki to the toWiki\n        force(bool): True if pages should be actually deleted - dry run only listing pages is default\n    \"\"\"\n    total = len(pageTitles)\n    self.log(\n        \"deleting %d pages in %s (%s)\"\n        % (total, self.toWikiId, \"forced\" if force else \"dry run\")\n    )\n    for i, pageTitle in enumerate(pageTitles):\n        try:\n            self.log(\n                \"%d/%d (%4.0f%%): deleting %s ...\"\n                % (i + 1, total, (i + 1) / total * 100, pageTitle),\n                end=\"\",\n            )\n            pageToBeDeleted = self.toWiki.getPage(pageTitle)\n            if not force:\n                self.log(\"\ud83d\udc4d\" if pageToBeDeleted.exists else \"\ud83d\udc4e\")\n            else:\n                pageToBeDeleted.delete(\"deleted by wiknuke\")\n                self.log(\"\u2705\")\n        except Exception as ex:\n            self.show_exception(ex)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.push","title":"<code>push(pageTitles, force=False, ignore=False, withImages=False)</code>","text":"<p>push the given page titles</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>pageTitles(list)</code>\n            \n            \n            \n              \n                <p>a list of page titles to be transfered from the formWiki to the toWiki</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>force(bool)</code>\n            \n            \n            \n              \n                <p>True if pages should be overwritten if they exist</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>ignore(bool)</code>\n            \n            \n            \n              \n                <p>True if warning for images should be ignored (e.g if they exist)</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>withImages(bool)</code>\n            \n            \n            \n              \n                <p>True if the image on a page should also be copied</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n      <p>Returns:\n    list: a list of pageTitles for which the activity failed</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def push(self, pageTitles, force=False, ignore=False, withImages=False) -&gt; list:\n    \"\"\"\n    push the given page titles\n\n    Args:\n        pageTitles(list): a list of page titles to be transfered from the formWiki to the toWiki\n        force(bool): True if pages should be overwritten if they exist\n        ignore(bool): True if warning for images should be ignored (e.g if they exist)\n        withImages(bool): True if the image on a page should also be copied\n    Returns:\n        list: a list of pageTitles for which the activity failed\n    \"\"\"\n    comment = f\"pushed from {self.fromWikiId} by wikipush\"\n    return self.work(\n        pageTitles,\n        activity=\"copying\",\n        comment=comment,\n        force=force,\n        ignore=ignore,\n        withImages=withImages,\n    )\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.pushImages","title":"<code>pushImages(imageList, delim='', ignore=False)</code>","text":"<p>push the images in the given image List</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>imageList(list)</code>\n            \n            \n            \n              \n                <p>a list of images to be pushed</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>ignore(bool)</code>\n            \n            \n            \n              \n                <p>True to upload despite any warnings.</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def pushImages(self, imageList, delim=\"\", ignore=False):\n    \"\"\"\n    push the images in the given image List\n\n    Args:\n        imageList(list): a list of images to be pushed\n        ignore(bool): True to upload despite any warnings.\n    \"\"\"\n    for image in imageList:\n        try:\n            self.log(\"%scopying image %s ...\" % (delim, image.name), end=\"\")\n            imagePath, filename = self.downloadImage(image)\n            description = image.imageinfo[\"comment\"]\n            try:\n                self.uploadImage(imagePath, filename, description, ignore)\n                self.log(\"\u2705\")\n            except Exception as ex:\n                self.handleAPIWarnings(ex.args[0], ignoreExists=ignore)\n                if self.debug:\n                    self.show_exception(ex)\n            if self.debug:\n                print(image.imageinfo)\n        except Exception as ex:\n            self.handleException(ex, ignore)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.query","title":"<code>query(askQuery, wiki=None, pageField=None, limit=None, showProgress=False, queryDivision=1)</code>","text":"<p>query the given wiki for pages matching the given askQuery</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>askQuery(string)</code>\n            \n            \n            \n              \n                <p>Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>wiki(wikibot3rd)</code>\n            \n            \n            \n              \n                <p>the wiki to query - use fromWiki if not specified</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>pageField(string)</code>\n            \n            \n            \n              \n                <p>the field to select the pageTitle from</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>limit(int)</code>\n            \n            \n            \n              \n                <p>the limit for the query (optional)</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>showProgress(bool)</code>\n            \n            \n            \n              \n                <p>true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n      <p>Returns:\n    list: a list of pageTitles matching the given askQuery</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def query(\n    self,\n    askQuery,\n    wiki=None,\n    pageField=None,\n    limit=None,\n    showProgress=False,\n    queryDivision=1,\n):\n    \"\"\"\n    query the given wiki for pages matching the given askQuery\n\n    Args:\n        askQuery(string): Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries\n        wiki(wikibot3rd): the wiki to query - use fromWiki if not specified\n        pageField(string): the field to select the pageTitle from\n        limit(int): the limit for the query (optional)\n        showProgress(bool): true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)\n    Returns:\n        list: a list of pageTitles matching the given askQuery\n    \"\"\"\n    pageRecords = self.queryPages(\n        askQuery, wiki, limit, showProgress, queryDivision\n    )\n    if pageField is None:\n        return pageRecords.keys()\n    # use a Dict to remove duplicates\n    pagesDict = {}\n    for pageRecord in pageRecords.values():\n        if pageField in pageRecord:\n            pagesDict[pageRecord[pageField]] = True\n    return list(pagesDict.keys())\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.queryPages","title":"<code>queryPages(askQuery, wiki=None, limit=None, showProgress=False, queryDivision=1)</code>","text":"<p>query the given wiki for pagerecords matching the given askQuery</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>askQuery</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>wiki</code>\n            \n                  <code>wikibot3rd</code>\n            \n            \n              \n                <p>the wiki to query - use fromWiki if not specified</p>\n              \n            \n            \n                  <code>None</code>\n            \n          \n          \n            <code>limit</code>\n            \n                  <code>int</code>\n            \n            \n              \n                <p>the limit for the query (optional)</p>\n              \n            \n            \n                  <code>None</code>\n            \n          \n          \n            <code>showProgress</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)</p>\n              \n            \n            \n                  <code>False</code>\n            \n          \n          \n            <code>queryDivision</code>\n            \n                  <code>int</code>\n            \n            \n              \n                <p>Defines the number of subintervals the query is divided into (must be greater equal 1)</p>\n              \n            \n            \n                  <code>1</code>\n            \n          \n      \n    \n      <p>Returns:\n    list: a list of pageRecords matching the given askQuery</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def queryPages(\n    self, askQuery: str, wiki=None, limit=None, showProgress=False, queryDivision=1\n) -&gt; dict:\n    \"\"\"\n    query the given wiki for pagerecords matching the given askQuery\n\n    Args:\n        askQuery (str): Semantic Media Wiki in line query https://www.semantic-mediawiki.org/wiki/Help:Inline_queries\n        wiki (wikibot3rd): the wiki to query - use fromWiki if not specified\n        limit (int): the limit for the query (optional)\n        showProgress (bool): true if progress of the query retrieval should be indicated (default: one dot per 50 records ...)\n        queryDivision (int): Defines the number of subintervals the query is divided into (must be greater equal 1)\n    Returns:\n        list: a list of pageRecords matching the given askQuery\n    \"\"\"\n    if wiki is None:\n        wiki = self.fromWiki\n    # no wiki no pages e.g. if wikirestore is used without a -s option\n    if wiki is None:\n        pageRecords = []\n\n    if wiki.is_smw_enabled:\n        smwClient = SMWClient(\n            wiki.getSite(),\n            showProgress=showProgress,\n            queryDivision=queryDivision,\n            debug=self.debug,\n        )\n        pageRecords = smwClient.query(askQuery, limit=limit)\n    else:\n        pageRecords = self.query_via_mw_api(askQuery, wiki, limit=limit)\n    return pageRecords\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.restore","title":"<code>restore(pageTitles=None, backupPath=None, listFile=None, stdIn=False)</code>","text":"<p>restore given page titles from local backup\nIf no page titles are given the whole backup is restored.</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>pageTitles(list)</code>\n            \n            \n            \n              \n                <p>a list of pageTitles to be restored to toWiki. If None -&gt; full restore of backup</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>backupPath(str)</code>\n            \n            \n            \n              \n                <p>path to backup location</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>listFile</code>\n            \n            \n            \n              \n                \n              \n            \n            \n                  <code>None</code>\n            \n          \n          \n            <code>stdIn</code>\n            \n            \n            \n              \n                \n              \n            \n            \n                  <code>False</code>\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def restore(self, pageTitles=None, backupPath=None, listFile=None, stdIn=False):\n    \"\"\"\n    restore given page titles from local backup\n    If no page titles are given the whole backup is restored.\n\n    Args:\n        pageTitles(list): a list of pageTitles to be restored to toWiki. If None -&gt; full restore of backup\n        backupPath(str): path to backup location\n        listFile:\n        stdIn:\n    \"\"\"\n    if stdIn:\n        backupPath = os.path.dirname(pageTitles[0].strip())\n        pageTitlesfix = []\n        for i in pageTitles:\n            pageTitlesfix.append(os.path.basename(i.strip().replace(\".wiki\", \"\")))\n        pageTitles = pageTitlesfix\n    elif listFile is not None:\n        f = open(listFile, \"r\")\n        allx = f.readlines()\n        pageTitles = []\n        for i in allx:\n            pageTitles.append(os.path.basename(i.strip()).replace(\".wiki\", \"\"))\n    else:\n        if backupPath is None:\n            backupPath = self.getHomePath(f\"wikibackup/{self.toWikiId}\")\n        if pageTitles is None:\n            pageTitles = []\n            for path, subdirs, files in os.walk(backupPath):\n                for name in files:\n                    filename = os.path.join(path, name)[len(backupPath) + 1 :]\n                    if filename.endswith(\".wiki\"):\n                        pageTitles.append(filename[: -len(\".wiki\")])\n    total = len(pageTitles)\n    self.log(\n        \"restoring %d pages from %s to %s\" % (total, backupPath, self.toWikiId)\n    )\n    for i, pageTitle in enumerate(pageTitles):\n        try:\n            self.log(\n                \"%d/%d (%4.0f%%): restore %s ...\"\n                % (i + 1, total, (i + 1) / total * 100, pageTitle),\n                end=\"\",\n            )\n            wikiFilePath = f\"{backupPath}/{pageTitle}.wiki\"\n            with open(wikiFilePath, mode=\"r\") as wikiFile:\n                page_content = wikiFile.read()\n                page = self.toWiki.getPage(pageTitle)\n                page.edit(\n                    page_content,\n                    f\"modified through wikirestore by {self.toWiki.wikiUser.user}\",\n                )\n            self.log(\"\u2705\")\n        except Exception as ex:\n            self.show_exception(ex)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.show_exception","title":"<code>show_exception(ex)</code>","text":"<p>Show the given exception and, if debug mode is on, show the traceback.</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def show_exception(self, ex: Exception):\n    \"\"\"\n    Show the given exception and, if debug mode is on, show the traceback.\n    \"\"\"\n    msg = f\"\u274c: {str(ex)}\"\n    if self.debug:\n        # Append the formatted traceback to the message\n        msg += \"\\n\" + traceback.format_exc()\n\n    self.log(msg)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.upload","title":"<code>upload(files, force=False)</code>","text":"<p>push the given files\nArgs:\n    files(list): a list of filenames to be transfered to the toWiki\n    force(bool): True if images should be overwritten if they exist</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def upload(self, files, force=False):\n    \"\"\"\n    push the given files\n    Args:\n        files(list): a list of filenames to be transfered to the toWiki\n        force(bool): True if images should be overwritten if they exist\n    \"\"\"\n    total = len(files)\n    self.log(\"uploading %d files to %s\" % (total, self.toWikiId))\n    for i, file in enumerate(files):\n        try:\n            self.log(\n                \"%d/%d (%4.0f%%): uploading %s ...\"\n                % (i + 1, total, (i + 1) / total * 100, file),\n                end=\"\",\n            )\n            description = \"uploaded by wikiupload\"\n            filename = os.path.basename(file)\n            self.uploadImage(file, filename, description, force)\n            self.log(\"\u2705\")\n        except Exception as ex:\n            self.show_exception(ex)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.uploadImage","title":"<code>uploadImage(imagePath, filename, description, ignoreExists=False)</code>","text":"<p>upload an image</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>imagePath(str)</code>\n            \n            \n            \n              \n                <p>the path to the image</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>filename(str)</code>\n            \n            \n            \n              \n                <p>the filename to use</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>description(str)</code>\n            \n            \n            \n              \n                <p>the description to use</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>ignoreExists(bool)</code>\n            \n            \n            \n              \n                <p>True if it should be ignored if the image exists</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def uploadImage(self, imagePath, filename, description, ignoreExists=False):\n    \"\"\"\n    upload an image\n\n    Args:\n        imagePath(str): the path to the image\n        filename(str): the filename to use\n        description(str): the description to use\n        ignoreExists(bool): True if it should be ignored if the image exists\n    \"\"\"\n    with open(imagePath, \"rb\") as imageFile:\n        warnings = None\n        response = self.toWiki.site.upload(\n            imageFile, filename, description, ignoreExists\n        )\n        if \"warnings\" in response:\n            warnings = response[\"warnings\"]\n        if \"upload\" in response and \"warnings\" in response[\"upload\"]:\n            warningsDict = response[\"upload\"][\"warnings\"]\n            warnings = []\n            for item in warningsDict.items():\n                warnings.append(str(item))\n        if warnings:\n            raise Exception(warnings)\n</code></pre>"},{"location":"#wikibot3rd.wikipush.WikiPush.work","title":"<code>work(pageTitles, activity='copying', comment='pushed', force=False, ignore=False, withImages=False)</code>","text":"<p>work on the given page titles</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>pageTitles(list)</code>\n            \n            \n            \n              \n                <p>a list of page titles to be transfered from the formWiki to the toWiki</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>activity(str)</code>\n            \n            \n            \n              \n                <p>the activity to perform</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>comment(str)</code>\n            \n            \n            \n              \n                <p>the comment to display</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>force(bool)</code>\n            \n            \n            \n              \n                <p>True if pages should be overwritten if they exist</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>ignore(bool)</code>\n            \n            \n            \n              \n                <p>True if warning for images should be ignored (e.g if they exist)</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>withImages(bool)</code>\n            \n            \n            \n              \n                <p>True if the image on a page should also be copied</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n      <p>Returns:\n    list: a list of pageTitles for which the activity failed</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def work(\n    self,\n    pageTitles: list,\n    activity: str = \"copying\",\n    comment: str = \"pushed\",\n    force: bool = False,\n    ignore: bool = False,\n    withImages: bool = False,\n) -&gt; list:\n    \"\"\"\n    work on the given page titles\n\n    Args:\n        pageTitles(list): a list of page titles to be transfered from the formWiki to the toWiki\n        activity(str): the activity to perform\n        comment(str): the comment to display\n        force(bool): True if pages should be overwritten if they exist\n        ignore(bool): True if warning for images should be ignored (e.g if they exist)\n        withImages(bool): True if the image on a page should also be copied\n    Returns:\n        list: a list of pageTitles for which the activity failed\n    \"\"\"\n    failed = []\n    total = len(pageTitles)\n    self.log(f\"{activity} {total} pages from {self.fromWikiId} to {self.toWikiId}\")\n    for i, pageTitle in enumerate(pageTitles):\n        try:\n            percent = (i + 1) / total * 100\n            self.log(\n                f\"{i+1}/{total} ({percent:4.0f}%): {activity} ... {pageTitle}\",\n                end=\"\",\n            )\n            page = self.fromWiki.getPage(pageTitle)\n            if page.exists:\n                # is this an image?\n                if isinstance(page, Image):\n                    self.pushImages([page], ignore=ignore)\n                else:\n                    newPage = self.toWiki.getPage(pageTitle)\n                    if not newPage.exists or force:\n                        try:\n                            newPage.edit(page.text(), comment)\n                            self.log(\"\u2705\")\n                            pageOk = True\n                        except Exception as ex:\n                            pageOk = self.handleException(ex, ignore)\n                            if not pageOk:\n                                failed.append(pageTitle)\n                        if withImages and pageOk:\n                            self.pushImages(page.images(), ignore=ignore)\n                    else:\n                        self.log(\"\ud83d\udc4e\")\n            else:\n                self.log(\"\u274c\")\n                failed.append(pageTitle)\n        except Exception as ex:\n            self.show_exception(ex)\n            failed.append(pageTitle)\n    return failed\n</code></pre>"},{"location":"#wikibot3rd.wikipush.main","title":"<code>main(argv=None, mode='wikipush')</code>","text":"<p>main program.</p>\n\n            \n              Source code in <code>wikibot3rd/wikipush.py</code>\n              <pre><code>def main(argv=None, mode=\"wikipush\"):  # IGNORE:C0111\n    \"\"\"main program.\"\"\"\n\n    if argv is None:\n        argv = sys.argv[1:]\n\n    program_name = mode\n    program_version = \"v%s\" % __version__\n    program_build_date = str(__updated__)\n    program_version_message = \"%%(prog)s %s (%s)\" % (\n        program_version,\n        program_build_date,\n    )\n    program_shortdesc = \"wikipush\"\n    user_name = \"Wolfgang Fahl\"\n\n    program_license = \"\"\"%s\n\n  Created by %s on %s.\n  Copyright 2020-2024 Wolfgang Fahl. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\n\n\"\"\" % (\n        program_shortdesc,\n        user_name,\n        str(__date__),\n    )\n\n    try:\n        # Setup argument parser\n        parser = ArgumentParser(\n            description=program_license, formatter_class=RawDescriptionHelpFormatter\n        )\n        parser.add_argument(\n            \"-V\", \"--version\", action=\"version\", version=program_version_message\n        )\n        if mode == \"wikipush\":\n            parser.add_argument(\n                \"-l\",\n                \"--login\",\n                dest=\"login\",\n                action=\"store_true\",\n                help=\"login to source wiki for access permission\",\n            )\n            parser.add_argument(\n                \"-s\", \"--source\", dest=\"source\", help=\"source wiki id\", required=True\n            )\n            parser.add_argument(\n                \"-f\",\n                \"--force\",\n                dest=\"force\",\n                action=\"store_true\",\n                help=\"force to overwrite existing pages\",\n            )\n            parser.add_argument(\n                \"-i\",\n                \"--ignore\",\n                dest=\"ignore\",\n                action=\"store_true\",\n                help=\"ignore upload warnings e.g. duplicate images\",\n            )\n            parser.add_argument(\n                \"-wi\",\n                \"--withImages\",\n                dest=\"withImages\",\n                action=\"store_true\",\n                help=\"copy images on the given pages\",\n            )\n        elif mode == \"wikibackup\":\n            parser.add_argument(\n                \"-g\",\n                \"--git\",\n                dest=\"git\",\n                action=\"store_true\",\n                help=\"use git for version control\",\n            )\n            parser.add_argument(\n                \"-l\",\n                \"--login\",\n                dest=\"login\",\n                action=\"store_true\",\n                help=\"login to source wiki for access permission\",\n            )\n            parser.add_argument(\n                \"-s\", \"--source\", dest=\"source\", help=\"source wiki id\", required=True\n            )\n            parser.add_argument(\n                \"-wi\",\n                \"--withImages\",\n                dest=\"withImages\",\n                action=\"store_true\",\n                help=\"copy images on the given pages\",\n            )\n            parser.add_argument(\n                \"--backupPath\",\n                dest=\"backupPath\",\n                help=\"path where the backup should be stored\",\n                required=False,\n            )\n        elif mode == \"wikinuke\":\n            parser.add_argument(\n                \"-f\",\n                \"--force\",\n                dest=\"force\",\n                action=\"store_true\",\n                help=\"force to delete pages - default is 'dry' run only listing pages\",\n            )\n        elif mode == \"wikiedit\":\n            parser.add_argument(\n                \"--search\", dest=\"search\", help=\"search pattern\", required=False\n            )\n            parser.add_argument(\n                \"--replace\", dest=\"replace\", help=\"replace pattern\", required=False\n            )\n            parser.add_argument(\n                \"--context\",\n                dest=\"context\",\n                type=int,\n                help=\"number of context lines to show in dry run diff display\",\n                default=1,\n            )\n            parser.add_argument(\n                \"-f\",\n                \"--force\",\n                dest=\"force\",\n                action=\"store_true\",\n                help=\"force to edit pages - default is 'dry' run only listing pages\",\n            )\n            parser.add_argument(\n                \"--template\",\n                dest=\"template\",\n                help=\"Name of the template to edit\",\n                required=False,\n            )\n            parser.add_argument(\n                \"--property\",\n                dest=\"property\",\n                help=\"Name of the property in the template to edit\",\n                required=False,\n            )\n            parser.add_argument(\n                \"--value\",\n                dest=\"value\",\n                help=\"Value of the Property. If not set but property name is given the property is removed from the template\",\n                required=False,\n            )\n        elif mode == \"wikiquery\":\n            parser.add_argument(\n                \"-l\",\n                \"--login\",\n                dest=\"login\",\n                action=\"store_true\",\n                help=\"login to source wiki for access permission\",\n            )\n            parser.add_argument(\n                \"-s\", \"--source\", dest=\"source\", help=\"source wiki id\", required=True\n            )\n            parser.add_argument(\n                \"--format\",\n                dest=\"format\",\n                default=\"json\",\n                help=\"format to use for query result csv,json,lod or any of the tablefmt options of https://pypi.org/project/tabulate/\",\n            )\n            parser.add_argument(\n                \"--entityName\",\n                dest=\"entityName\",\n                default=\"data\",\n                help=\"name of the entities that are queried - only needed for some output formats - default is 'data'\",\n            )\n            parser.add_argument(\n                \"--template\",\n                help=\"name of template to extract the data from - the query needs to have a pagetitle mainlabel and retrieve pages\",\n            )\n        elif mode == \"wikiupload\":\n            parser.add_argument(\n                \"--files\", nargs=\"+\", help=\"list of files to be uploaded\", required=True\n            )\n            parser.add_argument(\n                \"-f\",\n                \"--force\",\n                dest=\"force\",\n                action=\"store_true\",\n                help=\"force to (re)upload existing files - default is false\",\n            )\n            pass\n        elif mode == \"wikirestore\":\n            parser.add_argument(\n                \"--listFile\",\n                dest=\"listFile\",\n                help=\"List of pages to restore\",\n                required=False,\n            )\n            parser.add_argument(\n                \"--backupPath\",\n                dest=\"backupPath\",\n                help=\"path the backup is stored\",\n                required=False,\n            )\n            parser.add_argument(\n                \"-s\", \"--source\", dest=\"source\", help=\"source wiki id\", required=False\n            )\n            parser.add_argument(\n                \"-l\",\n                \"--login\",\n                dest=\"login\",\n                action=\"store_true\",\n                help=\"login to source wiki for access permission\",\n            )\n            parser.add_argument(\n                \"-stdinp\",\n                dest=\"stdinp\",\n                action=\"store_true\",\n                help=\"Use the input from STD IN using pipes\",\n            )\n        if mode in [\n            \"wikipush\",\n            \"wikiedit\",\n            \"wikinuke\",\n            \"wikibackup\",\n            \"wikiquery\",\n            \"wikirestore\",\n        ]:\n            QueryCmd.add_args(parser=parser)\n            parser.add_argument(\n                \"--progress\",\n                dest=\"showProgress\",\n                action=\"store_true\",\n                help=\"shows progress for query\",\n            )\n            parser.add_argument(\n                \"-pf\",\n                \"--pageField\",\n                dest=\"pageField\",\n                help=\"query result field which contains page\",\n            )\n            parser.add_argument(\n                \"-p\",\n                \"--pages\",\n                nargs=\"+\",\n                help=\"list of page Titles to be pushed\",\n                required=False,\n            )\n            parser.add_argument(\n                \"-ui\",\n                \"--withGUI\",\n                dest=\"ui\",\n                help=\"Pop up GUI for selection\",\n                action=\"store_true\",\n                required=False,\n            )\n            parser.add_argument(\n                \"-qd\",\n                \"--queryDivision\",\n                default=1,\n                dest=\"queryDivision\",\n                type=int,\n                help=\"divide query into equidistant subintervals to limit the result size of the individual queries\",\n                required=False,\n            )\n        if mode in [\"wikiquery\"]:\n            parser.add_argument(\"--title\", help=\"the title for the query\")\n        if not mode in [\"wikibackup\", \"wikiquery\"]:\n            parser.add_argument(\n                \"-t\", \"--target\", dest=\"target\", help=\"target wiki id\", required=True\n            )\n        # Process arguments\n        args = parser.parse_args(argv)\n        if hasattr(args, \"queryDivision\"):\n            if args.queryDivision &lt; 1:\n                raise ValueError(\"queryDivision argument must be greater equal 1\")\n\n        if mode == \"wikipush\":\n            wikipush = WikiPush(\n                args.source, args.target, login=args.login, debug=args.debug\n            )\n            queryWiki = wikipush.fromWiki\n        elif mode == \"wikibackup\":\n            wikipush = WikiPush(args.source, None, login=args.login, debug=args.debug)\n            queryWiki = wikipush.fromWiki\n        elif mode == \"wikiquery\":\n            wikipush = WikiPush(args.source, None, login=args.login, debug=args.debug)\n            queryWiki = wikipush.fromWiki\n        elif mode == \"wikiupload\":\n            wikipush = WikiPush(None, args.target, debug=args.debug)\n        elif mode == \"wikirestore\":\n            wikipush = WikiPush(\n                args.source, args.target, login=args.login, debug=args.debug\n            )\n            queryWiki = wikipush.fromWiki\n        else:\n            wikipush = WikiPush(None, args.target, debug=args.debug)\n            queryWiki = wikipush.toWiki\n        # make the full args available to wikipush\n        wikipush.args = args\n        if mode == \"wikiupload\":\n            wikipush.upload(args.files, args.force)\n        else:\n            pages = None\n            if args.pages:\n                pages = args.pages\n            elif hasattr(args, \"stdinp\"):\n                if args.stdinp:\n                    pages = sys.stdin.readlines()\n            if pages is None:\n                # set the fixed language for the wikpush toolkit\n                # SMW ask\n                # see https://www.semantic-mediawiki.org/wiki/Help:Inline_queries\n                # Parser function #ask\n                args.language = \"ask\"\n                query_cmd = QueryCmd(args=args, with_default_queries=False)\n                handled = query_cmd.handle_args()\n                if handled:\n                    return 0\n                query = query_cmd.queryCode\n                if mode == \"wikiquery\":\n                    formatedQueryResults = wikipush.formatQueryResult(\n                        query,\n                        wiki=queryWiki,\n                        limit=args.limit,\n                        showProgress=args.showProgress,\n                        queryDivision=args.queryDivision,\n                        outputFormat=args.format,\n                        entityName=args.entityName,\n                        title=args.title,\n                    )\n                    if formatedQueryResults:\n                        print(formatedQueryResults)\n                    else:\n                        print(f\"Format {args.format} is not supported.\")\n                else:\n                    pages = wikipush.query(\n                        query,\n                        wiki=queryWiki,\n                        pageField=args.pageField,\n                        limit=args.limit,\n                        showProgress=args.showProgress,\n                        queryDivision=args.queryDivision,\n                    )\n            if pages is None:\n                if mode == \"wikiquery\":\n                    # we are finished\n                    return 0\n                elif mode == \"wikirestore\":\n                    # full restore\n                    wikipush.restore(\n                        pageTitles=None,\n                        backupPath=args.backupPath,\n                        listFile=args.listFile,\n                    )\n                else:\n                    raise Exception(\n                        \"no pages specified - you might want to use the -p, -q -qn or --queryFile option\"\n                    )\n            else:\n                if args.ui and len(pages) &gt; 0:\n                    pages = Selector.select(\n                        pages,\n                        action=mode.lower().lstrip(\"wiki\")[0].upper()\n                        + mode.lstrip(\"wiki\")[1:],\n                        description=\"GUI program for the mode \" + mode,\n                        title=mode,\n                    )\n                    if pages == \"Q\":  # If GUI window is closed, end the program\n                        sys.exit(0)\n                if mode == \"wikipush\":\n                    wikipush.push(\n                        pages,\n                        force=args.force,\n                        ignore=args.ignore,\n                        withImages=args.withImages,\n                    )\n                elif mode == \"wikibackup\":\n                    wikipush.backup(\n                        pages,\n                        git=args.git,\n                        withImages=args.withImages,\n                        backupPath=args.backupPath,\n                    )\n                elif mode == \"wikinuke\":\n                    wikipush.nuke(pages, force=args.force)\n                elif mode == \"wikiedit\":\n                    # two modes search&amp;replace and WikiSON property edit\n                    if args.search or args.replace:\n                        # search&amp;replace\n                        if args.search and args.replace:\n                            modify = WikiPush.getModify(\n                                args.search, args.replace, args.debug\n                            )\n                            wikipush.edit(\n                                pages,\n                                modify=modify,\n                                context=args.context,\n                                force=args.force,\n                            )\n                        else:\n                            raise Exception(\n                                \"In wikiedit search&amp;replace mode both args '--search' and '--replace' need to be set\"\n                            )\n                    else:\n                        # WikiSON property edit\n                        if len(pages) &gt; 0 and args.template and args.property:\n                            wikipush.edit_wikison(\n                                page_titles=pages,\n                                entity_type_name=args.template,\n                                property_name=args.property,\n                                value=args.value,\n                                force=args.force,\n                            )\n                        else:\n                            raise Exception(\n                                \"In wikiedit WikiSON edit mode '--pages', '--template' and '--property' need to be defined ('--value' is optional see '--help')\"\n                            )\n\n                elif mode == \"wikirestore\":\n                    wikipush.restore(\n                        pages, backupPath=args.backupPath, stdIn=args.stdinp\n                    )\n                else:\n                    raise Exception(\"undefined wikipush mode %s\" % mode)\n\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if args.debug:\n            print(traceback.format_exc())\n        return 2\n</code></pre>"},{"location":"#wikibot3rd.wikiquery","title":"<code>wikiquery</code>","text":"<p>Created on 2024-04-18</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikirestore","title":"<code>wikirestore</code>","text":"<p>Created on 2021-02-16</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikitext","title":"<code>wikitext</code>","text":"<p>Created on 2023-02-24\n  @author: tholzheim</p>"},{"location":"#wikibot3rd.wikitext.WikiMarkup","title":"<code>WikiMarkup</code>","text":"<p>Provides methods to modify, query and update Templates in wiki markup\nsee https://en.wikipedia.org/wiki/Help:Wikitext</p>\n\n              \n                Source code in <code>wikibot3rd/wikitext.py</code>\n                <pre><code>class WikiMarkup:\n    \"\"\"\n    Provides methods to modify, query and update Templates in wiki markup\n    see https://en.wikipedia.org/wiki/Help:Wikitext\n    \"\"\"\n\n    def __init__(self, page_title: str, wiki_markup: str = None, debug: bool = False):\n        \"\"\"\n\n        Args:\n            page_title: page title of the wiki_markup file\n            wiki_markup: WikiPage content as string. If None tries to init the wiki_markup from source location\n        \"\"\"\n        self.page_title = page_title\n        self.debug = debug\n        self._wiki_markup = wiki_markup\n        self._parsed_wiki_markup: typing.Optional[wtp.WikiText] = None\n\n    @property\n    def wiki_markup(self) -&gt; str:\n        \"\"\"\n        Get wiki markup. If wikimarkup was parsed the parsed markup is converted back to wiki markup\n\n        Returns:\n            str\n        \"\"\"\n        if self._parsed_wiki_markup is None:\n            return self._wiki_markup\n        else:\n            return str(self._parsed_wiki_markup)\n\n    @wiki_markup.setter\n    def wiki_markup(self, wiki_markup: str):\n        self._wiki_markup = wiki_markup\n        if self._parsed_wiki_markup is not None:\n            # update parsed wiki_markup\n            self._parsed_wiki_markup = wtp.parse(wiki_markup)\n\n    @property\n    def parsed_wiki_markup(self) -&gt; wtp.WikiText:\n        \"\"\"\n        Get WikiText. If not already parsed the markup is parsed\n\n        Returns:\n            wtp:WikiText\n        \"\"\"\n        if self._parsed_wiki_markup is None and self._wiki_markup is not None:\n            self._parsed_wiki_markup = wtp.parse(self._wiki_markup)\n        return self._parsed_wiki_markup\n\n    @parsed_wiki_markup.setter\n    def parsed_wiki_markup(self, parsed_wiki_markup: wtp.WikiText):\n        self._parsed_wiki_markup = parsed_wiki_markup\n\n    def _get_templates_by_name(\n        self, template_name: str, match: dict = typing.Dict[str, str]\n    ) -&gt; typing.List[Template]:\n        \"\"\"\n        Returns the templates matching the given name and if additional matches are defined the values of the template\n        also have to match these\n        Args:\n            template_name: name of the template\n            match(dict): Additional matching criteria\n\n        Returns:\n            list of templates with the given name matching the given criteria\n        \"\"\"\n        if match is None:\n            match = {}\n        if self.parsed_wiki_markup is None or self.parsed_wiki_markup.templates is None:\n            # markup has no templates\n            return []\n        target_template_name = template_name.strip()\n        matching_templates = []\n        for template in self.parsed_wiki_markup.templates:\n            name = template.name.strip()\n            if name == target_template_name:\n                matches = True\n                for key, value in match.items():\n                    if not template.has_arg(key, value):\n                        matches = False\n                if matches:\n                    matching_templates.append(template)\n        return matching_templates\n\n    @classmethod\n    def _get_template_arguments(cls, template: Template) -&gt; typing.Dict[str, str]:\n        \"\"\"\n        Get the arguments of the given template\n        Args:\n            template: template to extract the arguments from\n\n        Returns:\n            dict: arguments of the template\n        \"\"\"\n        args = dict()\n        for arg in template.arguments:\n            name = arg.name.strip()\n            value = arg.value.strip()\n            args[name] = value\n        return args\n\n    def add_template(self, template_name: str, data: dict):\n        \"\"\"\n        Adds the given data as template with the given name to this wikifile.\n        The data is added as new template object to the wikifile.\n        Args:\n            template_name(str): Name of the template the data should be inserted in\n            data(dict): Data that should be saved in form of a template\n        \"\"\"\n        template_markup = \"{{\" + template_name + \"\\n\"\n        for key, value in data.items():\n            if value is not None:\n                template_markup += f\"|{key}={value}\\n\"\n        template_markup += \"}}\"\n        template = Template(template_markup)\n        self.wiki_markup = f\"{self.wiki_markup}\\n{template}\"\n\n    def update_template(\n        self,\n        template_name: str,\n        args: dict,\n        overwrite: bool = False,\n        update_all: bool = False,\n        match: typing.Optional[typing.Dict[str, str]] = None,\n    ):\n        \"\"\"\n        Updates the given template the values from the given dict args.\n        If force is set to True existing values will be overwritten.\n        Args:\n            template_name(str): name of the template that should be updated\n            args(dict): Dict containing the arguments that should be set. key=argument name, value=argument value\n            overwrite(bool): If True existing values will be overwritten\n            update_all(bool): If True all matching attributes are updated.\n                              Otherwise, only one template is updated if matched multiple an error is raised.\n            match(dict): matching criteria for the template.\n\n        Returns:\n            Nothing\n        \"\"\"\n        if match is None:\n            match = {}\n        matching_templates = self._get_templates_by_name(template_name, match=match)\n        if matching_templates:\n            if len(matching_templates) &gt; 1 and not update_all:\n                warnings.warn(\n                    \"More than one template were matched. Either improve the matching criteria or enable update_all\",\n                    UserWarning,\n                )\n                pass\n            else:\n                for template in matching_templates:\n                    self._update_arguments(template, args, overwrite)\n        else:\n            self.add_template(template_name, args)\n\n    @classmethod\n    def _update_arguments(cls, template: Template, args: dict, overwrite: bool = False):\n        \"\"\"\n        Updates the arguments of the given template with the values of the given dict (args)\n\n        Args:\n            template: Template that should be updated\n            args(dict): Dict containing the arguments that should be set. key=argument name, value=argument value\n            overwrite(bool): If True existing values will be overwritten\n\n        Returns:\n            Nothing\n        \"\"\"\n        postfix = \"\\n\"\n        for key, value in args.items():\n            if template.has_arg(key):\n                # update argument\n                if overwrite:\n                    template.del_arg(key)\n                    if value is not None:\n                        template.set_arg(key, str(value) + postfix)\n                else:\n                    pass\n            else:\n                if value is not None:\n                    template.set_arg(key, str(value) + postfix, preserve_spacing=False)\n\n    def extract_template(\n        self, template_name: str, match: typing.Optional[typing.Dict[str, str]] = None\n    ) -&gt; typing.List[typing.Dict[str, str]]:\n        \"\"\"\n        Extracts the template data and returns it as dict\n\n        Args:\n            template_name: name of the template that should be extracted\n            match(dict): Additional matching criteria\n\n        Returns:\n            list of dicts: records of the templates that match the given name\n        \"\"\"\n        if match is None:\n            match = {}\n        templates = self._get_templates_by_name(template_name, match=match)\n        lod = []\n        for template in templates:\n            if template is None:\n                continue\n            records = self._get_template_arguments(template)\n            if records:\n                lod.append(records)\n        return lod\n\n    def __str__(self) -&gt; str:\n        return self.wiki_markup\n</code></pre>"},{"location":"#wikibot3rd.wikitext.WikiMarkup.parsed_wiki_markup","title":"<code>parsed_wiki_markup: wtp.WikiText</code>\n\n  \n      <code>property</code>\n      <code>writable</code>","text":"<p>Get WikiText. If not already parsed the markup is parsed</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>wtp</code>            \n                  <code>WikiText</code>\n            \n            \n              \n                <p>WikiText</p>"},{"location":"#wikibot3rd.wikitext.WikiMarkup.wiki_markup","title":"<code>wiki_markup: str</code>\n\n  \n      <code>property</code>\n      <code>writable</code>","text":"<p>Get wiki markup. If wikimarkup was parsed the parsed markup is converted back to wiki markup</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>str</code>\n            \n            \n              \n                <p>str</p>"},{"location":"#wikibot3rd.wikitext.WikiMarkup.__init__","title":"<code>__init__(page_title, wiki_markup=None, debug=False)</code>","text":"<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>page_title</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>page title of the wiki_markup file</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>wiki_markup</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>WikiPage content as string. If None tries to init the wiki_markup from source location</p>\n              \n            \n            \n                  <code>None</code>\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikitext.py</code>\n              <pre><code>def __init__(self, page_title: str, wiki_markup: str = None, debug: bool = False):\n    \"\"\"\n\n    Args:\n        page_title: page title of the wiki_markup file\n        wiki_markup: WikiPage content as string. If None tries to init the wiki_markup from source location\n    \"\"\"\n    self.page_title = page_title\n    self.debug = debug\n    self._wiki_markup = wiki_markup\n    self._parsed_wiki_markup: typing.Optional[wtp.WikiText] = None\n</code></pre>"},{"location":"#wikibot3rd.wikitext.WikiMarkup.add_template","title":"<code>add_template(template_name, data)</code>","text":"<p>Adds the given data as template with the given name to this wikifile.\nThe data is added as new template object to the wikifile.\nArgs:\n    template_name(str): Name of the template the data should be inserted in\n    data(dict): Data that should be saved in form of a template</p>\n\n            \n              Source code in <code>wikibot3rd/wikitext.py</code>\n              <pre><code>def add_template(self, template_name: str, data: dict):\n    \"\"\"\n    Adds the given data as template with the given name to this wikifile.\n    The data is added as new template object to the wikifile.\n    Args:\n        template_name(str): Name of the template the data should be inserted in\n        data(dict): Data that should be saved in form of a template\n    \"\"\"\n    template_markup = \"{{\" + template_name + \"\\n\"\n    for key, value in data.items():\n        if value is not None:\n            template_markup += f\"|{key}={value}\\n\"\n    template_markup += \"}}\"\n    template = Template(template_markup)\n    self.wiki_markup = f\"{self.wiki_markup}\\n{template}\"\n</code></pre>"},{"location":"#wikibot3rd.wikitext.WikiMarkup.extract_template","title":"<code>extract_template(template_name, match=None)</code>","text":"<p>Extracts the template data and returns it as dict</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>template_name</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>name of the template that should be extracted</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>match(dict)</code>\n            \n            \n            \n              \n                <p>Additional matching criteria</p>\n              \n            \n            \n                required\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>List[Dict[str, str]]</code>\n            \n            \n              \n                <p>list of dicts: records of the templates that match the given name</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikitext.py</code>\n              <pre><code>def extract_template(\n    self, template_name: str, match: typing.Optional[typing.Dict[str, str]] = None\n) -&gt; typing.List[typing.Dict[str, str]]:\n    \"\"\"\n    Extracts the template data and returns it as dict\n\n    Args:\n        template_name: name of the template that should be extracted\n        match(dict): Additional matching criteria\n\n    Returns:\n        list of dicts: records of the templates that match the given name\n    \"\"\"\n    if match is None:\n        match = {}\n    templates = self._get_templates_by_name(template_name, match=match)\n    lod = []\n    for template in templates:\n        if template is None:\n            continue\n        records = self._get_template_arguments(template)\n        if records:\n            lod.append(records)\n    return lod\n</code></pre>"},{"location":"#wikibot3rd.wikitext.WikiMarkup.update_template","title":"<code>update_template(template_name, args, overwrite=False, update_all=False, match=None)</code>","text":"<p>Updates the given template the values from the given dict args.\nIf force is set to True existing values will be overwritten.\nArgs:\n    template_name(str): name of the template that should be updated\n    args(dict): Dict containing the arguments that should be set. key=argument name, value=argument value\n    overwrite(bool): If True existing values will be overwritten\n    update_all(bool): If True all matching attributes are updated.\n                      Otherwise, only one template is updated if matched multiple an error is raised.\n    match(dict): matching criteria for the template.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n            \n            \n              \n                <p>Nothing</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikitext.py</code>\n              <pre><code>def update_template(\n    self,\n    template_name: str,\n    args: dict,\n    overwrite: bool = False,\n    update_all: bool = False,\n    match: typing.Optional[typing.Dict[str, str]] = None,\n):\n    \"\"\"\n    Updates the given template the values from the given dict args.\n    If force is set to True existing values will be overwritten.\n    Args:\n        template_name(str): name of the template that should be updated\n        args(dict): Dict containing the arguments that should be set. key=argument name, value=argument value\n        overwrite(bool): If True existing values will be overwritten\n        update_all(bool): If True all matching attributes are updated.\n                          Otherwise, only one template is updated if matched multiple an error is raised.\n        match(dict): matching criteria for the template.\n\n    Returns:\n        Nothing\n    \"\"\"\n    if match is None:\n        match = {}\n    matching_templates = self._get_templates_by_name(template_name, match=match)\n    if matching_templates:\n        if len(matching_templates) &gt; 1 and not update_all:\n            warnings.warn(\n                \"More than one template were matched. Either improve the matching criteria or enable update_all\",\n                UserWarning,\n            )\n            pass\n        else:\n            for template in matching_templates:\n                self._update_arguments(template, args, overwrite)\n    else:\n        self.add_template(template_name, args)\n</code></pre>"},{"location":"#wikibot3rd.wikitext.WikiSON","title":"<code>WikiSON</code>","text":"<p>WikiSON Api to edit WikiSON entities</p>\n\n              \n                Source code in <code>wikibot3rd/wikitext.py</code>\n                <pre><code>class WikiSON:\n    \"\"\"\n    WikiSON Api to edit WikiSON entities\n    \"\"\"\n\n    def __init__(self, page_title: str, wiki_markup: str):\n        \"\"\"\n        constructor\n        Args:\n            page_title: name of the wiki page\n            wiki_markup: markup of the wiki page\n        \"\"\"\n        self.wiki_markup = WikiMarkup(page_title, wiki_markup)\n\n    def get(self, entity_type_name: str) -&gt; typing.Optional[typing.Dict[str, str]]:\n        \"\"\"\n        Get the WikiSON entity by the given name\n        Args:\n            entity_type_name: name of the WikiSON entity type e.g. Scholar, Event\n\n        Raises:\n            Exception: if wiki markup contains more than one WikiSON with the same entity type name\n\n        Returns:\n            dict: record of the entity\n        \"\"\"\n        records = self.wiki_markup.extract_template(entity_type_name)\n        if len(records) &gt; 1:\n            raise Exception(\n                \"More than one WikiSON with the same entity type on one Page\"\n            )\n        if len(records) == 1:\n            record = records[0]\n        else:\n            record = None\n        return record\n\n    def set(self, entity_type_name: str, record: dict) -&gt; str:\n        \"\"\"\n        Set WikiSON entity with the given type and data\n        Args:\n            entity_type_name: name of the WikiSON entity type e.g. Scholar, Event\n            record: data to add to the WikiSON entity\n\n        Returns:\n            str: wiki markup of the page\n        \"\"\"\n        self.wiki_markup.update_template(entity_type_name, args=record, overwrite=True)\n        return self.wiki_markup.wiki_markup\n</code></pre>"},{"location":"#wikibot3rd.wikitext.WikiSON.__init__","title":"<code>__init__(page_title, wiki_markup)</code>","text":"<p>constructor\nArgs:\n    page_title: name of the wiki page\n    wiki_markup: markup of the wiki page</p>\n\n            \n              Source code in <code>wikibot3rd/wikitext.py</code>\n              <pre><code>def __init__(self, page_title: str, wiki_markup: str):\n    \"\"\"\n    constructor\n    Args:\n        page_title: name of the wiki page\n        wiki_markup: markup of the wiki page\n    \"\"\"\n    self.wiki_markup = WikiMarkup(page_title, wiki_markup)\n</code></pre>"},{"location":"#wikibot3rd.wikitext.WikiSON.get","title":"<code>get(entity_type_name)</code>","text":"<p>Get the WikiSON entity by the given name\nArgs:\n    entity_type_name: name of the WikiSON entity type e.g. Scholar, Event</p>\n\n\n<p>Raises:</p>\n    \n      \n        \n          Type\n          Description\n        \n      \n      \n          \n            \n                  <code>Exception</code>\n            \n            \n              \n                <p>if wiki markup contains more than one WikiSON with the same entity type name</p>\n              \n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>dict</code>            \n                  <code>Optional[Dict[str, str]]</code>\n            \n            \n              \n                <p>record of the entity</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikitext.py</code>\n              <pre><code>def get(self, entity_type_name: str) -&gt; typing.Optional[typing.Dict[str, str]]:\n    \"\"\"\n    Get the WikiSON entity by the given name\n    Args:\n        entity_type_name: name of the WikiSON entity type e.g. Scholar, Event\n\n    Raises:\n        Exception: if wiki markup contains more than one WikiSON with the same entity type name\n\n    Returns:\n        dict: record of the entity\n    \"\"\"\n    records = self.wiki_markup.extract_template(entity_type_name)\n    if len(records) &gt; 1:\n        raise Exception(\n            \"More than one WikiSON with the same entity type on one Page\"\n        )\n    if len(records) == 1:\n        record = records[0]\n    else:\n        record = None\n    return record\n</code></pre>"},{"location":"#wikibot3rd.wikitext.WikiSON.set","title":"<code>set(entity_type_name, record)</code>","text":"<p>Set WikiSON entity with the given type and data\nArgs:\n    entity_type_name: name of the WikiSON entity type e.g. Scholar, Event\n    record: data to add to the WikiSON entity</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n                  <code>str</code>\n            \n            \n              \n                <p>wiki markup of the page</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikitext.py</code>\n              <pre><code>def set(self, entity_type_name: str, record: dict) -&gt; str:\n    \"\"\"\n    Set WikiSON entity with the given type and data\n    Args:\n        entity_type_name: name of the WikiSON entity type e.g. Scholar, Event\n        record: data to add to the WikiSON entity\n\n    Returns:\n        str: wiki markup of the page\n    \"\"\"\n    self.wiki_markup.update_template(entity_type_name, args=record, overwrite=True)\n    return self.wiki_markup.wiki_markup\n</code></pre>"},{"location":"#wikibot3rd.wikiupload","title":"<code>wikiupload</code>","text":"<p>Created on 2020-11-12</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikiuser","title":"<code>wikiuser</code>","text":"<p>Created on 2020-11-01</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikiuser.WikiCredentials","title":"<code>WikiCredentials</code>\n\n\n  \n      <code>dataclass</code>","text":"<p>Base class for wiki credentials</p>\n\n              \n                Source code in <code>wikibot3rd/wikiuser.py</code>\n                <pre><code>@dataclass\nclass WikiCredentials:\n    \"\"\"\n    Base class for wiki credentials\n    \"\"\"\n\n    password: str = field(default=None, repr=False)\n    cypher: str = field(default=None, repr=False)\n    secret: str = field(default=None, repr=False)\n    salt: str = field(default=None, repr=False)\n\n    def __post_init__(self):\n        \"\"\"\n        if a password is available immediately encrypt it\n        \"\"\"\n        if self.password is not None:\n            self.encrypt(self.password)\n            self.password = None\n\n    @property\n    def encrypted(self) -&gt; bool:\n        \"\"\"\n        Property to check if the credentials are encrypted.\n\n        Returns:\n            bool: True if the credentials are encrypted, False otherwise.\n        \"\"\"\n        encrypted = self.cypher is not None\n        return encrypted\n\n    @property\n    def needs_encrypt(self) -&gt; bool:\n        needs_encrypt = self.password is not None and not self.encrypted\n        return needs_encrypt\n\n    def encrypt(self, password: str):\n        \"\"\"\n        Encrypt the given password\n        \"\"\"\n        crypt = Crypt.getRandomCrypt()\n        self.secret = crypt.encrypt(password)\n        self.cypher = crypt.cypher.decode()\n        self.salt = crypt.salt.decode()\n\n    def decrypt(self) -&gt; str:\n        \"\"\"\n        Decrypt and return the password\n        \"\"\"\n        if not self.encrypted:\n            raise ValueError(\"Data is not encrypted\")\n        c = Crypt(self.cypher, 20, self.salt)\n        password = c.decrypt(self.secret)\n        return password\n\n    def get_password(self) -&gt; str:\n        \"\"\"\n        get my decrypted password\n\n        Returns:\n            str: the decrypted password for this user\n        \"\"\"\n        if not self.encrypted:\n            raise ValueError(\"clear text password state\")\n        password = self.decrypt()\n        return password\n\n    def getPassword(self) -&gt; str:\n        return self.get_password()\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiCredentials.encrypted","title":"<code>encrypted: bool</code>\n\n  \n      <code>property</code>","text":"<p>Property to check if the credentials are encrypted.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>bool</code>            \n                  <code>bool</code>\n            \n            \n              \n                <p>True if the credentials are encrypted, False otherwise.</p>"},{"location":"#wikibot3rd.wikiuser.WikiCredentials.__post_init__","title":"<code>__post_init__()</code>","text":"<p>if a password is available immediately encrypt it</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def __post_init__(self):\n    \"\"\"\n    if a password is available immediately encrypt it\n    \"\"\"\n    if self.password is not None:\n        self.encrypt(self.password)\n        self.password = None\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiCredentials.decrypt","title":"<code>decrypt()</code>","text":"<p>Decrypt and return the password</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def decrypt(self) -&gt; str:\n    \"\"\"\n    Decrypt and return the password\n    \"\"\"\n    if not self.encrypted:\n        raise ValueError(\"Data is not encrypted\")\n    c = Crypt(self.cypher, 20, self.salt)\n    password = c.decrypt(self.secret)\n    return password\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiCredentials.encrypt","title":"<code>encrypt(password)</code>","text":"<p>Encrypt the given password</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def encrypt(self, password: str):\n    \"\"\"\n    Encrypt the given password\n    \"\"\"\n    crypt = Crypt.getRandomCrypt()\n    self.secret = crypt.encrypt(password)\n    self.cypher = crypt.cypher.decode()\n    self.salt = crypt.salt.decode()\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiCredentials.get_password","title":"<code>get_password()</code>","text":"<p>get my decrypted password</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n                  <code>str</code>\n            \n            \n              \n                <p>the decrypted password for this user</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def get_password(self) -&gt; str:\n    \"\"\"\n    get my decrypted password\n\n    Returns:\n        str: the decrypted password for this user\n    \"\"\"\n    if not self.encrypted:\n        raise ValueError(\"clear text password state\")\n    password = self.decrypt()\n    return password\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser","title":"<code>WikiUser</code>\n\n\n  \n      <code>dataclass</code>","text":"<p>\n              Bases: <code>WikiUserData</code></p>\n\n\n      <p>WikiUser handling</p>\n\n              \n                Source code in <code>wikibot3rd/wikiuser.py</code>\n                <pre><code>@dataclass\nclass WikiUser(WikiUserData):\n    \"\"\"\n    WikiUser handling\n    \"\"\"\n\n    interactive: bool = False\n    debug: bool = False\n    lenient: bool = True\n    filePath: str = None\n    yes: bool = False\n\n    def get_wiki_url(self) -&gt; str:\n        \"\"\"\n        return the full url of this wiki\n\n        Returns:\n            str: the full url of this wiki\n        \"\"\"\n        return f\"{self.url}{self.scriptPath}\"\n\n    def getWikiUrl(self) -&gt; str:\n        \"\"\"\n        return the full url of this wiki\n\n        Returns:\n            str: the full url of this wiki\n        \"\"\"\n        return self.get_wiki_url()\n\n    def getInteractiveFields(self):\n        \"\"\"\n        Get the non-credential fields from WikiUserData plus 'password' for interactive input.\n        \"\"\"\n        # Get all field names from WikiCredentials to exclude\n        credentials_field_names = {field.name for field in fields(WikiCredentials)}\n\n        # Create a list to hold the non-credential fields in the declared order\n        interactive_fields = []\n\n        # Iterate over WikiUserData fields in the declared order\n        for field in fields(WikiUserData):\n            if field.name not in credentials_field_names:\n                interactive_fields.append(field)\n\n        # Add the 'password' field explicitly, assuming it's part of WikiCredentials\n        password_field = next(\n            field for field in fields(WikiCredentials) if field.name == \"password\"\n        )\n        interactive_fields.append(password_field)\n\n        return interactive_fields\n\n    def ask_password(self) -&gt; str:\n        \"\"\"\n        Ask the user for a password twice to ensure it is entered correctly.\n\n        Returns:\n            str: The confirmed password entered by the user.\n        \"\"\"\n        while True:\n            password = getpass.getpass(\"Password (hidden): \")\n            if not password:\n                print(\"Password cannot be empty. Please enter a valid password.\")\n                continue\n            confirm_password = getpass.getpass(\"Confirm Password (hidden): \")\n            if password == confirm_password:\n                return password\n            else:\n                print(\"Passwords do not match. Please try again.\")\n\n    def interactiveSave(\n        self, yes: bool = False, interactive: bool = False, filePath=None\n    ):\n        \"\"\"\n        save me\n\n        Args:\n            yes (bool): if True save without asking\n            interactive (bool): if True get interactive input\n            filePath (str): the path where to save the credentials ini file\n        \"\"\"\n        text = \"\"\n        interactive_fields = self.getInteractiveFields()\n\n        for field in interactive_fields:\n            value = getattr(self, field.name)\n            if interactive:\n                print(text)\n                if field.name == \"password\":\n                    # Ensure password is provided\n                    if not value:\n                        inputValue = self.ask_password()  # Ask for password twice\n                        self.encrypt(inputValue)  # Encrypt immediately after input\n                        value = \"********\"  # Placeholder for display purposes\n                else:\n                    inputMsg = f\"{field.name} ({value}): \"\n                    inputValue = input(inputMsg)\n                    if inputValue:\n                        setattr(self, field.name, inputValue)\n                        value = inputValue\n            text += f\"\\n  {field.name}={value}\"\n        if not yes:\n            answer = input(\n                f\"shall i store credentials for {text}\\nto an ini file? yes/no y/n\"\n            )\n            yes = \"y\" in answer or \"yes\" in answer\n        if yes:\n            ini_path = self.save(filePath)\n            print(f\"wikiuser details available at {ini_path}\")\n\n    def __str__(self):\n        return f\"{self.user} {self.wikiId}\"\n\n    @staticmethod\n    def getIniPath():\n        \"\"\"\n        get the path for the ini file\n        \"\"\"\n        return str(Path.home() / \".mediawiki-japi\")\n\n    @staticmethod\n    def iniFilePath(wikiId: str):\n        \"\"\"\n        get the path for the ini file for the given wikiId\n        \"\"\"\n        user = getpass.getuser()\n        iniPath = WikiUser.getIniPath()\n        return f\"{iniPath}/{user}_{wikiId}.ini\"\n\n    @classmethod\n    def ofWikiId(cls, wikiId: str, lenient=False) -&gt; \"WikiUser\":\n        \"\"\"\n        create a wikiUser for the given wikiId\n\n        Args:\n            wikiId (str): the wikiId of the user to be created\n            lenient (bool): if True ignore parsing errors in the ini file\n\n        Returns:\n            WikiUser: the wikiUser for this wikiId\n        \"\"\"\n        path = cls.iniFilePath(wikiId)\n        try:\n            config = cls.readPropertyFile(path)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                f'the wiki with the wikiID \"{wikiId}\" does not have a corresponding configuration file ... you might want to create one with the wikiuser command'\n            )\n        return cls.ofDict(config, lenient=lenient)\n\n    def save(self, iniFilePath=None) -&gt; str:\n        \"\"\"\n        save me to a propertyFile\n\n        Returns:\n            str: the path of the property file\n        \"\"\"\n        if iniFilePath is None:\n            iniPath = self.getIniPath()\n            os.makedirs(iniPath, exist_ok=True)\n            iniFilePath = self.iniFilePath(self.wikiId)\n\n        with open(iniFilePath, \"w\") as iniFile:\n            isodate = datetime.datetime.now().isoformat()\n            content = f\"# Mediawiki JAPI credentials for {self.wikiId}\\n# created by py-3rdparty-mediawiki WikiUser at {isodate}\\n\"\n            for field in fields(WikiUserData):\n                value = getattr(self, field.name)\n                if value is not None:\n                    content += f\"{field.name}={value}\\n\"\n            iniFile.write(content)\n        return iniFilePath\n\n    @staticmethod\n    def readPropertyFile(filepath, sep=\"=\", comment_char=\"#\") -&gt; Dict[str, str]:\n        \"\"\"\n        Read the file passed as parameter as a properties file.\n\n        https://stackoverflow.com/a/31852401/1497139\n\n        \"\"\"\n        props = {}\n        with open(filepath, \"rt\") as f:\n            for line in f:\n                l = line.strip()\n                if l and not l.startswith(comment_char):\n                    key_value = l.split(sep)\n                    key = key_value[0].strip()\n                    value = sep.join(key_value[1:]).strip().strip('\"')\n                    props[key] = value\n        return props\n\n    @classmethod\n    def getWikiUsers(cls, lenient: bool = False):\n        \"\"\"\n        get all WikiUsers from the ini files in the iniPath\n        \"\"\"\n        wikiUsers = {}\n        iniPath = cls.getIniPath()\n        if os.path.isdir(iniPath):\n            for entry in os.scandir(iniPath):\n                if entry.name.endswith(\".ini\") and entry.is_file():\n                    try:\n                        config = cls.readPropertyFile(entry.path)\n                        wikiUser = cls.ofDict(config, lenient=lenient)\n                        wikiUsers[wikiUser.wikiId] = wikiUser\n                    except Exception as ex:\n                        print(f\"error in {entry.path}: {str(ex)}\")\n        return wikiUsers\n\n    @classmethod\n    def ofDict(cls, userDict: dict, encrypted=True, lenient=False, encrypt=True):\n        \"\"\"\n        create a WikiUser from the given dictionary\n\n        Args:\n        userDict (dict): dictionary with WikiUser properties\n        encrypted(bool): if True the password is encrypted in the dict\n        lenient (bool): if True ignore missing fields\n        encrypt (bool): if True encrypt the password (if not encrypted yet)\n\n        Returns:\n        WikiUser: the WikiUser created from the dictionary\n        \"\"\"\n        if \"url\" in userDict and userDict[\"url\"] is not None:\n            # fix broken escapes e.g. http\\://waihekepedia.bitplan.com\n            userDict[\"url\"] = userDict[\"url\"].replace(r\"\\:\", \":\")\n\n        # is the password currently encrypted?\n        is_encrypted = userDict.get(\"cypher\") is not None\n\n        if encrypted != is_encrypted and not lenient:\n            raise Exception(\"Encryption state mismatch\")\n\n        err_msg = \"\"\n        try:\n            wikiUser = cls(**userDict)\n        except Exception as ex:\n            err_msg = str(ex) + \"\\n\"\n        if wikiUser and wikiUser.is_smw:\n            for field in fields(WikiUserData):\n                if field.name not in userDict and not lenient:\n                    if field.default is None:\n                        if is_encrypted and field.name in [\"cypher\", \"secret\", \"salt\"]:\n                            err_msg += f\"\\n{field.name} missing for encrypted data\"\n                        elif field.name not in [\n                            \"cypher\",\n                            \"secret\",\n                            \"salt\",\n                            \"password\",\n                            \"encrypted\",\n                        ]:\n                            err_msg += f\"\\n{field.name} missing\"\n        if err_msg:\n            raise Exception(err_msg)\n\n        if encrypt and wikiUser.needs_encrypt:\n            wikiUser.encrypt(wikiUser.password)\n        return wikiUser\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.ask_password","title":"<code>ask_password()</code>","text":"<p>Ask the user for a password twice to ensure it is entered correctly.</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n                  <code>str</code>\n            \n            \n              \n                <p>The confirmed password entered by the user.</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def ask_password(self) -&gt; str:\n    \"\"\"\n    Ask the user for a password twice to ensure it is entered correctly.\n\n    Returns:\n        str: The confirmed password entered by the user.\n    \"\"\"\n    while True:\n        password = getpass.getpass(\"Password (hidden): \")\n        if not password:\n            print(\"Password cannot be empty. Please enter a valid password.\")\n            continue\n        confirm_password = getpass.getpass(\"Confirm Password (hidden): \")\n        if password == confirm_password:\n            return password\n        else:\n            print(\"Passwords do not match. Please try again.\")\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.getIniPath","title":"<code>getIniPath()</code>\n\n  \n      <code>staticmethod</code>","text":"<p>get the path for the ini file</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>@staticmethod\ndef getIniPath():\n    \"\"\"\n    get the path for the ini file\n    \"\"\"\n    return str(Path.home() / \".mediawiki-japi\")\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.getInteractiveFields","title":"<code>getInteractiveFields()</code>","text":"<p>Get the non-credential fields from WikiUserData plus 'password' for interactive input.</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def getInteractiveFields(self):\n    \"\"\"\n    Get the non-credential fields from WikiUserData plus 'password' for interactive input.\n    \"\"\"\n    # Get all field names from WikiCredentials to exclude\n    credentials_field_names = {field.name for field in fields(WikiCredentials)}\n\n    # Create a list to hold the non-credential fields in the declared order\n    interactive_fields = []\n\n    # Iterate over WikiUserData fields in the declared order\n    for field in fields(WikiUserData):\n        if field.name not in credentials_field_names:\n            interactive_fields.append(field)\n\n    # Add the 'password' field explicitly, assuming it's part of WikiCredentials\n    password_field = next(\n        field for field in fields(WikiCredentials) if field.name == \"password\"\n    )\n    interactive_fields.append(password_field)\n\n    return interactive_fields\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.getWikiUrl","title":"<code>getWikiUrl()</code>","text":"<p>return the full url of this wiki</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n                  <code>str</code>\n            \n            \n              \n                <p>the full url of this wiki</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def getWikiUrl(self) -&gt; str:\n    \"\"\"\n    return the full url of this wiki\n\n    Returns:\n        str: the full url of this wiki\n    \"\"\"\n    return self.get_wiki_url()\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.getWikiUsers","title":"<code>getWikiUsers(lenient=False)</code>\n\n  \n      <code>classmethod</code>","text":"<p>get all WikiUsers from the ini files in the iniPath</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>@classmethod\ndef getWikiUsers(cls, lenient: bool = False):\n    \"\"\"\n    get all WikiUsers from the ini files in the iniPath\n    \"\"\"\n    wikiUsers = {}\n    iniPath = cls.getIniPath()\n    if os.path.isdir(iniPath):\n        for entry in os.scandir(iniPath):\n            if entry.name.endswith(\".ini\") and entry.is_file():\n                try:\n                    config = cls.readPropertyFile(entry.path)\n                    wikiUser = cls.ofDict(config, lenient=lenient)\n                    wikiUsers[wikiUser.wikiId] = wikiUser\n                except Exception as ex:\n                    print(f\"error in {entry.path}: {str(ex)}\")\n    return wikiUsers\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.get_wiki_url","title":"<code>get_wiki_url()</code>","text":"<p>return the full url of this wiki</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n                  <code>str</code>\n            \n            \n              \n                <p>the full url of this wiki</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def get_wiki_url(self) -&gt; str:\n    \"\"\"\n    return the full url of this wiki\n\n    Returns:\n        str: the full url of this wiki\n    \"\"\"\n    return f\"{self.url}{self.scriptPath}\"\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.iniFilePath","title":"<code>iniFilePath(wikiId)</code>\n\n  \n      <code>staticmethod</code>","text":"<p>get the path for the ini file for the given wikiId</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>@staticmethod\ndef iniFilePath(wikiId: str):\n    \"\"\"\n    get the path for the ini file for the given wikiId\n    \"\"\"\n    user = getpass.getuser()\n    iniPath = WikiUser.getIniPath()\n    return f\"{iniPath}/{user}_{wikiId}.ini\"\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.interactiveSave","title":"<code>interactiveSave(yes=False, interactive=False, filePath=None)</code>","text":"<p>save me</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>yes</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>if True save without asking</p>\n              \n            \n            \n                  <code>False</code>\n            \n          \n          \n            <code>interactive</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>if True get interactive input</p>\n              \n            \n            \n                  <code>False</code>\n            \n          \n          \n            <code>filePath</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>the path where to save the credentials ini file</p>\n              \n            \n            \n                  <code>None</code>\n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def interactiveSave(\n    self, yes: bool = False, interactive: bool = False, filePath=None\n):\n    \"\"\"\n    save me\n\n    Args:\n        yes (bool): if True save without asking\n        interactive (bool): if True get interactive input\n        filePath (str): the path where to save the credentials ini file\n    \"\"\"\n    text = \"\"\n    interactive_fields = self.getInteractiveFields()\n\n    for field in interactive_fields:\n        value = getattr(self, field.name)\n        if interactive:\n            print(text)\n            if field.name == \"password\":\n                # Ensure password is provided\n                if not value:\n                    inputValue = self.ask_password()  # Ask for password twice\n                    self.encrypt(inputValue)  # Encrypt immediately after input\n                    value = \"********\"  # Placeholder for display purposes\n            else:\n                inputMsg = f\"{field.name} ({value}): \"\n                inputValue = input(inputMsg)\n                if inputValue:\n                    setattr(self, field.name, inputValue)\n                    value = inputValue\n        text += f\"\\n  {field.name}={value}\"\n    if not yes:\n        answer = input(\n            f\"shall i store credentials for {text}\\nto an ini file? yes/no y/n\"\n        )\n        yes = \"y\" in answer or \"yes\" in answer\n    if yes:\n        ini_path = self.save(filePath)\n        print(f\"wikiuser details available at {ini_path}\")\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.ofDict","title":"<code>ofDict(userDict, encrypted=True, lenient=False, encrypt=True)</code>\n\n  \n      <code>classmethod</code>","text":"<p>create a WikiUser from the given dictionary</p>\n<p>Args:\nuserDict (dict): dictionary with WikiUser properties\nencrypted(bool): if True the password is encrypted in the dict\nlenient (bool): if True ignore missing fields\nencrypt (bool): if True encrypt the password (if not encrypted yet)</p>\n<p>Returns:\nWikiUser: the WikiUser created from the dictionary</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>@classmethod\ndef ofDict(cls, userDict: dict, encrypted=True, lenient=False, encrypt=True):\n    \"\"\"\n    create a WikiUser from the given dictionary\n\n    Args:\n    userDict (dict): dictionary with WikiUser properties\n    encrypted(bool): if True the password is encrypted in the dict\n    lenient (bool): if True ignore missing fields\n    encrypt (bool): if True encrypt the password (if not encrypted yet)\n\n    Returns:\n    WikiUser: the WikiUser created from the dictionary\n    \"\"\"\n    if \"url\" in userDict and userDict[\"url\"] is not None:\n        # fix broken escapes e.g. http\\://waihekepedia.bitplan.com\n        userDict[\"url\"] = userDict[\"url\"].replace(r\"\\:\", \":\")\n\n    # is the password currently encrypted?\n    is_encrypted = userDict.get(\"cypher\") is not None\n\n    if encrypted != is_encrypted and not lenient:\n        raise Exception(\"Encryption state mismatch\")\n\n    err_msg = \"\"\n    try:\n        wikiUser = cls(**userDict)\n    except Exception as ex:\n        err_msg = str(ex) + \"\\n\"\n    if wikiUser and wikiUser.is_smw:\n        for field in fields(WikiUserData):\n            if field.name not in userDict and not lenient:\n                if field.default is None:\n                    if is_encrypted and field.name in [\"cypher\", \"secret\", \"salt\"]:\n                        err_msg += f\"\\n{field.name} missing for encrypted data\"\n                    elif field.name not in [\n                        \"cypher\",\n                        \"secret\",\n                        \"salt\",\n                        \"password\",\n                        \"encrypted\",\n                    ]:\n                        err_msg += f\"\\n{field.name} missing\"\n    if err_msg:\n        raise Exception(err_msg)\n\n    if encrypt and wikiUser.needs_encrypt:\n        wikiUser.encrypt(wikiUser.password)\n    return wikiUser\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.ofWikiId","title":"<code>ofWikiId(wikiId, lenient=False)</code>\n\n  \n      <code>classmethod</code>","text":"<p>create a wikiUser for the given wikiId</p>\n\n\n<p>Parameters:</p>\n    \n      \n        \n          Name\n          Type\n          Description\n          Default\n        \n      \n      \n          \n            <code>wikiId</code>\n            \n                  <code>str</code>\n            \n            \n              \n                <p>the wikiId of the user to be created</p>\n              \n            \n            \n                required\n            \n          \n          \n            <code>lenient</code>\n            \n                  <code>bool</code>\n            \n            \n              \n                <p>if True ignore parsing errors in the ini file</p>\n              \n            \n            \n                  <code>False</code>\n            \n          \n      \n    \n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>WikiUser</code>            \n                  <code>WikiUser</code>\n            \n            \n              \n                <p>the wikiUser for this wikiId</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>@classmethod\ndef ofWikiId(cls, wikiId: str, lenient=False) -&gt; \"WikiUser\":\n    \"\"\"\n    create a wikiUser for the given wikiId\n\n    Args:\n        wikiId (str): the wikiId of the user to be created\n        lenient (bool): if True ignore parsing errors in the ini file\n\n    Returns:\n        WikiUser: the wikiUser for this wikiId\n    \"\"\"\n    path = cls.iniFilePath(wikiId)\n    try:\n        config = cls.readPropertyFile(path)\n    except FileNotFoundError:\n        raise FileNotFoundError(\n            f'the wiki with the wikiID \"{wikiId}\" does not have a corresponding configuration file ... you might want to create one with the wikiuser command'\n        )\n    return cls.ofDict(config, lenient=lenient)\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.readPropertyFile","title":"<code>readPropertyFile(filepath, sep='=', comment_char='#')</code>\n\n  \n      <code>staticmethod</code>","text":"<p>Read the file passed as parameter as a properties file.</p>\n<p>https://stackoverflow.com/a/31852401/1497139</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>@staticmethod\ndef readPropertyFile(filepath, sep=\"=\", comment_char=\"#\") -&gt; Dict[str, str]:\n    \"\"\"\n    Read the file passed as parameter as a properties file.\n\n    https://stackoverflow.com/a/31852401/1497139\n\n    \"\"\"\n    props = {}\n    with open(filepath, \"rt\") as f:\n        for line in f:\n            l = line.strip()\n            if l and not l.startswith(comment_char):\n                key_value = l.split(sep)\n                key = key_value[0].strip()\n                value = sep.join(key_value[1:]).strip().strip('\"')\n                props[key] = value\n    return props\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUser.save","title":"<code>save(iniFilePath=None)</code>","text":"<p>save me to a propertyFile</p>\n\n\n    <p>Returns:</p>\n    \n      \n        \nName          Type\n          Description\n        \n      \n      \n          \n<code>str</code>            \n                  <code>str</code>\n            \n            \n              \n                <p>the path of the property file</p>\n              \n            \n          \n      \n    \n\n            \n              Source code in <code>wikibot3rd/wikiuser.py</code>\n              <pre><code>def save(self, iniFilePath=None) -&gt; str:\n    \"\"\"\n    save me to a propertyFile\n\n    Returns:\n        str: the path of the property file\n    \"\"\"\n    if iniFilePath is None:\n        iniPath = self.getIniPath()\n        os.makedirs(iniPath, exist_ok=True)\n        iniFilePath = self.iniFilePath(self.wikiId)\n\n    with open(iniFilePath, \"w\") as iniFile:\n        isodate = datetime.datetime.now().isoformat()\n        content = f\"# Mediawiki JAPI credentials for {self.wikiId}\\n# created by py-3rdparty-mediawiki WikiUser at {isodate}\\n\"\n        for field in fields(WikiUserData):\n            value = getattr(self, field.name)\n            if value is not None:\n                content += f\"{field.name}={value}\\n\"\n        iniFile.write(content)\n    return iniFilePath\n</code></pre>"},{"location":"#wikibot3rd.wikiuser.WikiUserData","title":"<code>WikiUserData</code>\n\n\n  \n      <code>dataclass</code>","text":"<p>\n              Bases: <code>WikiCredentials</code></p>\n\n\n      <p>User credentials for a specific wiki</p>\n\n              \n                Source code in <code>wikibot3rd/wikiuser.py</code>\n                <pre><code>@dataclass\nclass WikiUserData(WikiCredentials):\n    \"\"\"\n    User credentials for a specific wiki\n    \"\"\"\n\n    wikiId: str = None\n    url: str = None\n    scriptPath: str = \"\"\n    version: str = \"MediaWiki 1.39.10\"\n    user: str = None\n    email: str = None\n    is_smw: bool = True\n\n    def __post_init__(self):\n        WikiCredentials.__post_init__(self)\n        if isinstance(self.is_smw, str):\n            normalized_value = self.is_smw.strip().lower()\n            if normalized_value in {\"yes\", \"y\", \"true\"}:\n                self.is_smw = True\n            elif normalized_value in {\"no\", \"n\", \"false\"}:\n                self.is_smw = False\n            else:\n                raise ValueError(f\"Invalid value for is_smw: {self.is_smw}\")\n</code></pre>"},{"location":"#wikibot3rd.wikiuser_cmd","title":"<code>wikiuser_cmd</code>","text":"<p>Created on 2024-09-26</p>\n<p>@author: wf</p>"},{"location":"#wikibot3rd.wikiuser_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>WikiUser credential handling</p>\n\n            \n              Source code in <code>wikibot3rd/wikiuser_cmd.py</code>\n              <pre><code>def main(argv=None):\n    \"\"\"\n    WikiUser credential handling\n    \"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n\n    program_name = os.path.basename(sys.argv[0])\n    program_version = \"v%s\" % __version__\n    program_build_date = str(__updated__)\n    program_version_message = \"%%(prog)s %s (%s)\" % (\n        program_version,\n        program_build_date,\n    )\n    program_shortdesc = \"WikiUser credential handling\"\n    user_name = \"Wolfgang Fahl\"\n\n    program_license = f\"\"\"{program_shortdesc}\n\n  Created by {user_name} on {str(__date__)}.\n  Copyright 2020-2024 Wolfgang Fahl. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\n\nUSAGE\n\"\"\"\n\n    try:\n        # Setup argument parser\n        parser = ArgumentParser(\n            description=program_license, formatter_class=RawDescriptionHelpFormatter\n        )\n        parser.add_argument(\n            \"-d\",\n            \"--debug\",\n            dest=\"debug\",\n            action=\"count\",\n            help=\"set debug level [default: %(default)s]\",\n        )\n        parser.add_argument(\"-e\", \"--email\", dest=\"email\", help=\"email of the user\")\n        parser.add_argument(\"-f\", \"--file\", dest=\"filePath\", help=\"ini-file path\")\n        parser.add_argument(\"-i\", \"--interactive\", action=\"store_true\")\n        parser.add_argument(\"-l\", \"--url\", dest=\"url\", help=\"url of the wiki\")\n        parser.add_argument(\n            \"-L\",\n            \"--lenient\",\n            dest=\"lenient\",\n            action=\"store_true\",\n            help=\"be lenient with missing fields\",\n        )\n        parser.add_argument(\"-p\", \"--password\", dest=\"password\", help=\"password\")\n        parser.add_argument(\n            \"-s\",\n            \"--scriptPath\",\n            dest=\"scriptPath\",\n            help=\"script path default: %(default)s)\",\n            default=\"\",\n        )\n        parser.add_argument(\n            \"-u\",\n            \"--user\",\n            dest=\"user\",\n            help=\"os user id default: %(default)s)\",\n            default=getpass.getuser(),\n        )\n        parser.add_argument(\n            \"-v\",\n            \"--wikiVersion\",\n            dest=\"version\",\n            default=\"MediaWiki 1.39.1\",\n            help=\"version of the wiki default: %(default)s)\",\n        )\n        parser.add_argument(\n            \"-V\", \"--version\", action=\"version\", version=program_version_message\n        )\n        parser.add_argument(\"-w\", \"--wikiId\", dest=\"wikiId\", help=\"wiki Id\")\n        parser.add_argument(\n            \"-y\",\n            \"--yes\",\n            dest=\"yes\",\n            action=\"store_true\",\n            help=\"immediately store without asking\",\n        )\n        parser.add_argument(\n            \"--smw\", dest=\"is_smw\", default=\"true\", help=\"is this a semantic mediawiki?\"\n        )\n        # Process arguments\n        args = parser.parse_args(argv)\n        argsDict = vars(args)\n        wikiuser = WikiUser.ofDict(\n            argsDict, encrypted=False, lenient=True, encrypt=False\n        )\n        wikiuser.interactiveSave(args.yes, args.interactive, args.filePath)\n\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        if DEBUG:\n            raise (e)\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if getattr(args, \"debug\", False):\n            print(traceback.format_exc())\n        return 2\n</code></pre>"}]}